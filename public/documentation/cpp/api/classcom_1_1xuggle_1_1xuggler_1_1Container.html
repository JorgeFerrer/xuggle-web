<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xuggle: com::xuggle::xuggler::Container Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecom.html">com</a>::<a class="el" href="namespacecom_1_1xuggle.html">xuggle</a>::<a class="el" href="namespacecom_1_1xuggle_1_1xuggler.html">xuggler</a>::<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html">Container</a>
  </div>
</div>
<div class="contents">
<h1>com::xuggle::xuggler::Container Class Reference</h1><!-- doxytag: class="com::xuggle::xuggler::Container" --><!-- doxytag: inherits="com::xuggle::xuggler::IContainer" --><code>#include &lt;<a class="el" href="Container_8h-source.html">Container.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for com::xuggle::xuggler::Container:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1Container__inherit__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1Container__inherit__map" alt="Inheritance graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1Container__inherit__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio..." alt="" coords="5,84,232,111"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="11,7,227,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for com::xuggle::xuggler::Container:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1Container__coll__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1Container__coll__map" alt="Collaboration graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1Container__coll__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio..." alt="" coords="8,180,235,206"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="13,100,229,126"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1AtomicInteger.html" title="Internal only." alt="" coords="5,6,237,33"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classcom_1_1xuggle_1_1xuggler_1_1Container-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="Container_8h-source.html#l00035">35</a> of file <a class="el" href="Container_8h-source.html">Container.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a88474b8409fddb99f53b5bc2f6a860b">setInputBufferLength</a> (uint32_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffer length Xuggler will suggest to FFMPEG for reading inputs.  <a href="#a88474b8409fddb99f53b5bc2f6a860b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4d0aefbe2c8213d2566e7a6df83fc017">getInputBufferLength</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the input buffer length.  <a href="#4d0aefbe2c8213d2566e7a6df83fc017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#5c1433736092da13424735411f92cf99">isOpened</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this container opened?  <a href="#5c1433736092da13424735411f92cf99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bff6463a42d13ce72b8f4ff122fc9b15">isHeaderWritten</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a header been successfully written?  <a href="#bff6463a42d13ce72b8f4ff122fc9b15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070">open</a> (const char *url, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> type, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *pContainerFormat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open this container and make it ready for reading or writing.  <a href="#958973be9670bf5c3090ce246360b070"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#1171e6664c2238563e35b6182ff073eb">open</a> (const char *url, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> type, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *pContainerFormat, bool, bool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open this container and make it ready for reading or writing, optionally reading as far into the container as necessary to find all streams.  <a href="#1171e6664c2238563e35b6182ff073eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fe5f6450c9f1a38cc1617baf98e5a7bf">getContainerFormat</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object being used for this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a>, or null if the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> doesn't yet know.  <a href="#fe5f6450c9f1a38cc1617baf98e5a7bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8">getType</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the type of this container.  <a href="#cb30481cf91632e1e6de7674e1ef92f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#8db00c9340d6aafa29ce46d66429dbb5">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the container.  <a href="#8db00c9340d6aafa29ce46d66429dbb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#61e44ea796f8a4516827268b7d506588">close</a> (bool)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#91feaac97271cd5e8308729f18e84760">getNumStreams</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of streams in this container.  <a href="#91feaac97271cd5e8308729f18e84760"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbc015aeee158dbb7e571500cf0018db">getStream</a> (uint32_t position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the stream at the given position.  <a href="#bbc015aeee158dbb7e571500cf0018db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ca9af5946b65f4f2280241ad57b860cc">addNewStream</a> (int32_t id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new stream in this container and returns it.  <a href="#ca9af5946b65f4f2280241ad57b860cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#2e4dca124e41521350735e78a5e0fd59">readNextPacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the next packet into the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a>.  <a href="#2e4dca124e41521350735e78a5e0fd59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#7d41ce13583cbedfd55a0f2b8f38b7b6">writePacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, bool forceInterleave)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the contents of the packet to the container.  <a href="#7d41ce13583cbedfd55a0f2b8f38b7b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#b01206e3ec2168f3fb6eabfb1525f1d8">writePacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the contents of the packet to the container, but make sure the packets are interleaved.  <a href="#b01206e3ec2168f3fb6eabfb1525f1d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#894bffc35224c8f0e3947aa7fb821ed7">writeHeader</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a header, if needed, for this container.  <a href="#894bffc35224c8f0e3947aa7fb821ed7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a819c2aa3e1509493132f600012a1b5b">writeTrailer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a trailer, if needed, for this container.  <a href="#a819c2aa3e1509493132f600012a1b5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AVFormatContext *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#6d50eaaf36b5864c64922ad8fbd48e4a">getFormatContext</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716">queryStreamMetaData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to read all the meta data in this stream, potentially by reading ahead and decoding packets.  <a href="#c9b1fcb51b448e84a4e62d97bf07b716"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a3fdac358b46c778278a864efdd062e3">seekKeyFrame</a> (int streamIndex, int64_t timestamp, int32_t flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#3d26cf3a258c11367468802b75fabcd1">getDuration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the duration, if known, of this container.  <a href="#3d26cf3a258c11367468802b75fabcd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d5f4120e63c0bc4dccf2ee8c37771364">getStartTime</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the starting timestamp in microseconds of the first packet of the earliest stream in this container.  <a href="#d5f4120e63c0bc4dccf2ee8c37771364"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#316b8205188f0ac40f60ad00fcbf2983">getFileSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file size in bytes of this container.  <a href="#316b8205188f0ac40f60ad00fcbf2983"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a8a88f87119ac97f667b292aa1d19eb6">getBitRate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the calculated overall bit rate of this file.  <a href="#a8a88f87119ac97f667b292aa1d19eb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fdce37ee74b7a4cc8f45a2b9ecc06d41">setPreload</a> (int32_t preload)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the container has not already been opened, sets the AVFormatContext.preload property which can be useful in some circumstances such as when dealing with mpeg formats.  <a href="#fdce37ee74b7a4cc8f45a2b9ecc06d41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d1b240a1bb3a040814ae513cd78c7f91">getPreload</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The amount container will attemtp to preload.  <a href="#d1b240a1bb3a040814ae513cd78c7f91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#e74c019ad63453cc2584f0a752fd79f8">setMaxDelay</a> (int32_t maxdelay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the max delay for the AVFormatContext.max_delay property.  <a href="#e74c019ad63453cc2584f0a752fd79f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fda72b06c5c37e1de2b962e691581290">getMaxDelay</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the AVFormatContext.max_delay property if possible.  <a href="#fda72b06c5c37e1de2b962e691581290"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4100ba10f4ed468f93e0e406d8df966f">getNumProperties</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of settable properties on this object.  <a href="#4100ba10f4ed468f93e0e406d8df966f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#53a5cc27420bd775af445db84c5ec95a">getPropertyMetaData</a> (int32_t propertyNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#53a5cc27420bd775af445db84c5ec95a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#36743c0c7add3bcd5653296bbab941af">getPropertyMetaData</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#36743c0c7add3bcd5653296bbab941af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#19db2d967d4470afb196a3237a96681d">setProperty</a> (const char *name, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a property on this Object.  <a href="#19db2d967d4470afb196a3237a96681d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#f7f620dc708bf23f978efaa39230ab07">setProperty</a> (const char *name, double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#f7f620dc708bf23f978efaa39230ab07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#661c4c4c35c42b56947ab186d3a183ad">setProperty</a> (const char *name, int64_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#661c4c4c35c42b56947ab186d3a183ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c91b7be505f35547be20061e4462d377">setProperty</a> (const char *name, bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#c91b7be505f35547be20061e4462d377"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#92404787199b49ef1d33348db55f629d">setProperty</a> (const char *name, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#92404787199b49ef1d33348db55f629d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d249081d220c772f8e0d7c9f569a6d5b">getPropertyAsString</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a property on this Object.  <a href="#d249081d220c772f8e0d7c9f569a6d5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ae0d0772742776f6a91c6b1763917242">getPropertyAsDouble</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a double;.  <a href="#ae0d0772742776f6a91c6b1763917242"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c2576ac8fb9b1c5cf9257b47f0081b56">getPropertyAsLong</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an long;.  <a href="#c2576ac8fb9b1c5cf9257b47f0081b56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#9820ba26dd86a4db0d185d047454916f">getPropertyAsRational</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;.  <a href="#9820ba26dd86a4db0d185d047454916f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbf3ccc481d3c88a0b2c4d1a508d56c0">getPropertyAsBoolean</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a boolean.  <a href="#bbf3ccc481d3c88a0b2c4d1a508d56c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#34b5a0ead185e980905b1b379bbd6291">getFlags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flags associated with this object.  <a href="#34b5a0ead185e980905b1b379bbd6291"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#83173a1086878cdef9f645c7f8c14a8c">setFlags</a> (int32_t newFlags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flags to use with this object.  <a href="#83173a1086878cdef9f645c7f8c14a8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#0214b27eb3bddf589d2b4bc481091c5d">getFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a> flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the setting for the specified flag.  <a href="#0214b27eb3bddf589d2b4bc481091c5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#6812f6402105fd2424f01b3ed34b059f">setFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a> flag, bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flag.  <a href="#6812f6402105fd2424f01b3ed34b059f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c60bbfd16ab2e713ed98c330189135f5">getURL</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the URL the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> was opened with.  <a href="#c60bbfd16ab2e713ed98c330189135f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9e8a8e23fefa87a8ca34ee132c9d16a">flushPackets</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush all packets to output.  <a href="#c9e8a8e23fefa87a8ca34ee132c9d16a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#68fd2f39ddf1be3cbe7db4d95ccfbf12">getReadRetryCount</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of times <a class="el" href="">IContainer#readNextPacket(IPacket)</a> will retry a read if it gets a <a class="el" href="">IError.Type#ERROR_AGAIN</a> value back.  <a href="#68fd2f39ddf1be3cbe7db4d95ccfbf12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#e069c6c46b2566530a9d5f5ed236473c">setReadRetryCount</a> (int32_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the read retry count.  <a href="#e069c6c46b2566530a9d5f5ed236473c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ac1057eaa815ad8cc1492f823112141b">getParameters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parameters that will be used when opening.  <a href="#ac1057eaa815ad8cc1492f823112141b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4b08ae798f60caf917852e56351b71bb">setParameters</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *parameters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parameters for this container.  <a href="#4b08ae798f60caf917852e56351b71bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#0ebc043b97ce12dfd43f28f26f3cced8">canStreamsBeAddedDynamically</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can streams be added dynamically to this container?  <a href="#0ebc043b97ce12dfd43f28f26f3cced8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#668b512eb384f55c03dfd3961ca1462a">getMetaData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> for this object, or null if none.  <a href="#668b512eb384f55c03dfd3961ca1462a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#1242ab31447bb274441dbf0f97c68771">setMetaData</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *metaData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> on this object, overriding any previous meta data.  <a href="#1242ab31447bb274441dbf0f97c68771"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#f901720a3ce47813525d459a54f3c3ad">createSDPData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the given buffer with a null-terminated ASCII set of bytes representing SDP data that is suitable for use with an RTSP-based system.  <a href="#f901720a3ce47813525d459a54f3c3ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#005b81a5cef01432eb74f74873c64185">setForcedAudioCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all audio streams are encoded with the given audio codec when demuxing.  <a href="#005b81a5cef01432eb74f74873c64185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#875da3ccedd3927a024857cc52c35640">setForcedVideoCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all video streams are encoded with the given video codec when demuxing.  <a href="#875da3ccedd3927a024857cc52c35640"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#5eb5146e5f01df2fc0ab2029ca75488c">setForcedSubtitleCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all subtitle streams are encoded with the given subtitle codec when demuxing.  <a href="#5eb5146e5f01df2fc0ab2029ca75488c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c71a98f5487b92fab88cc5f36299b536">seekKeyFrame</a> (int32_t streamIndex, int64_t minTimeStamp, int64_t targetTimeStamp, int64_t maxTimeStamp, int32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL - Seeks to timestamp in the container.  <a href="#c71a98f5487b92fab88cc5f36299b536"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#aee9db293e888cf451fcac0f17dd943b">~Container</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#dd0ea21cc22204a12fb3c059c07ae16c">Container</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="aee9db293e888cf451fcac0f17dd943b"></a><!-- doxytag: member="com::xuggle::xuggler::Container::~Container" ref="aee9db293e888cf451fcac0f17dd943b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::Container::~Container           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00071">71</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00072"></a>00072   {
<a name="l00073"></a>00073     reset();
<a name="l00074"></a>00074     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00075"></a>00075       avformat_free_context(mFormatContext);
<a name="l00076"></a>00076     <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Destroyed container: %p"</span>, <span class="keyword">this</span>);
<a name="l00077"></a>00077   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd0ea21cc22204a12fb3c059c07ae16c"></a><!-- doxytag: member="com::xuggle::xuggler::Container::Container" ref="dd0ea21cc22204a12fb3c059c07ae16c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::Container::Container           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00055">55</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="IContainerParameters_8cpp-source.html#l00041">com::xuggle::xuggler::IContainerParameters::make()</a>, and <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00056"></a>00056   {
<a name="l00057"></a>00057     <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Making container: %p"</span>, <span class="keyword">this</span>);
<a name="l00058"></a>00058     mFormatContext = avformat_alloc_context();
<a name="l00059"></a>00059     <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00060"></a>00060       <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00061"></a>00061     
<a name="l00062"></a>00062     mIsOpened = <span class="keyword">false</span>;
<a name="l00063"></a>00063     mIsMetaDataQueried=<span class="keyword">false</span>;
<a name="l00064"></a>00064     mNeedTrailerWrite = <span class="keyword">false</span>;
<a name="l00065"></a>00065     mNumStreams = 0;
<a name="l00066"></a>00066     mInputBufferLength = 0;
<a name="l00067"></a>00067     mReadRetryCount = 1;
<a name="l00068"></a>00068     mParameters = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html#4a56858e83db1ef92963451af1cd1169" title="Create a new parameters object with default settings.">IContainerParameters::make</a>();
<a name="l00069"></a>00069   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a88474b8409fddb99f53b5bc2f6a860b"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setInputBufferLength" ref="a88474b8409fddb99f53b5bc2f6a860b" args="(uint32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setInputBufferLength           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the buffer length Xuggler will suggest to FFMPEG for reading inputs. 
<p>
If called when a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> is open, the call is ignored and -1 is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The suggested buffer size. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>size on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#38b0b9d59587da84e5f46129fcbe96c3">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00097">97</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00098"></a>00098   {
<a name="l00099"></a>00099     int32_t retval = -1;
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (mIsOpened)
<a name="l00101"></a>00101     {
<a name="l00102"></a>00102       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to set input buffer length while file is opened; ignoring"</span>);
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104     <span class="keywordflow">else</span>
<a name="l00105"></a>00105     {
<a name="l00106"></a>00106       mInputBufferLength = size;
<a name="l00107"></a>00107       retval = size;
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109     <span class="keywordflow">return</span> retval;
<a name="l00110"></a>00110   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4d0aefbe2c8213d2566e7a6df83fc017"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getInputBufferLength" ref="4d0aefbe2c8213d2566e7a6df83fc017" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t com::xuggle::xuggler::Container::getInputBufferLength           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the input buffer length. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The input buffer length Xuggler's told FFMPEG to assume. 0 means FFMPEG should choose it's own size (and it'll probably be 32768). </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#55cd201f53a1ba5164ebe1450aa9f4cf">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00113">113</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00114"></a>00114   {
<a name="l00115"></a>00115     <span class="keywordflow">return</span> mInputBufferLength;
<a name="l00116"></a>00116   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5c1433736092da13424735411f92cf99"></a><!-- doxytag: member="com::xuggle::xuggler::Container::isOpened" ref="5c1433736092da13424735411f92cf99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Container::isOpened           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this container opened? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if opened; false if not. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#7a9582bad53dceece938ced81a948326">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00119">119</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00369">addNewStream()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00120"></a>00120   {
<a name="l00121"></a>00121     <span class="keywordflow">return</span> mIsOpened;
<a name="l00122"></a>00122   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bff6463a42d13ce72b8f4ff122fc9b15"></a><!-- doxytag: member="com::xuggle::xuggler::Container::isHeaderWritten" ref="bff6463a42d13ce72b8f4ff122fc9b15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Container::isHeaderWritten           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has a header been successfully written? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if yes, false if no. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#23d39d461a6c1f42fd2b37d63dfc9573">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00125">125</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00369">addNewStream()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00126"></a>00126   {
<a name="l00127"></a>00127     <span class="keywordflow">return</span> (mIsOpened &amp;&amp; mNeedTrailerWrite);
<a name="l00128"></a>00128   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="958973be9670bf5c3090ce246360b070"></a><!-- doxytag: member="com::xuggle::xuggler::Container::open" ref="958973be9670bf5c3090ce246360b070" args="(const char *url, Type type, IContainerFormat *pContainerFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td>
          <td class="paramname"> <em>pContainerFormat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open this container and make it ready for reading or writing. 
<p>
The caller must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#8db00c9340d6aafa29ce46d66429dbb5">close()</a> when done, but if not, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will eventually close them later but warn to the logging system.  <p>
This just forwards to <a class="el" href="">open(String, Type, IContainerFormat, boolean, boolean)</a> passing false for aStreamsCanBeAddedDynamically, and true for aLookForAllStreams. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>The resource to open; The format of this string is any url that FFMPEG supports (including additional protocols if added through the <a class="el" href="namespacecom_1_1xuggle_1_1xuggler_1_1io.html" title="This package contains the XUGGLER IO library which is used to register callbacks...">xuggler.io</a> library). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pContainerFormat</em>&nbsp;</td><td>A pointer to a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ContainerFormat.html">ContainerFormat</a> object specifying the format of this container, or 0 (NULL) if you want us to guess.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c4ebd5f91b50093a33a03b9891b09af">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00131">131</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00133"></a>00133   {
<a name="l00134"></a>00134     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070" title="Open this container and make it ready for reading or writing.">open</a>(url, type, pContainerFormat, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l00135"></a>00135   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1171e6664c2238563e35b6182ff073eb"></a><!-- doxytag: member="com::xuggle::xuggler::Container::open" ref="1171e6664c2238563e35b6182ff073eb" args="(const char *url, Type type, IContainerFormat *pContainerFormat, bool, bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td>
          <td class="paramname"> <em>pContainerFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aStreamsCanBeAddedDynamically</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aQueryStreamMetaData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open this container and make it ready for reading or writing, optionally reading as far into the container as necessary to find all streams. 
<p>
The caller must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#8db00c9340d6aafa29ce46d66429dbb5">close()</a> when done, but if not, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will eventually close them later but warn to the logging system. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>The resource to open; The format of this string is any url that FFMPEG supports (including additional protocols if added through the <a class="el" href="namespacecom_1_1xuggle_1_1xuggler_1_1io.html" title="This package contains the XUGGLER IO library which is used to register callbacks...">xuggler.io</a> library). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pContainerFormat</em>&nbsp;</td><td>A pointer to a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ContainerFormat.html">ContainerFormat</a> object specifying the format of this container, or 0 (NULL) if you want us to guess. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStreamsCanBeAddedDynamically</em>&nbsp;</td><td>If true, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070" title="Open this container and make it ready for reading or writing.">open()</a> will expect that new streams can be added at any time, even after the format header has been read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aQueryStreamMetaData</em>&nbsp;</td><td>If true, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070" title="Open this container and make it ready for reading or writing.">open()</a> will call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716">queryStreamMetaData()</a> on this container, which will potentially block until it has ready enough data to find all streams in a container. If false, it will only block to read a minimal header for this container format.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1fb363cc644d10e07c95868c2e3ce66d">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00138">138</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="IContainer_8h-source.html#l00107">com::xuggle::xuggler::IContainer::READ</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00142"></a>00142   {
<a name="l00143"></a>00143     int32_t retval = -1;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     <span class="comment">// reset if an open is called before a close.</span>
<a name="l00146"></a>00146     reset();
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149       <span class="comment">// always reset to a new one</span>
<a name="l00150"></a>00150       mFormatContext = avformat_alloc_context();
<a name="l00151"></a>00151       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00152"></a>00152         <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00153"></a>00153     }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     <span class="keywordflow">if</span> (url &amp;&amp; *url)
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157       <span class="keywordflow">if</span> (type == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l00158"></a>00158       {
<a name="l00159"></a>00159         retval = openOutputURL(url, pContainerFormat,
<a name="l00160"></a>00160             aStreamsCanBeAddedDynamically);
<a name="l00161"></a>00161       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a>)
<a name="l00162"></a>00162       {
<a name="l00163"></a>00163         retval = openInputURL(url, pContainerFormat,
<a name="l00164"></a>00164             aStreamsCanBeAddedDynamically, aLookForAllStreams);
<a name="l00165"></a>00165       }
<a name="l00166"></a>00166       <span class="keywordflow">else</span>
<a name="l00167"></a>00167       {
<a name="l00168"></a>00168         <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(<span class="keyword">false</span>, <span class="stringliteral">"Invalid type for open"</span>);
<a name="l00169"></a>00169         retval = -1;
<a name="l00170"></a>00170       }
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00173"></a>00173     <span class="keywordflow">return</span> retval;
<a name="l00174"></a>00174   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fe5f6450c9f1a38cc1617baf98e5a7bf"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getContainerFormat" ref="fe5f6450c9f1a38cc1617baf98e5a7bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> * com::xuggle::xuggler::Container::getContainerFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object being used for this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a>, or null if the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> doesn't yet know. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object, or null. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#aa5c811008064fb4c630e972d1fc0ca3">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00177">177</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="IContainerFormat_8cpp-source.html#l00033">com::xuggle::xuggler::IContainerFormat::make()</a>, <a class="el" href="ContainerFormat_8cpp-source.html#l00051">com::xuggle::xuggler::ContainerFormat::setInputFormat()</a>, and <a class="el" href="ContainerFormat_8cpp-source.html#l00062">com::xuggle::xuggler::ContainerFormat::setOutputFormat()</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00631">writeHeader()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00178"></a>00178   {
<a name="l00179"></a>00179     ContainerFormat *retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html#88feb20f330d4b602ac37e745f7ca471" title="Create a new IContainerFormat object.">ContainerFormat::make</a>();
<a name="l00180"></a>00180     <span class="keywordflow">if</span> (retval)
<a name="l00181"></a>00181     {
<a name="l00182"></a>00182       <span class="keywordflow">if</span> (mFormatContext)
<a name="l00183"></a>00183       {
<a name="l00184"></a>00184         <span class="keywordflow">if</span> (mFormatContext-&gt;iformat)
<a name="l00185"></a>00185           retval-&gt;setInputFormat(mFormatContext-&gt;iformat);
<a name="l00186"></a>00186         <span class="keywordflow">if</span> (mFormatContext-&gt;oformat)
<a name="l00187"></a>00187           retval-&gt;setOutputFormat(mFormatContext-&gt;oformat);
<a name="l00188"></a>00188       }
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190     <span class="keywordflow">return</span> retval;
<a name="l00191"></a>00191   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cb30481cf91632e1e6de7674e1ef92f8"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getType" ref="cb30481cf91632e1e6de7674e1ef92f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">IContainer::Type</a> com::xuggle::xuggler::Container::getType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find out the type of this container. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Type of this container. <a class="el" href="">IContainer.Type#READ</a> if not yet opened. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#da0f091c4272a46c83b3d1f9fd73e732">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00348">348</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="IContainer_8h-source.html#l00107">com::xuggle::xuggler::IContainer::READ</a>, and <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00420">close()</a>, <a class="el" href="Container_8cpp-source.html#l01046">flushPackets()</a>, <a class="el" href="Container_8cpp-source.html#l01104">getMetaData()</a>, <a class="el" href="Container_8cpp-source.html#l00631">writeHeader()</a>, <a class="el" href="Container_8cpp-source.html#l00557">writePacket()</a>, and <a class="el" href="Container_8cpp-source.html#l00708">writeTrailer()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00349"></a>00349   {
<a name="l00350"></a>00350     <span class="keywordflow">return</span> (!mFormatContext ? <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a> :
<a name="l00351"></a>00351         (mFormatContext-&gt;oformat ? <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>: <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a>));
<a name="l00352"></a>00352   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8db00c9340d6aafa29ce46d66429dbb5"></a><!-- doxytag: member="com::xuggle::xuggler::Container::close" ref="8db00c9340d6aafa29ce46d66429dbb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the container. 
<p>
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070" title="Open this container and make it ready for reading or writing.">open()</a> must have been called first, or else an error is returned.<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>.  <p>
If this method exits because of an interruption, all resources will be closed anyway. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ddca0a2734d52075a38368018eb671f5">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00414">414</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00415"></a>00415   {
<a name="l00416"></a>00416     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#8db00c9340d6aafa29ce46d66429dbb5" title="Close the container.">close</a>(<span class="keyword">false</span>);
<a name="l00417"></a>00417   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="61e44ea796f8a4516827268b7d506588"></a><!-- doxytag: member="com::xuggle::xuggler::Container::close" ref="61e44ea796f8a4516827268b7d506588" args="(bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::close           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>dangling</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00420">420</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="IContainer_8h-source.html#l00107">com::xuggle::xuggler::IContainer::READ</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="Logger_8h-source.html#l00191">VS_LOG_DEBUG</a>, <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>, <a class="el" href="Container_8cpp-source.html#l00708">writeTrailer()</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00421"></a>00421   {
<a name="l00422"></a>00422     int32_t retval = -1;
<a name="l00423"></a>00423     mMetaData.reset();
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="keywordflow">if</span> (mFormatContext &amp;&amp; mIsOpened)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mNumStreams == mStreams.size(),
<a name="l00428"></a>00428           <span class="stringliteral">"unexpected number of streams"</span>);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430       <span class="keywordflow">if</span> (mNeedTrailerWrite)
<a name="l00431"></a>00431       {
<a name="l00432"></a>00432         <span class="keywordflow">if</span> (dangling)
<a name="l00433"></a>00433           <span class="comment">// don't actually write the trailer when dangling; we could</span>
<a name="l00434"></a>00434           <span class="comment">// block on that, which could occur inside a finalizer thread</span>
<a name="l00435"></a>00435           <span class="comment">// or other unexpected thread</span>
<a name="l00436"></a>00436           <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Disposing of dangling container but could not write trailer"</span>);
<a name="l00437"></a>00437         <span class="keywordflow">else</span> {
<a name="l00438"></a>00438           <a class="code" href="Logger_8h.html#d877a8a48949721fb99c500103c71800">VS_LOG_DEBUG</a>(<span class="stringliteral">"Writing dangling trailer"</span>);
<a name="l00439"></a>00439           (void) this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a819c2aa3e1509493132f600012a1b5b" title="Adds a trailer, if needed, for this container.">writeTrailer</a>();
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441         mNeedTrailerWrite = <span class="keyword">false</span>;
<a name="l00442"></a>00442       }
<a name="l00443"></a>00443       mOpenCoders.clear();
<a name="l00444"></a>00444 
<a name="l00445"></a>00445       <span class="keywordflow">while</span>(mStreams.size() &gt; 0)
<a name="l00446"></a>00446       {
<a name="l00447"></a>00447         <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;Stream&gt;</a> * stream=mStreams.back();
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(stream &amp;&amp; *stream, <span class="stringliteral">"no stream?"</span>);
<a name="l00450"></a>00450         <span class="keywordflow">if</span> (stream &amp;&amp; *stream) {
<a name="l00451"></a>00451           (*stream)-&gt;containerClosed(<span class="keyword">this</span>);
<a name="l00452"></a>00452           <span class="keyword">delete</span> stream;
<a name="l00453"></a>00453         }
<a name="l00454"></a>00454         mStreams.pop_back();
<a name="l00455"></a>00455       }
<a name="l00456"></a>00456       mNumStreams = 0;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a>)
<a name="l00459"></a>00459       {
<a name="l00460"></a>00460         av_close_input_file(mFormatContext);
<a name="l00461"></a>00461         retval = 0;
<a name="l00462"></a>00462         mFormatContext = 0;
<a name="l00463"></a>00463       } <span class="keywordflow">else</span>
<a name="l00464"></a>00464       {
<a name="l00465"></a>00465         retval = avio_close(mFormatContext-&gt;pb);
<a name="l00466"></a>00466         avformat_free_context(mFormatContext);
<a name="l00467"></a>00467         mFormatContext = 0;
<a name="l00468"></a>00468       }
<a name="l00469"></a>00469       mIsOpened = <span class="keyword">false</span>;
<a name="l00470"></a>00470       mIsMetaDataQueried=<span class="keyword">false</span>;
<a name="l00471"></a>00471     }
<a name="l00472"></a>00472     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00473"></a>00473     <span class="keywordflow">return</span> retval;
<a name="l00474"></a>00474   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="91feaac97271cd5e8308729f18e84760"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getNumStreams" ref="91feaac97271cd5e8308729f18e84760" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getNumStreams           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of streams in this container. 
<p>
If opened in <a class="el" href="">IContainer.Type#READ</a> mode, this will query the stream and find out how many streams are in it.<p>
If opened in <a class="el" href="">IContainer.Type#WRITE</a> mode, this will return the number of streams the caller has added to date.<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of streams in this container. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#10d95ce646db22b3a9a09e684bb76663">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00355">355</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00631">writeHeader()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00356"></a>00356   {
<a name="l00357"></a>00357     int32_t retval = 0;
<a name="l00358"></a>00358     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00359"></a>00359     {
<a name="l00360"></a>00360       <span class="keywordflow">if</span> (mFormatContext-&gt;nb_streams != mNumStreams)
<a name="l00361"></a>00361         setupAllInputStreams();
<a name="l00362"></a>00362       retval = mFormatContext-&gt;nb_streams;
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00365"></a>00365     <span class="keywordflow">return</span> retval;
<a name="l00366"></a>00366   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bbc015aeee158dbb7e571500cf0018db"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getStream" ref="bbc015aeee158dbb7e571500cf0018db" args="(uint32_t position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> * com::xuggle::xuggler::Container::getStream           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the stream at the given position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>the index of this stream in the container </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The stream at that position in the container, or null if none there. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#4f5f866cf02b17802411d18edc554083">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00477">477</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">readNextPacket()</a>, and <a class="el" href="Container_8cpp-source.html#l00631">writeHeader()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00478"></a>00478   {
<a name="l00479"></a>00479     Stream *retval = 0;
<a name="l00480"></a>00480     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00481"></a>00481     {
<a name="l00482"></a>00482       <span class="keywordflow">if</span> (mFormatContext-&gt;nb_streams != mNumStreams)
<a name="l00483"></a>00483         setupAllInputStreams();
<a name="l00484"></a>00484 
<a name="l00485"></a>00485       <span class="keywordflow">if</span> (position &lt; mNumStreams)
<a name="l00486"></a>00486       {
<a name="l00487"></a>00487         <span class="comment">// will acquire for caller.</span>
<a name="l00488"></a>00488         retval = (*mStreams.at(position)).<span class="keyword">get</span>();
<a name="l00489"></a>00489       }
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491     <span class="keywordflow">return</span> retval;
<a name="l00492"></a>00492   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ca9af5946b65f4f2280241ad57b860cc"></a><!-- doxytag: member="com::xuggle::xuggler::Container::addNewStream" ref="ca9af5946b65f4f2280241ad57b860cc" args="(int32_t id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> * com::xuggle::xuggler::Container::addNewStream           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new stream in this container and returns it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>A format-dependent id for this stream.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new stream. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#3a6d69e1efc872094a2332dff86ca1f9">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00369">369</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="RefPointer_8h-source.html#l00206">com::xuggle::ferry::RefPointer&lt; T &gt;::get()</a>, <a class="el" href="Container_8cpp-source.html#l00125">isHeaderWritten()</a>, <a class="el" href="Container_8cpp-source.html#l00119">isOpened()</a>, <a class="el" href="Stream_8cpp-source.html#l00072">com::xuggle::xuggler::Stream::make()</a>, <a class="el" href="IStream_8h-source.html#l00060">com::xuggle::xuggler::IStream::OUTBOUND</a>, <a class="el" href="Logger_8h-source.html#l00191">VS_LOG_DEBUG</a>, and <a class="el" href="RefCounted_8h-source.html#l00230">VS_REF_RELEASE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00370"></a>00370   {
<a name="l00371"></a>00371     Stream *retval=0;
<a name="l00372"></a>00372     <span class="keywordflow">try</span>
<a name="l00373"></a>00373     {
<a name="l00374"></a>00374       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00375"></a>00375         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no format context"</span>);
<a name="l00376"></a>00376       
<a name="l00377"></a>00377       <span class="keywordflow">if</span> (!<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#5c1433736092da13424735411f92cf99" title="Is this container opened?">isOpened</a>())
<a name="l00378"></a>00378         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"attempted to add stream to "</span>
<a name="l00379"></a>00379             <span class="stringliteral">" unopened container"</span>);
<a name="l00380"></a>00380       
<a name="l00381"></a>00381       <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bff6463a42d13ce72b8f4ff122fc9b15" title="Has a header been successfully written?">isHeaderWritten</a>())
<a name="l00382"></a>00382         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot add stream after header is written"</span>
<a name="l00383"></a>00383             );
<a name="l00384"></a>00384       
<a name="l00385"></a>00385       AVStream * stream=0;
<a name="l00386"></a>00386       stream = av_new_stream(mFormatContext, <span class="keywordtype">id</span>);
<a name="l00387"></a>00387       <span class="keywordflow">if</span> (!stream)
<a name="l00388"></a>00388         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"could not allocate stream"</span>);
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;Stream&gt;</a>* p = <span class="keyword">new</span> <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;Stream&gt;</a>(
<a name="l00391"></a>00391           <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html#3d4cfacd8b30a3504bdb59ad85f4919c">Stream::make</a>(<span class="keyword">this</span>, stream, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html#2b2321941e122011341ee9a354927232fa3dcb3f6851df9159ffd7c7ff2a56ab">IStream::OUTBOUND</a>)
<a name="l00392"></a>00392       );
<a name="l00393"></a>00393       <span class="keywordflow">if</span> (!p) <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00394"></a>00394       <span class="keywordflow">if</span> (*p)
<a name="l00395"></a>00395       {
<a name="l00396"></a>00396         mStreams.push_back(p);
<a name="l00397"></a>00397         mNumStreams++;
<a name="l00398"></a>00398         retval = p-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#deb150bcd9d22a22c13117ef83bc91a1" title="Call RefCounted::acquire() on the managed pointer and return it.">get</a>(); <span class="comment">// acquire for caller</span>
<a name="l00399"></a>00399       }
<a name="l00400"></a>00400       <span class="keywordflow">else</span>
<a name="l00401"></a>00401       {
<a name="l00402"></a>00402         <span class="keyword">delete</span> p;
<a name="l00403"></a>00403         <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00404"></a>00404       }
<a name="l00405"></a>00405     } <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00406"></a>00406     {
<a name="l00407"></a>00407       <a class="code" href="Logger_8h.html#d877a8a48949721fb99c500103c71800">VS_LOG_DEBUG</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00408"></a>00408       <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00409"></a>00409     }
<a name="l00410"></a>00410     <span class="keywordflow">return</span> retval;
<a name="l00411"></a>00411   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2e4dca124e41521350735e78a5e0fd59"></a><!-- doxytag: member="com::xuggle::xuggler::Container::readNextPacket" ref="2e4dca124e41521350735e78a5e0fd59" args="(IPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::readNextPacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the next packet into the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a>. 
<p>
This method will release any buffers currently held by this packet and allocate new ones. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In/Out] The packet the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> will read into.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful, or &lt;0 if not. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#aa5604ff560da4cb93c3a8d363a08fe3">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00495">495</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Packet_8h-source.html#l00081">com::xuggle::xuggler::Packet::getAVPacket()</a>, <a class="el" href="Packet_8cpp-source.html#l00073">com::xuggle::xuggler::Packet::getDts()</a>, <a class="el" href="Packet_8cpp-source.html#l00147">com::xuggle::xuggler::Packet::getDuration()</a>, <a class="el" href="Packet_8cpp-source.html#l00100">com::xuggle::xuggler::Packet::getFlags()</a>, <a class="el" href="Packet_8cpp-source.html#l00159">com::xuggle::xuggler::Packet::getPosition()</a>, <a class="el" href="Packet_8cpp-source.html#l00061">com::xuggle::xuggler::Packet::getPts()</a>, <a class="el" href="Packet_8cpp-source.html#l00085">com::xuggle::xuggler::Packet::getSize()</a>, <a class="el" href="Container_8cpp-source.html#l00477">getStream()</a>, <a class="el" href="Packet_8cpp-source.html#l00095">com::xuggle::xuggler::Packet::getStreamIndex()</a>, <a class="el" href="Packet_8cpp-source.html#l00209">com::xuggle::xuggler::Packet::reset()</a>, <a class="el" href="Packet_8h-source.html#l00050">com::xuggle::xuggler::Packet::setTimeBase()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, <a class="el" href="Packet_8cpp-source.html#l00177">com::xuggle::xuggler::Packet::wrapAVPacket()</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00496"></a>00496   {
<a name="l00497"></a>00497     int32_t retval = -1;
<a name="l00498"></a>00498     Packet* pkt = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span>(ipkt);
<a name="l00499"></a>00499     <span class="keywordflow">if</span> (mFormatContext &amp;&amp; pkt)
<a name="l00500"></a>00500     {
<a name="l00501"></a>00501       AVPacket tmpPacket;
<a name="l00502"></a>00502       AVPacket* packet=0;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504       packet = &amp;tmpPacket;
<a name="l00505"></a>00505       av_init_packet(packet);
<a name="l00506"></a>00506       pkt-&gt;reset();
<a name="l00507"></a>00507       int32_t numReads=0;
<a name="l00508"></a>00508       <span class="keywordflow">do</span>
<a name="l00509"></a>00509       {
<a name="l00510"></a>00510         retval = av_read_frame(mFormatContext,
<a name="l00511"></a>00511             packet);
<a name="l00512"></a>00512         ++numReads;
<a name="l00513"></a>00513       }
<a name="l00514"></a>00514       <span class="keywordflow">while</span> (retval == AVERROR(EAGAIN) &amp;&amp;
<a name="l00515"></a>00515           (mReadRetryCount &lt; 0 || numReads &lt;= mReadRetryCount));
<a name="l00516"></a>00516 
<a name="l00517"></a>00517       <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l00518"></a>00518         pkt-&gt;wrapAVPacket(packet);
<a name="l00519"></a>00519       av_free_packet(packet);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521       <span class="comment">// Get a pointer to the wrapped packet</span>
<a name="l00522"></a>00522       packet = pkt-&gt;getAVPacket();
<a name="l00523"></a>00523       <span class="comment">// and dump it's contents</span>
<a name="l00524"></a>00524       <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"read-packet: %lld, %lld, %d, %d, %d, %lld, %lld: %p"</span>,
<a name="l00525"></a>00525           pkt-&gt;getDts(),
<a name="l00526"></a>00526           pkt-&gt;getPts(),
<a name="l00527"></a>00527           pkt-&gt;getFlags(),
<a name="l00528"></a>00528           pkt-&gt;getStreamIndex(),
<a name="l00529"></a>00529           pkt-&gt;getSize(),
<a name="l00530"></a>00530           pkt-&gt;getDuration(),
<a name="l00531"></a>00531           pkt-&gt;getPosition(),
<a name="l00532"></a>00532           packet-&gt;data);
<a name="l00533"></a>00533       
<a name="l00534"></a>00534       <span class="comment">// and let's try to set the packet time base if known</span>
<a name="l00535"></a>00535       <span class="keywordflow">if</span> (pkt-&gt;getStreamIndex() &gt;= 0)
<a name="l00536"></a>00536       {
<a name="l00537"></a>00537         <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IStream&gt;</a> stream = this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbc015aeee158dbb7e571500cf0018db" title="Get the stream at the given position.">getStream</a>(pkt-&gt;getStreamIndex());
<a name="l00538"></a>00538         <span class="keywordflow">if</span> (stream)
<a name="l00539"></a>00539         {
<a name="l00540"></a>00540           <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IRational&gt;</a> streamBase = stream-&gt;getTimeBase();
<a name="l00541"></a>00541           <span class="keywordflow">if</span> (streamBase)
<a name="l00542"></a>00542           {
<a name="l00543"></a>00543             pkt-&gt;setTimeBase(streamBase.<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#b1538ab848cc19e5aa7ec627afa2a853" title="Return the managed pointer without calling RefCounted::acquire() on it.">value</a>());
<a name="l00544"></a>00544           }
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546       }
<a name="l00547"></a>00547     }
<a name="l00548"></a>00548     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00549"></a>00549     <span class="keywordflow">return</span> retval;
<a name="l00550"></a>00550   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7d41ce13583cbedfd55a0f2b8f38b7b6"></a><!-- doxytag: member="com::xuggle::xuggler::Container::writePacket" ref="7d41ce13583cbedfd55a0f2b8f38b7b6" args="(IPacket *packet, bool forceInterleave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::writePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceInterleave</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the contents of the packet to the container. 
<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In] The packet to write out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>forceInterleave</em>&nbsp;</td><td>[In] If true, then this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will make sure all packets are interleaved by DTS (even across streams in a container). If false, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> won't, and it's up to the caller to interleave if necessary.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd># of bytes written if successful, or &lt;0 if not. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17580f71444c579fa2a8c29ec382c7c6">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00557">557</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00085">com::xuggle::xuggler::Packet::getSize()</a>, <a class="el" href="Packet_8cpp-source.html#l00095">com::xuggle::xuggler::Packet::getStreamIndex()</a>, <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="Packet_8cpp-source.html#l00382">com::xuggle::xuggler::Packet::isComplete()</a>, <a class="el" href="IPacket_8cpp-source.html#l00037">com::xuggle::xuggler::IPacket::make()</a>, <a class="el" href="Stream_8cpp-source.html#l00360">com::xuggle::xuggler::Stream::stampOutputPacket()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>, <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00552">writePacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00558"></a>00558   {
<a name="l00559"></a>00559     int32_t retval = -1;
<a name="l00560"></a>00560     Packet *pkt = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span>(ipkt);
<a name="l00561"></a>00561     <span class="keywordflow">try</span>
<a name="l00562"></a>00562     {
<a name="l00563"></a>00563       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l00564"></a>00564         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write packet to read only container"</span>);
<a name="l00565"></a>00565       
<a name="l00566"></a>00566       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00567"></a>00567         <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">"no format context"</span>);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569       <span class="keywordflow">if</span> (!pkt)
<a name="l00570"></a>00570         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write missing packet"</span>);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572       <span class="keywordflow">if</span> (!pkt-&gt;isComplete())
<a name="l00573"></a>00573         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write incomplete packet"</span>);
<a name="l00574"></a>00574 
<a name="l00575"></a>00575       <span class="keywordflow">if</span> (!pkt-&gt;getSize())
<a name="l00576"></a>00576         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write empty packet"</span>);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578       <span class="keywordflow">if</span> (!mNeedTrailerWrite)
<a name="l00579"></a>00579         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"container has not written header yet"</span>);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581       int32_t pktIndex = pkt-&gt;getStreamIndex();
<a name="l00582"></a>00582       
<a name="l00583"></a>00583       <span class="keywordflow">if</span> ((uint32_t)pktIndex &gt;= mNumStreams)
<a name="l00584"></a>00584         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"packet being written to stream that doesn't exist"</span>);
<a name="l00585"></a>00585 
<a name="l00586"></a>00586       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;Stream&gt;</a> *streamPtr = mStreams.at(pktIndex);
<a name="l00587"></a>00587       <span class="keywordflow">if</span> (!streamPtr || !*streamPtr)
<a name="l00588"></a>00588         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no stream set up for this packet"</span>);
<a name="l00589"></a>00589       
<a name="l00590"></a>00590       Stream* stream = streamPtr-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#b1538ab848cc19e5aa7ec627afa2a853" title="Return the managed pointer without calling RefCounted::acquire() on it.">value</a>();
<a name="l00591"></a>00591 
<a name="l00592"></a>00592       <span class="comment">// Create a new packet that wraps the input data; this</span>
<a name="l00593"></a>00593       <span class="comment">// just copies meta-data</span>
<a name="l00594"></a>00594       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;Packet&gt;</a> outPacket = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">Packet::make</a>(pkt, <span class="keyword">false</span>);
<a name="l00595"></a>00595       <span class="comment">// Stamp it with the stream data</span>
<a name="l00596"></a>00596       <span class="keywordflow">if</span> (stream-&gt;stampOutputPacket(outPacket.<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#b1538ab848cc19e5aa7ec627afa2a853" title="Return the managed pointer without calling RefCounted::acquire() on it.">value</a>()) &lt;0)
<a name="l00597"></a>00597         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"could not stamp output packet"</span>);
<a name="l00598"></a>00598       
<a name="l00599"></a>00599       AVPacket *packet = 0;
<a name="l00600"></a>00600       packet = outPacket-&gt;getAVPacket();
<a name="l00601"></a>00601       <span class="keywordflow">if</span> (!packet || !packet-&gt;data)
<a name="l00602"></a>00602         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no data in packet"</span>);
<a name="l00603"></a>00603       
<a name="l00604"></a>00604       <span class="comment">/*</span>
<a name="l00605"></a>00605 <span class="comment">      VS_LOG_DEBUG("write-packet: %lld, %lld, %d, %d, %d, %lld, %lld: %p",</span>
<a name="l00606"></a>00606 <span class="comment">          pkt-&gt;getDts(),</span>
<a name="l00607"></a>00607 <span class="comment">          pkt-&gt;getPts(),</span>
<a name="l00608"></a>00608 <span class="comment">          pkt-&gt;getFlags(),</span>
<a name="l00609"></a>00609 <span class="comment">          pkt-&gt;getStreamIndex(),</span>
<a name="l00610"></a>00610 <span class="comment">          pkt-&gt;getSize(),</span>
<a name="l00611"></a>00611 <span class="comment">          pkt-&gt;getDuration(),</span>
<a name="l00612"></a>00612 <span class="comment">          pkt-&gt;getPosition(),</span>
<a name="l00613"></a>00613 <span class="comment">          packet-&gt;data);</span>
<a name="l00614"></a>00614 <span class="comment">          */</span>
<a name="l00615"></a>00615       
<a name="l00616"></a>00616       <span class="keywordflow">if</span> (forceInterleave)
<a name="l00617"></a>00617         retval =  av_interleaved_write_frame(mFormatContext, packet);
<a name="l00618"></a>00618       <span class="keywordflow">else</span>
<a name="l00619"></a>00619         retval = av_write_frame(mFormatContext, packet);
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621     <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00622"></a>00622     {
<a name="l00623"></a>00623       <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00624"></a>00624       retval = -1;
<a name="l00625"></a>00625     }
<a name="l00626"></a>00626     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00627"></a>00627     <span class="keywordflow">return</span> retval;
<a name="l00628"></a>00628   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b01206e3ec2168f3fb6eabfb1525f1d8"></a><!-- doxytag: member="com::xuggle::xuggler::Container::writePacket" ref="b01206e3ec2168f3fb6eabfb1525f1d8" args="(IPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::writePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the contents of the packet to the container, but make sure the packets are interleaved. 
<p>
This means the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> may have to queue up packets from one stream while waiting for packets from another. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In] The packet to write out.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd># of bytes written if successful, or &lt;0 if not. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e0b96a4e7be3e0391ba5b41bdcc1a75d">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00552">552</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00557">writePacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00553"></a>00553   {
<a name="l00554"></a>00554     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#7d41ce13583cbedfd55a0f2b8f38b7b6" title="Writes the contents of the packet to the container.">writePacket</a>(ipkt, <span class="keyword">true</span>);
<a name="l00555"></a>00555   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="894bffc35224c8f0e3947aa7fb821ed7"></a><!-- doxytag: member="com::xuggle::xuggler::Container::writeHeader" ref="894bffc35224c8f0e3947aa7fb821ed7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::writeHeader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a header, if needed, for this container. 
<p>
Call this AFTER you've added all streams you want to add, opened all IStreamCoders for those streams (with proper configuration) and before you write the first frame. If you attempt to write a header but haven't opened all codecs, this method will log a warning, and your output file will likely be corrupt. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful. &lt; 0 if not. Always -1 if this is a READ container. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00631">631</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="ContainerParameters_8cpp-source.html#l00185">com::xuggle::xuggler::ContainerParameters::getAVParameters()</a>, <a class="el" href="Container_8cpp-source.html#l00177">getContainerFormat()</a>, <a class="el" href="Container_8cpp-source.html#l00355">getNumStreams()</a>, <a class="el" href="Container_8cpp-source.html#l00477">getStream()</a>, <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00632"></a>00632   {
<a name="l00633"></a>00633     int32_t retval = -1;
<a name="l00634"></a>00634     <span class="keywordflow">try</span> {
<a name="l00635"></a>00635       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l00636"></a>00636         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write packet to read only container"</span>);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00639"></a>00639         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no format context allocated"</span>);
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="preprocessor">#ifdef VS_DEBUG</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span>      <span class="comment">// for shits and giggles, dump the ffmpeg output</span>
<a name="l00643"></a>00643       <span class="comment">// dump_format(mFormatContext, 0, (mFormatContext ? mFormatContext-&gt;filename :0), 1);</span>
<a name="l00644"></a>00644 <span class="preprocessor">#endif // VS_DEBUG</span>
<a name="l00645"></a>00645 <span class="preprocessor"></span>
<a name="l00646"></a>00646       <span class="comment">// This checks to make sure that parameters are set correctly.</span>
<a name="l00647"></a>00647       AVFormatParameters* params = 0;
<a name="l00648"></a>00648       ContainerParameters* cParams = <span class="keyword">dynamic_cast&lt;</span>ContainerParameters*<span class="keyword">&gt;</span>(mParameters.value());
<a name="l00649"></a>00649       <span class="keywordflow">if</span> (cParams)
<a name="l00650"></a>00650         params = cParams-&gt;getAVParameters();
<a name="l00651"></a>00651 
<a name="l00652"></a>00652       retval = av_set_parameters(mFormatContext, params);
<a name="l00653"></a>00653       <span class="keywordflow">if</span> (retval &lt; 0)
<a name="l00654"></a>00654         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"incorrect parameters set on container"</span>);
<a name="l00655"></a>00655 
<a name="l00656"></a>00656       <span class="comment">// now we're going to walk through and record each open stream coder.</span>
<a name="l00657"></a>00657       <span class="comment">// this is needed to catch a potential error on writeTrailer().</span>
<a name="l00658"></a>00658       mOpenCoders.clear();
<a name="l00659"></a>00659       <span class="keywordtype">int</span> numStreams = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#91feaac97271cd5e8308729f18e84760" title="The number of streams in this container.">getNumStreams</a>();
<a name="l00660"></a>00660       <span class="keywordflow">if</span> (numStreams &lt; 0 &amp;&amp; 
<a name="l00661"></a>00661           !(mFormatContext-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER))
<a name="l00662"></a>00662         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no streams added to container"</span>);
<a name="l00663"></a>00663       
<a name="l00664"></a>00664       <span class="keywordflow">if</span> (numStreams == 0)
<a name="l00665"></a>00665       {
<a name="l00666"></a>00666         <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IContainerFormat&gt;</a> format = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fe5f6450c9f1a38cc1617baf98e5a7bf" title="Returns the IContainerFormat object being used for this IContainer, or null if the...">getContainerFormat</a>();
<a name="l00667"></a>00667         <span class="keywordflow">if</span> (format)
<a name="l00668"></a>00668         {
<a name="l00669"></a>00669           <span class="keyword">const</span> <span class="keywordtype">char</span> *shortName = format-&gt;getOutputFormatShortName();
<a name="l00670"></a>00670           <span class="keywordflow">if</span> (shortName &amp;&amp; !strcmp(shortName, <span class="stringliteral">"mp3"</span>))
<a name="l00671"></a>00671             <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no streams added to mp3 container"</span>);
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673       }
<a name="l00674"></a>00674       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numStreams; i++)
<a name="l00675"></a>00675       {
<a name="l00676"></a>00676         <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IStream&gt;</a> stream = this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbc015aeee158dbb7e571500cf0018db" title="Get the stream at the given position.">getStream</a>(i);
<a name="l00677"></a>00677         <span class="keywordflow">if</span> (stream)
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679           <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IStreamCoder&gt;</a> coder = stream-&gt;getStreamCoder();
<a name="l00680"></a>00680           <span class="keywordflow">if</span> (coder)
<a name="l00681"></a>00681           {
<a name="l00682"></a>00682             <span class="keywordflow">if</span> (coder-&gt;isOpen())
<a name="l00683"></a>00683               <span class="comment">// add to our open list</span>
<a name="l00684"></a>00684               mOpenCoders.push_back(coder);
<a name="l00685"></a>00685             <span class="keywordflow">else</span>
<a name="l00686"></a>00686               <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"writing Header for container, but at least one codec (%d) is not opened first"</span>, i);
<a name="l00687"></a>00687           }
<a name="l00688"></a>00688         }
<a name="l00689"></a>00689       }
<a name="l00690"></a>00690       retval = av_write_header(mFormatContext);
<a name="l00691"></a>00691       <span class="keywordflow">if</span> (retval &lt; 0)
<a name="l00692"></a>00692         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"could not write header for container"</span>);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694       <span class="comment">// force a flush.</span>
<a name="l00695"></a>00695       avio_flush(mFormatContext-&gt;pb);
<a name="l00696"></a>00696       <span class="comment">// and remember that a writeTrailer is needed</span>
<a name="l00697"></a>00697       mNeedTrailerWrite = <span class="keyword">true</span>;
<a name="l00698"></a>00698     }
<a name="l00699"></a>00699     <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00700"></a>00700     {
<a name="l00701"></a>00701       <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00702"></a>00702       retval = -1;
<a name="l00703"></a>00703     }
<a name="l00704"></a>00704     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00705"></a>00705     <span class="keywordflow">return</span> retval;
<a name="l00706"></a>00706   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a819c2aa3e1509493132f600012a1b5b"></a><!-- doxytag: member="com::xuggle::xuggler::Container::writeTrailer" ref="a819c2aa3e1509493132f600012a1b5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::writeTrailer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a trailer, if needed, for this container. 
<p>
Call this AFTER you've written all data you're going to write to this container but BEFORE you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b">IStreamCoder#close()</a> on your <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> objects. <p>
You must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#894bffc35224c8f0e3947aa7fb821ed7">writeHeader()</a> before you call this (and if you don't, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will warn loudly and not actually write the trailer).  <p>
If you have closed any of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> objects that were open when you called <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#894bffc35224c8f0e3947aa7fb821ed7">writeHeader()</a>, then this method will fail. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful. &lt; 0 if not. Always &lt;0 if this is a READ container. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b951e5d5469db4cb1029a4af71e689df">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00708">708</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>, <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>, <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00420">close()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00709"></a>00709   {
<a name="l00710"></a>00710     int32_t retval = -1;
<a name="l00711"></a>00711     <span class="keywordflow">try</span>
<a name="l00712"></a>00712     {
<a name="l00713"></a>00713       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l00714"></a>00714         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write packet to read only container"</span>);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l00717"></a>00717         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no format context allocated"</span>);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719       <span class="keywordflow">if</span> (mNeedTrailerWrite)
<a name="l00720"></a>00720       {
<a name="l00721"></a>00721         <span class="keywordflow">while</span>(mOpenCoders.size()&gt;0)
<a name="l00722"></a>00722         {
<a name="l00723"></a>00723           <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;IStreamCoder&gt;</a> coder = mOpenCoders.front();
<a name="l00724"></a>00724           mOpenCoders.pop_front();
<a name="l00725"></a>00725           <span class="keywordflow">if</span> (!coder-&gt;isOpen())
<a name="l00726"></a>00726           {
<a name="l00727"></a>00727             mOpenCoders.clear();
<a name="l00728"></a>00728             <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"attempt to write trailer, but at least one used codec already closed"</span>);
<a name="l00729"></a>00729           }
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731         retval = av_write_trailer(mFormatContext);
<a name="l00732"></a>00732         <span class="keywordflow">if</span> (retval == 0)
<a name="l00733"></a>00733         {
<a name="l00734"></a>00734           avio_flush(mFormatContext-&gt;pb);
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736       } <span class="keywordflow">else</span> {
<a name="l00737"></a>00737         <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"writeTrailer() with no matching call to writeHeader()"</span>);
<a name="l00738"></a>00738       }
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740     <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00741"></a>00741     {
<a name="l00742"></a>00742       <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00743"></a>00743       retval = -1;
<a name="l00744"></a>00744     }
<a name="l00745"></a>00745     <span class="comment">// regardless of whether or not the write trailer succeeded, since</span>
<a name="l00746"></a>00746     <span class="comment">// an attempt has occurred, we shouldn't call it twice.</span>
<a name="l00747"></a>00747     mNeedTrailerWrite = <span class="keyword">false</span>;
<a name="l00748"></a>00748     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00749"></a>00749     <span class="keywordflow">return</span> retval;
<a name="l00750"></a>00750   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6d50eaaf36b5864c64922ad8fbd48e4a"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getFormatContext" ref="6d50eaaf36b5864c64922ad8fbd48e4a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVFormatContext * com::xuggle::xuggler::Container::getFormatContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00091">91</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00092"></a>00092   {
<a name="l00093"></a>00093     <span class="keywordflow">return</span> mFormatContext;
<a name="l00094"></a>00094   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c9b1fcb51b448e84a4e62d97bf07b716"></a><!-- doxytag: member="com::xuggle::xuggler::Container::queryStreamMetaData" ref="c9b1fcb51b448e84a4e62d97bf07b716" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::queryStreamMetaData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to read all the meta data in this stream, potentially by reading ahead and decoding packets. 
<p>
Any packets this method reads ahead will be cached and correctly returned when you read packets, but this method can be non-blocking potentially until end of container to get all meta data. Take care when you call it. <p>
After this method is called, other meta data methods like <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#3d26cf3a258c11367468802b75fabcd1">getDuration()</a> should work. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on failure. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2d212870b29f797cbb39eed5c65094c4">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00753">753</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00861">getBitRate()</a>, <a class="el" href="Container_8cpp-source.html#l00831">getDuration()</a>, <a class="el" href="Container_8cpp-source.html#l00851">getFileSize()</a>, and <a class="el" href="Container_8cpp-source.html#l00841">getStartTime()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00754"></a>00754   {
<a name="l00755"></a>00755     <span class="keywordtype">int</span> retval = -1;
<a name="l00756"></a>00756     <span class="keywordflow">if</span> (mIsOpened)
<a name="l00757"></a>00757     {
<a name="l00758"></a>00758       <span class="keywordflow">if</span> (!mIsMetaDataQueried)
<a name="l00759"></a>00759       {
<a name="l00760"></a>00760         retval = av_find_stream_info(mFormatContext);
<a name="l00761"></a>00761         <span class="comment">// for shits and giggles, dump the ffmpeg output</span>
<a name="l00762"></a>00762         <span class="comment">// dump_format(mFormatContext, 0, (mFormatContext ? mFormatContext-&gt;filename :0), 0);</span>
<a name="l00763"></a>00763         mIsMetaDataQueried = <span class="keyword">true</span>;
<a name="l00764"></a>00764       } <span class="keywordflow">else</span> {
<a name="l00765"></a>00765         retval = 0;
<a name="l00766"></a>00766       }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768       <span class="keywordflow">if</span> (retval &gt;= 0 &amp;&amp; mFormatContext-&gt;nb_streams &gt; 0)
<a name="l00769"></a>00769       {
<a name="l00770"></a>00770         setupAllInputStreams();
<a name="l00771"></a>00771       } <span class="keywordflow">else</span> {
<a name="l00772"></a>00772         <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Could not find streams in input container"</span>);
<a name="l00773"></a>00773       }
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775     <span class="keywordflow">else</span>
<a name="l00776"></a>00776     {
<a name="l00777"></a>00777       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempt to queryStreamMetaData but container is not open"</span>);
<a name="l00778"></a>00778     }
<a name="l00779"></a>00779     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00780"></a>00780     <span class="keywordflow">return</span> retval;
<a name="l00781"></a>00781   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a3fdac358b46c778278a864efdd062e3"></a><!-- doxytag: member="com::xuggle::xuggler::Container::seekKeyFrame" ref="a3fdac358b46c778278a864efdd062e3" args="(int streamIndex, int64_t timestamp, int32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::Container::seekKeyFrame           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3d26cf3a258c11367468802b75fabcd1"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getDuration" ref="3d26cf3a258c11367468802b75fabcd1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Container::getDuration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the duration, if known, of this container. 
<p>
This will only work for non-streamable containers where <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> can calculate the container size.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The duration, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382">Global#NO_PTS</a> if not known. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#46210689b9ae96925e7e193930bb9fb0">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00831">831</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, and <a class="el" href="Container_8cpp-source.html#l00753">queryStreamMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00832"></a>00832   {
<a name="l00833"></a>00833     int64_t retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00834"></a>00834     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716" title="Attempts to read all the meta data in this stream, potentially by reading ahead and...">queryStreamMetaData</a>();
<a name="l00835"></a>00835     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00836"></a>00836       retval = mFormatContext-&gt;duration;
<a name="l00837"></a>00837     <span class="keywordflow">return</span> retval;
<a name="l00838"></a>00838   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d5f4120e63c0bc4dccf2ee8c37771364"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getStartTime" ref="d5f4120e63c0bc4dccf2ee8c37771364" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Container::getStartTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the starting timestamp in microseconds of the first packet of the earliest stream in this container. 
<p>
This will only return value values either either (a) for non-streamable containers where <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> can calculate the container size or (b) after <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> has actually read the first packet from a streamable source. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The starting timestamp in microseconds, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382">Global#NO_PTS</a> if not known. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a4854bfde32fd18dfa4146c5fdf16802">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00841">841</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, and <a class="el" href="Container_8cpp-source.html#l00753">queryStreamMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00842"></a>00842   {
<a name="l00843"></a>00843     int64_t retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00844"></a>00844     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716" title="Attempts to read all the meta data in this stream, potentially by reading ahead and...">queryStreamMetaData</a>();
<a name="l00845"></a>00845     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00846"></a>00846       retval = mFormatContext-&gt;start_time;
<a name="l00847"></a>00847     <span class="keywordflow">return</span> retval;
<a name="l00848"></a>00848   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="316b8205188f0ac40f60ad00fcbf2983"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getFileSize" ref="316b8205188f0ac40f60ad00fcbf2983" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Container::getFileSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the file size in bytes of this container. 
<p>
This will only return a valid value if the container is non-streamed and supports seek.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The file size in bytes, or &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#34a28d2cea2d7769f9220034a1e8ef77">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00851">851</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00753">queryStreamMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00852"></a>00852   {
<a name="l00853"></a>00853     int64_t retval = -1;
<a name="l00854"></a>00854     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716" title="Attempts to read all the meta data in this stream, potentially by reading ahead and...">queryStreamMetaData</a>();
<a name="l00855"></a>00855     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00856"></a>00856       retval = mFormatContext-&gt;file_size;
<a name="l00857"></a>00857     <span class="keywordflow">return</span> retval;
<a name="l00858"></a>00858   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a8a88f87119ac97f667b292aa1d19eb6"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getBitRate" ref="a8a88f87119ac97f667b292aa1d19eb6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getBitRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the calculated overall bit rate of this file. 
<p>
This will only return a valid value if the container is non-streamed and supports seek.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>The overall bit rate in bytes per second, or &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d24ebd9fa679dc4e03b5c745cbdf3bd">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00861">861</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00753">queryStreamMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00862"></a>00862   {
<a name="l00863"></a>00863     int32_t retval = -1;
<a name="l00864"></a>00864     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716" title="Attempts to read all the meta data in this stream, potentially by reading ahead and...">queryStreamMetaData</a>();
<a name="l00865"></a>00865     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00866"></a>00866       retval = mFormatContext-&gt;bit_rate;
<a name="l00867"></a>00867     <span class="keywordflow">return</span> retval;
<a name="l00868"></a>00868   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fdce37ee74b7a4cc8f45a2b9ecc06d41"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setPreload" ref="fdce37ee74b7a4cc8f45a2b9ecc06d41" args="(int32_t preload)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setPreload           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>preload</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the container has not already been opened, sets the AVFormatContext.preload property which can be useful in some circumstances such as when dealing with mpeg formats. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>preload</em>&nbsp;</td><td>amount to preload </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#c1e45fa674401ff262116000654b9ead">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00871">871</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00872"></a>00872   {
<a name="l00873"></a>00873     int32_t retval = -1;
<a name="l00874"></a>00874     <span class="keywordflow">if</span> (mIsOpened || !mFormatContext)
<a name="l00875"></a>00875     {
<a name="l00876"></a>00876       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to set preload while file is opened; ignoring"</span>);
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878     <span class="keywordflow">else</span>
<a name="l00879"></a>00879     {
<a name="l00880"></a>00880       mFormatContext-&gt;preload = preload;
<a name="l00881"></a>00881       retval = preload;
<a name="l00882"></a>00882     }
<a name="l00883"></a>00883     <span class="keywordflow">return</span> retval;
<a name="l00884"></a>00884   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d1b240a1bb3a040814ae513cd78c7f91"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPreload" ref="d1b240a1bb3a040814ae513cd78c7f91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getPreload           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The amount container will attemtp to preload. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The amount to preload, error code otherwise. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2bc101a4e88efed7dbfd6a0385c78c63">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00887">887</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00888"></a>00888   {
<a name="l00889"></a>00889     int32_t retval = -1;
<a name="l00890"></a>00890     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00891"></a>00891       retval = mFormatContext-&gt;preload;
<a name="l00892"></a>00892     <span class="keywordflow">return</span> retval;
<a name="l00893"></a>00893   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e74c019ad63453cc2584f0a752fd79f8"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setMaxDelay" ref="e74c019ad63453cc2584f0a752fd79f8" args="(int32_t maxdelay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setMaxDelay           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxdelay</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the max delay for the AVFormatContext.max_delay property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxdelay</em>&nbsp;</td><td>maximum delay for container </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ffd6269c4f5468f5fa78970138cf4f42">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00896">896</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00897"></a>00897   {
<a name="l00898"></a>00898     int32_t retval = -1;
<a name="l00899"></a>00899     <span class="keywordflow">if</span> (mIsOpened || !mFormatContext)
<a name="l00900"></a>00900     {
<a name="l00901"></a>00901       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to set max delay while file is opened; ignoring"</span>);
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903     <span class="keywordflow">else</span>
<a name="l00904"></a>00904     {
<a name="l00905"></a>00905       mFormatContext-&gt;max_delay = maxdelay;
<a name="l00906"></a>00906       retval = maxdelay;
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908     <span class="keywordflow">return</span> retval;
<a name="l00909"></a>00909   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fda72b06c5c37e1de2b962e691581290"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getMaxDelay" ref="fda72b06c5c37e1de2b962e691581290" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getMaxDelay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the AVFormatContext.max_delay property if possible. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The max delay, error code otherwise. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#cfc7e16b076f706ec8dfb2576909148a">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00912">912</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00913"></a>00913   {
<a name="l00914"></a>00914     int32_t retval = -1;
<a name="l00915"></a>00915     <span class="keywordflow">if</span> (mFormatContext)
<a name="l00916"></a>00916       retval = mFormatContext-&gt;max_delay;
<a name="l00917"></a>00917     <span class="keywordflow">return</span> retval;
<a name="l00918"></a>00918   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4100ba10f4ed468f93e0e406d8df966f"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getNumProperties" ref="4100ba10f4ed468f93e0e406d8df966f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getNumProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of settable properties on this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>total number of options (not including constant definitions) </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1a8ee4550ef8ae857ac96126657e6e9a">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00921">921</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00112">com::xuggle::xuggler::Property::getNumProperties()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00922"></a>00922   {
<a name="l00923"></a>00923     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#875467d8b4b7317d1bbc265e369af806" title="For internal use.">Property::getNumProperties</a>(mFormatContext);
<a name="l00924"></a>00924   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="53a5cc27420bd775af445db84c5ec95a"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyMetaData" ref="53a5cc27420bd775af445db84c5ec95a" args="(int32_t propertyNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> * com::xuggle::xuggler::Container::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>propertyNo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>propertyNo</em>&nbsp;</td><td>The property number in the options list.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c0c2f30bba223aab4fa028eb4427249">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00927">927</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00131">com::xuggle::xuggler::Property::getPropertyMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00928"></a>00928   {
<a name="l00929"></a>00929     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#1acff8d5d03d46ed59ccc95cb713dde4" title="Returns the metadata for the numbered property.">Property::getPropertyMetaData</a>(mFormatContext, propertyNo);
<a name="l00930"></a>00930   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="36743c0c7add3bcd5653296bbab941af"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyMetaData" ref="36743c0c7add3bcd5653296bbab941af" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> * com::xuggle::xuggler::Container::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a1325d8c31034d9883c805b2f3ddcde7">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00933">933</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00131">com::xuggle::xuggler::Property::getPropertyMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00934"></a>00934   {
<a name="l00935"></a>00935     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#1acff8d5d03d46ed59ccc95cb713dde4" title="Returns the metadata for the numbered property.">Property::getPropertyMetaData</a>(mFormatContext, name);
<a name="l00936"></a>00936   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="19db2d967d4470afb196a3237a96681d"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setProperty" ref="19db2d967d4470afb196a3237a96681d" args="(const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a property on this Object. 
<p>
All AVOptions supported by the underlying AVClass are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name. For example "b" for bit-rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 if the property was successfully set; &lt;0 on error </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#193d39a27e22a7b3b8221dabbe6da4cd">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00939">939</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00940"></a>00940   {
<a name="l00941"></a>00941     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mFormatContext, aName, aValue);
<a name="l00942"></a>00942   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f7f620dc708bf23f978efaa39230ab07"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setProperty" ref="f7f620dc708bf23f978efaa39230ab07" args="(const char *name, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2ef795b1f539a9165e6115a87bb968be">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00945">945</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00946"></a>00946   {
<a name="l00947"></a>00947     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mFormatContext, aName, aValue);
<a name="l00948"></a>00948   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="661c4c4c35c42b56947ab186d3a183ad"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setProperty" ref="661c4c4c35c42b56947ab186d3a183ad" args="(const char *name, int64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#156bd0b2f9cf0664d3cae72c7b0fc25d">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00951">951</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00952"></a>00952   {
<a name="l00953"></a>00953     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mFormatContext, aName, aValue);
<a name="l00954"></a>00954   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c91b7be505f35547be20061e4462d377"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setProperty" ref="c91b7be505f35547be20061e4462d377" args="(const char *name, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#0e4f0ab8ee56dfa12a05c07682c53b5d">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00957">957</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00958"></a>00958   {
<a name="l00959"></a>00959     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mFormatContext, aName, aValue);
<a name="l00960"></a>00960   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="92404787199b49ef1d33348db55f629d"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setProperty" ref="92404787199b49ef1d33348db55f629d" args="(const char *name, IRational *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e3604cbb97d2059eca19688e192dcd26">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00964">964</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00965"></a>00965   {
<a name="l00966"></a>00966     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mFormatContext, aName, aValue);
<a name="l00967"></a>00967   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d249081d220c772f8e0d7c9f569a6d5b"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyAsString" ref="d249081d220c772f8e0d7c9f569a6d5b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * com::xuggle::xuggler::Container::getPropertyAsString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a property on this Object. 
<p>
Note for C++ callers; you must free the returned array with delete[] in order to avoid a memory leak. If you call from Java or any other language, you don't need to worry about this. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>property name</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an string copy of the option value, or null if the option doesn't exist. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d1e4b2c4bbf93fc86c70e517c8e9578">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00971">971</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00224">com::xuggle::xuggler::Property::getPropertyAsString()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00972"></a>00972   {
<a name="l00973"></a>00973     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#626f8c0b62b95793590b85d6552f9ba6" title="Gets the value of this property, and returns as a new[]ed string.">Property::getPropertyAsString</a>(mFormatContext, aName);
<a name="l00974"></a>00974   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ae0d0772742776f6a91c6b1763917242"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyAsDouble" ref="ae0d0772742776f6a91c6b1763917242" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com::xuggle::xuggler::Container::getPropertyAsDouble           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a double;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#8eb0ee5298eeecaa2028b2e4ae3a43f5">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00977">977</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00407">com::xuggle::xuggler::Property::getPropertyAsDouble()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00978"></a>00978   {
<a name="l00979"></a>00979     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#5b04523742370ac92e85c843c80fda57" title="Gets the value of this property, and returns as a double;.">Property::getPropertyAsDouble</a>(mFormatContext, aName);
<a name="l00980"></a>00980   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c2576ac8fb9b1c5cf9257b47f0081b56"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyAsLong" ref="c2576ac8fb9b1c5cf9257b47f0081b56" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Container::getPropertyAsLong           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an long;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f6a4994a87d3246c90ca49a876b1cdd6">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00983">983</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00430">com::xuggle::xuggler::Property::getPropertyAsLong()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00984"></a>00984   {
<a name="l00985"></a>00985     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#e1eb7b43f0a6d77bb44fa71845b084c4" title="Gets the value of this property, and returns as an long;.">Property::getPropertyAsLong</a>(mFormatContext, aName);
<a name="l00986"></a>00986   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9820ba26dd86a4db0d185d047454916f"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyAsRational" ref="9820ba26dd86a4db0d185d047454916f" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> * com::xuggle::xuggler::Container::getPropertyAsRational           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b9c88e910ff0fbc79fe222bfd3cd9c43">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00989">989</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00453">com::xuggle::xuggler::Property::getPropertyAsRational()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00990"></a>00990   {
<a name="l00991"></a>00991     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#383d3c035f3b6ad95e65247f561fe04c" title="Gets the value of this property, and returns as an IRational;.">Property::getPropertyAsRational</a>(mFormatContext, aName);
<a name="l00992"></a>00992   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bbf3ccc481d3c88a0b2c4d1a508d56c0"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getPropertyAsBoolean" ref="bbf3ccc481d3c88a0b2c4d1a508d56c0" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Container::getPropertyAsBoolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value of property, or false on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d2a804668a41b04c0428ce48dc10c12">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00995">995</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00477">com::xuggle::xuggler::Property::getPropertyAsBoolean()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00996"></a>00996   {
<a name="l00997"></a>00997     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#768278773536fdeb44b6f4358baaaf9a" title="Gets the value of this property, and returns as a boolean.">Property::getPropertyAsBoolean</a>(mFormatContext, aName);
<a name="l00998"></a>00998   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="34b5a0ead185e980905b1b379bbd6291"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getFlags" ref="34b5a0ead185e980905b1b379bbd6291" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the flags associated with this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The (compacted) value of all flags set. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#38c5b1ae3388b104f4be7d764b437906">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01001">1001</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01002"></a>01002   {
<a name="l01003"></a>01003     <span class="keywordflow">return</span> (mFormatContext ? mFormatContext-&gt;flags: 0);
<a name="l01004"></a>01004   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="83173a1086878cdef9f645c7f8c14a8c"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setFlags" ref="83173a1086878cdef9f645c7f8c14a8c" args="(int32_t newFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Container::setFlags           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flags to use with this object. 
<p>
All values must be ORed (|) together.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFlags</em>&nbsp;</td><td>The new set flags for this codec. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a371e8fc5ba1b4717c4750b26cb69037">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01007">1007</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01008"></a>01008   {
<a name="l01009"></a>01009     <span class="keywordflow">if</span> (mFormatContext)
<a name="l01010"></a>01010       mFormatContext-&gt;flags = newFlags;
<a name="l01011"></a>01011   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0214b27eb3bddf589d2b4bc481091c5d"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getFlag" ref="0214b27eb3bddf589d2b4bc481091c5d" args="(Flags flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Container::getFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the setting for the specified flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag you want to find the setting for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for false; non-zero for true </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a2cb2aecf555dc3b0e37a8d261d7f595">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01014">1014</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01015"></a>01015   {
<a name="l01016"></a>01016     <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l01017"></a>01017     <span class="keywordflow">if</span> (mFormatContext)
<a name="l01018"></a>01018       result = mFormatContext-&gt;flags&amp; flag;
<a name="l01019"></a>01019     <span class="keywordflow">return</span> result;
<a name="l01020"></a>01020   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6812f6402105fd2424f01b3ed34b059f"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setFlag" ref="6812f6402105fd2424f01b3ed34b059f" args="(Flags flag, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Container::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set it to (true or false) </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#668d5d01c638cc5bbd5b28d0aaa4b684">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01023">1023</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01024"></a>01024   {
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (mFormatContext)
<a name="l01026"></a>01026     {
<a name="l01027"></a>01027       <span class="keywordflow">if</span> (value)
<a name="l01028"></a>01028       {
<a name="l01029"></a>01029         mFormatContext-&gt;flags |= flag;
<a name="l01030"></a>01030       }
<a name="l01031"></a>01031       <span class="keywordflow">else</span>
<a name="l01032"></a>01032       {
<a name="l01033"></a>01033         mFormatContext-&gt;flags &amp;= (~flag);
<a name="l01034"></a>01034       }
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c60bbfd16ab2e713ed98c330189135f5"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getURL" ref="c60bbfd16ab2e713ed98c330189135f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * com::xuggle::xuggler::Container::getURL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the URL the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> was opened with. 
<p>
May return null if unknown. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the URL opened, or null. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e111c3ee0deb32a534aae9cd033f0a7a">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01040">1040</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01041"></a>01041   {
<a name="l01042"></a>01042     <span class="keywordflow">return</span> mFormatContext &amp;&amp; *mFormatContext-&gt;filename ? mFormatContext-&gt;filename : 0;
<a name="l01043"></a>01043   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c9e8a8e23fefa87a8ca34ee132c9d16a"></a><!-- doxytag: member="com::xuggle::xuggler::Container::flushPackets" ref="c9e8a8e23fefa87a8ca34ee132c9d16a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::flushPackets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush all packets to output. 
<p>
Will only work on <a class="el" href="">IContainer.Type#WRITE</a> containers. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f18be848a461be8efde6cee3f1c06dbf">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01046">1046</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>, <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01047"></a>01047   {
<a name="l01048"></a>01048     int32_t retval = -1;
<a name="l01049"></a>01049     <span class="keywordflow">try</span>
<a name="l01050"></a>01050     {
<a name="l01051"></a>01051       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l01052"></a>01052         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"cannot write packet to read only container"</span>);
<a name="l01053"></a>01053 
<a name="l01054"></a>01054       <span class="keywordflow">if</span> (!mFormatContext)
<a name="l01055"></a>01055         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no format context allocated"</span>);
<a name="l01056"></a>01056 
<a name="l01057"></a>01057       <span class="comment">// Do the flush</span>
<a name="l01058"></a>01058       avio_flush(mFormatContext-&gt;pb);
<a name="l01059"></a>01059       retval = 0;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061     <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l01062"></a>01062     {
<a name="l01063"></a>01063       <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l01064"></a>01064       retval = -1;
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l01067"></a>01067     <span class="keywordflow">return</span> retval;
<a name="l01068"></a>01068   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="68fd2f39ddf1be3cbe7db4d95ccfbf12"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getReadRetryCount" ref="68fd2f39ddf1be3cbe7db4d95ccfbf12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::getReadRetryCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of times <a class="el" href="">IContainer#readNextPacket(IPacket)</a> will retry a read if it gets a <a class="el" href="">IError.Type#ERROR_AGAIN</a> value back. 
<p>
Defaults to 1 times. &lt;0 means it will keep retrying indefinitely.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the read retry count </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#490b52a2589e490d0d34247d382151ef">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01071">1071</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01072"></a>01072   {
<a name="l01073"></a>01073     <span class="keywordflow">return</span> mReadRetryCount;
<a name="l01074"></a>01074   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e069c6c46b2566530a9d5f5ed236473c"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setReadRetryCount" ref="e069c6c46b2566530a9d5f5ed236473c" args="(int32_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Container::setReadRetryCount           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the read retry count. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#68fd2f39ddf1be3cbe7db4d95ccfbf12" title="Get the number of times IContainer#readNextPacket(IPacket) will retry a read if it...">getReadRetryCount()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The read retry count. &lt;0 means keep trying. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e881592ff0c456c35d566ee2b9b66f3b">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01077">1077</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01078"></a>01078   {
<a name="l01079"></a>01079     mReadRetryCount = aCount;
<a name="l01080"></a>01080   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ac1057eaa815ad8cc1492f823112141b"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getParameters" ref="ac1057eaa815ad8cc1492f823112141b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> * com::xuggle::xuggler::Container::getParameters           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parameters that will be used when opening. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>setParameters(IContainerParameters)</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The parameters </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#9c7066428bc1ead1130f16920bd1d47e">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01083">1083</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01084"></a>01084   {
<a name="l01085"></a>01085     <span class="keywordflow">return</span> mParameters.get();
<a name="l01086"></a>01086   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4b08ae798f60caf917852e56351b71bb"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setParameters" ref="4b08ae798f60caf917852e56351b71bb" args="(IContainerParameters *parameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Container::setParameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *&nbsp;</td>
          <td class="paramname"> <em>parameters</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the parameters for this container. 
<p>
Normally this is not required, but if you're opening something like a webcam, you need to specify to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> parameters such as a time base, width, height, etc.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parameters</em>&nbsp;</td><td>The parameters to set. Ignored if null. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#589d287bb2170a8605e8983e81ae6586">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01089">1089</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01090"></a>01090   {
<a name="l01091"></a>01091     <span class="keywordflow">if</span> (params)
<a name="l01092"></a>01092       mParameters.reset(params, <span class="keyword">true</span>);
<a name="l01093"></a>01093   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0ebc043b97ce12dfd43f28f26f3cced8"></a><!-- doxytag: member="com::xuggle::xuggler::Container::canStreamsBeAddedDynamically" ref="0ebc043b97ce12dfd43f28f26f3cced8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Container::canStreamsBeAddedDynamically           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can streams be added dynamically to this container? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if streams can be added dynamically </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#afe2fbcf6616eb5c256c436e384e0868">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01096">1096</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01097"></a>01097   {
<a name="l01098"></a>01098     <span class="keywordflow">if</span> (mFormatContext)
<a name="l01099"></a>01099       <span class="keywordflow">return</span> mFormatContext-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER;
<a name="l01100"></a>01100     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01101"></a>01101   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="668b512eb384f55c03dfd3961ca1462a"></a><!-- doxytag: member="com::xuggle::xuggler::Container::getMetaData" ref="668b512eb384f55c03dfd3961ca1462a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> * com::xuggle::xuggler::Container::getMetaData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> for this object, or null if none. 
<p>
If the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> object that this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> came from was opened for reading, then changes via <a class="el" href="">IMetaData#setValue(String, String)</a> will have no effect on the underlying media.  <p>
If the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> object that this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> came from was opened for writing, then changes via <a class="el" href="">IMetaData#setValue(String, String)</a> will have no effect after <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">IContainer#writeHeader()</a> is called.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a>. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d1788ab8398aea307081d6a8cacf4107">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01104">1104</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Container_8cpp-source.html#l00348">getType()</a>, <a class="el" href="IMetaData_8cpp-source.html#l00036">com::xuggle::xuggler::IMetaData::make()</a>, and <a class="el" href="IContainer_8h-source.html#l00108">com::xuggle::xuggler::IContainer::WRITE</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l01118">setMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01105"></a>01105   {
<a name="l01106"></a>01106     <span class="keywordflow">if</span> (!mMetaData &amp;&amp; mFormatContext)
<a name="l01107"></a>01107     {
<a name="l01108"></a>01108       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8" title="Find out the type of this container.">getType</a>() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>)
<a name="l01109"></a>01109         mMetaData = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html#03defc6451fc720615c3d0d7593cc126" title="Create a new IMetaData bag of properties with no values set.">MetaData::make</a>(&amp;mFormatContext-&gt;metadata);
<a name="l01110"></a>01110       <span class="keywordflow">else</span>
<a name="l01111"></a>01111         <span class="comment">// make a read-only copy so when libav deletes the</span>
<a name="l01112"></a>01112         <span class="comment">// input version we don't delete our copy</span>
<a name="l01113"></a>01113         mMetaData = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html#03defc6451fc720615c3d0d7593cc126" title="Create a new IMetaData bag of properties with no values set.">MetaData::make</a>(mFormatContext-&gt;metadata);
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115     <span class="keywordflow">return</span> mMetaData.get();
<a name="l01116"></a>01116   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1242ab31447bb274441dbf0f97c68771"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setMetaData" ref="1242ab31447bb274441dbf0f97c68771" args="(IMetaData *metaData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Container::setMetaData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> on this object, overriding any previous meta data. 
<p>
You should call this method on writable containers and before you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">IContainer#writeHeader</a>, as it probably won't do anything after that.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#668b512eb384f55c03dfd3961ca1462a" title="Get the IMetaData for this object, or null if none.">getMetaData()</a> </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#03b7ee2a3b40ba44176d2b8f8b081564">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01118">1118</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="MetaData_8cpp-source.html#l00141">com::xuggle::xuggler::MetaData::copy()</a>, <a class="el" href="Container_8cpp-source.html#l01104">getMetaData()</a>, and <a class="el" href="RefCounted_8cpp-source.html#l00070">com::xuggle::ferry::RefCounted::release()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01119"></a>01119   {
<a name="l01120"></a>01120     MetaData* data = <span class="keyword">dynamic_cast&lt;</span>MetaData*<span class="keyword">&gt;</span>(<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#668b512eb384f55c03dfd3961ca1462a" title="Get the IMetaData for this object, or null if none.">getMetaData</a>());
<a name="l01121"></a>01121     <span class="keywordflow">if</span> (data) {
<a name="l01122"></a>01122       data-&gt;copy(copy);
<a name="l01123"></a>01123       <span class="comment">// release for the get above</span>
<a name="l01124"></a>01124       data-&gt;release();
<a name="l01125"></a>01125     }
<a name="l01126"></a>01126     <span class="keywordflow">return</span>;
<a name="l01127"></a>01127   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f901720a3ce47813525d459a54f3c3ad"></a><!-- doxytag: member="com::xuggle::xuggler::Container::createSDPData" ref="f901720a3ce47813525d459a54f3c3ad" args="(com::xuggle::ferry::IBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::createSDPData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the given buffer with a null-terminated ASCII set of bytes representing SDP data that is suitable for use with an RTSP-based system. 
<p>
This method only works if Xuggler is linking against a version of FFmpeg that supports RTSP.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com.xuggle.ferry.IBuffer</a> object to fill with data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written, including the terminating 0 byte, or &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#97736a47ff6836e1d931e8f40a64191c">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01130">1130</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#a5743da411135fd90cb1c3e99b2cfaa4">com::xuggle::ferry::IBuffer::getBufferSize()</a>, <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a">com::xuggle::ferry::IBuffer::getBytes()</a>, and <a class="el" href="Logger_8h-source.html#l00188">VS_LOG_INFO</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01131"></a>01131   {
<a name="l01132"></a>01132     <span class="keywordflow">if</span> (!mFormatContext)
<a name="l01133"></a>01133       <span class="keywordflow">return</span> -1;
<a name="l01134"></a>01134     <span class="keywordflow">if</span> (!buffer)
<a name="l01135"></a>01135       <span class="keywordflow">return</span> -1;
<a name="l01136"></a>01136     
<a name="l01137"></a>01137     int32_t bufSize = buffer-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#a5743da411135fd90cb1c3e99b2cfaa4" title="Get the current maximum number of bytes that can be safely placed in this buffer...">getBufferSize</a>();
<a name="l01138"></a>01138     <span class="keywordflow">if</span> (bufSize &lt;= 0)
<a name="l01139"></a>01139       <span class="keywordflow">return</span> -1;
<a name="l01140"></a>01140     
<a name="l01141"></a>01141     <span class="keywordtype">char</span>* bytes = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(buffer-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a" title="Returns up to length bytes, starting at offset in the underlying buffer we&amp;#39;re...">getBytes</a>(0, bufSize));
<a name="l01142"></a>01142     <span class="keywordflow">if</span> (!bytes)
<a name="l01143"></a>01143       <span class="keywordflow">return</span> -1;
<a name="l01144"></a>01144     
<a name="l01145"></a>01145     bytes[0] = 0;
<a name="l01146"></a>01146     <span class="comment">// null terminate the buffer to ensure strlen below doesn't</span>
<a name="l01147"></a>01147     <span class="comment">// overrun</span>
<a name="l01148"></a>01148     bytes[bufSize-1]=0;
<a name="l01149"></a>01149     int32_t ret = av_sdp_create(&amp;mFormatContext, 1, bytes, bufSize-1);
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l01152"></a>01152     {
<a name="l01153"></a>01153       <a class="code" href="Logger_8h.html#d4421bb17c246dcfb6440dbb63312063">VS_LOG_INFO</a>(<span class="stringliteral">"Could not create SDP file: %d"</span>, ret);
<a name="l01154"></a>01154       <span class="keywordflow">return</span> ret;
<a name="l01155"></a>01155     }
<a name="l01156"></a>01156     <span class="comment">// Otherwise, we have to figure out the length, including the </span>
<a name="l01157"></a>01157     <span class="comment">// terminating null</span>
<a name="l01158"></a>01158     ret = strlen(bytes)+1;
<a name="l01159"></a>01159     <span class="keywordflow">return</span> ret;
<a name="l01160"></a>01160   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="005b81a5cef01432eb74f74873c64185"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setForcedAudioCodec" ref="005b81a5cef01432eb74f74873c64185" args="(ICodec::ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setForcedAudioCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all audio streams are encoded with the given audio codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an audio codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d8cb3efd249708f1620d52005afc58d1">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01163">1163</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00053">com::xuggle::xuggler::ICodec::CODEC_ID_NONE</a>, <a class="el" href="ICodec_8h-source.html#l00367">com::xuggle::xuggler::ICodec::CODEC_TYPE_AUDIO</a>, and <a class="el" href="ICodec_8cpp-source.html#l00059">com::xuggle::xuggler::ICodec::findDecodingCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01164"></a>01164   {
<a name="l01165"></a>01165     int32_t retval=-1;
<a name="l01166"></a>01166     <span class="keywordflow">if</span> (mFormatContext &amp;&amp; <span class="keywordtype">id</span> != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28f87075e4ac81f926f81204f4d000bb6e">ICodec::CODEC_ID_NONE</a>)
<a name="l01167"></a>01167     {
<a name="l01168"></a>01168       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;ICodec&gt;</a> codec = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#f5caf2521e0bda9038bdf07e663b14c1" title="Find a codec that can be used for decoding.">ICodec::findDecodingCodec</a>(<span class="keywordtype">id</span>);
<a name="l01169"></a>01169       <span class="keywordflow">if</span> (codec &amp;&amp; codec-&gt;getType() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>)
<a name="l01170"></a>01170         mFormatContext-&gt;audio_codec_id = (<span class="keyword">enum</span> CodecID) id;
<a name="l01171"></a>01171     }
<a name="l01172"></a>01172     <span class="keywordflow">return</span> retval;
<a name="l01173"></a>01173   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="875da3ccedd3927a024857cc52c35640"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setForcedVideoCodec" ref="875da3ccedd3927a024857cc52c35640" args="(ICodec::ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setForcedVideoCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all video streams are encoded with the given video codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an video codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5a496ddd025c3017181887538fab29e5">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01176">1176</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00053">com::xuggle::xuggler::ICodec::CODEC_ID_NONE</a>, <a class="el" href="ICodec_8h-source.html#l00366">com::xuggle::xuggler::ICodec::CODEC_TYPE_VIDEO</a>, and <a class="el" href="ICodec_8cpp-source.html#l00059">com::xuggle::xuggler::ICodec::findDecodingCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01177"></a>01177   {
<a name="l01178"></a>01178     int32_t retval=-1;
<a name="l01179"></a>01179     <span class="keywordflow">if</span> (mFormatContext &amp;&amp; <span class="keywordtype">id</span> != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28f87075e4ac81f926f81204f4d000bb6e">ICodec::CODEC_ID_NONE</a>)
<a name="l01180"></a>01180     {
<a name="l01181"></a>01181       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;ICodec&gt;</a> codec = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#f5caf2521e0bda9038bdf07e663b14c1" title="Find a codec that can be used for decoding.">ICodec::findDecodingCodec</a>(<span class="keywordtype">id</span>);
<a name="l01182"></a>01182       <span class="keywordflow">if</span> (codec &amp;&amp; codec-&gt;getType() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd448fc7fdfd7648393fec9774f4f0a10e9">ICodec::CODEC_TYPE_VIDEO</a>)
<a name="l01183"></a>01183         mFormatContext-&gt;video_codec_id = (<span class="keyword">enum</span> CodecID) id;
<a name="l01184"></a>01184     }
<a name="l01185"></a>01185     <span class="keywordflow">return</span> retval;
<a name="l01186"></a>01186   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5eb5146e5f01df2fc0ab2029ca75488c"></a><!-- doxytag: member="com::xuggle::xuggler::Container::setForcedSubtitleCodec" ref="5eb5146e5f01df2fc0ab2029ca75488c" args="(ICodec::ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::setForcedSubtitleCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all subtitle streams are encoded with the given subtitle codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an subtitle codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f1a4ae51498242dfce13bb238ec10775">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l01189">1189</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00053">com::xuggle::xuggler::ICodec::CODEC_ID_NONE</a>, <a class="el" href="ICodec_8h-source.html#l00369">com::xuggle::xuggler::ICodec::CODEC_TYPE_SUBTITLE</a>, and <a class="el" href="ICodec_8cpp-source.html#l00059">com::xuggle::xuggler::ICodec::findDecodingCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01190"></a>01190   {
<a name="l01191"></a>01191     int32_t retval=-1;
<a name="l01192"></a>01192     <span class="keywordflow">if</span> (mFormatContext &amp;&amp; <span class="keywordtype">id</span> != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28f87075e4ac81f926f81204f4d000bb6e">ICodec::CODEC_ID_NONE</a>)
<a name="l01193"></a>01193     {
<a name="l01194"></a>01194       <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++.">RefPointer&lt;ICodec&gt;</a> codec = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#f5caf2521e0bda9038bdf07e663b14c1" title="Find a codec that can be used for decoding.">ICodec::findDecodingCodec</a>(<span class="keywordtype">id</span>);
<a name="l01195"></a>01195       <span class="keywordflow">if</span> (codec &amp;&amp; codec-&gt;getType() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4f902da714be44335346d5032b98b05b1">ICodec::CODEC_TYPE_SUBTITLE</a>)
<a name="l01196"></a>01196         mFormatContext-&gt;subtitle_codec_id = (<span class="keyword">enum</span> CodecID) id;
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198     <span class="keywordflow">return</span> retval;
<a name="l01199"></a>01199   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c71a98f5487b92fab88cc5f36299b536"></a><!-- doxytag: member="com::xuggle::xuggler::Container::seekKeyFrame" ref="c71a98f5487b92fab88cc5f36299b536" args="(int32_t streamIndex, int64_t minTimeStamp, int64_t targetTimeStamp, int64_t maxTimeStamp, int32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Container::seekKeyFrame           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>minTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>targetTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>maxTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EXPERIMENTAL - Seeks to timestamp in the container. 
<p>
Seeking will be done so that the point from which all active streams can be presented successfully will be closest to <code>targetTimeStamp</code> and within <code> minTimeStamp/maxTimeStamp</code>.  <p>
If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ce79de394dbc46e9f1f7542cee176445">SEEK_FLAG_BYTE</a>, then all time stamps are in bytes and are the file position (this may not be supported by all demuxers). If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17bda2e9f78c72f87c3b6b01ae2d0a1a">SEEK_FLAG_FRAME</a>, then all time stamps are in frames in the stream with <code>streamIndex</code> (this may not be supported by all demuxers). Otherwise all time stamps are in units of the stream selected by stream_index or if stream_index is -1, in microseconds. If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d77e67f96064168bc6bae9ac720970e1">SEEK_FLAG_ANY</a>, then non-keyframes are treated as keyframes (this may not be supported by all demuxers). If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d18e85998ab0cb1b624cfda4a5f240c2">SEEK_FLAG_BACKWARDS</a>, then we will attempt to search backwards in the container (this may not be supported by all demuxers and file protocols).  <p>
This is part of the new seek API which is still under construction. It may change in future Xuggler versions.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>index of the stream which is used as time base reference </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minTimeStamp</em>&nbsp;</td><td>smallest acceptable time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetTimeStamp</em>&nbsp;</td><td>target time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxTimeStamp</em>&nbsp;</td><td>largest acceptable time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A bitmask of the <code>SEEK_FLAG_*</code> flags, or 0 to turn all flags off. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;=0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.4 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#afbb7a5d43a2e06bd33a45b6b3083786">com::xuggle::xuggler::IContainer</a>.</p>

<p>Definition at line <a class="el" href="Container_8cpp-source.html#l00805">805</a> of file <a class="el" href="Container_8cpp-source.html">Container.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>, and <a class="el" href="Container_8cpp-source.html#l00042">XUGGLER_CHECK_INTERRUPT</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00807"></a>00807   {
<a name="l00808"></a>00808     int32_t retval = -1;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="keywordflow">if</span> (mIsOpened)
<a name="l00811"></a>00811     {
<a name="l00812"></a>00812       <span class="keywordflow">if</span> (streamIndex &gt;= (int32_t)mNumStreams)
<a name="l00813"></a>00813         <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempt to seek on streamIndex %d but only %d streams known about in container"</span>,
<a name="l00814"></a>00814             streamIndex, mNumStreams);
<a name="l00815"></a>00815       <span class="keywordflow">else</span>
<a name="l00816"></a>00816         retval = avformat_seek_file(mFormatContext, streamIndex,
<a name="l00817"></a>00817             minTimeStamp,
<a name="l00818"></a>00818             targetTimeStamp,
<a name="l00819"></a>00819             maxTimeStamp,
<a name="l00820"></a>00820             flags);
<a name="l00821"></a>00821     }
<a name="l00822"></a>00822     <span class="keywordflow">else</span>
<a name="l00823"></a>00823     {
<a name="l00824"></a>00824       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempt to seekKeyFrame but container is not open"</span>);
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826     <a class="code" href="Container_8cpp.html#8315171e0f02608bde71404d87740781">XUGGLER_CHECK_INTERRUPT</a>(retval);
<a name="l00827"></a>00827     <span class="keywordflow">return</span> retval;
<a name="l00828"></a>00828   }
</pre></div>
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>csrc/com/xuggle/xuggler/<a class="el" href="Container_8h-source.html">Container.h</a><li>csrc/com/xuggle/xuggler/<a class="el" href="Container_8cpp-source.html">Container.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 11 07:40:07 2011 for Xuggle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
