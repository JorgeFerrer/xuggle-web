<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xuggle: com::xuggle::xuggler::IContainer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecom.html">com</a>::<a class="el" href="namespacecom_1_1xuggle.html">xuggle</a>::<a class="el" href="namespacecom_1_1xuggle_1_1xuggler.html">xuggler</a>::<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a>
  </div>
</div>
<div class="contents">
<h1>com::xuggle::xuggler::IContainer Class Reference</h1><!-- doxytag: class="com::xuggle::xuggler::IContainer" --><!-- doxytag: inherits="com::xuggle::ferry::RefCounted" --><code>#include &lt;<a class="el" href="IContainer_8h-source.html">IContainer.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for com::xuggle::xuggler::IContainer:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1IContainer__inherit__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1IContainer__inherit__map" alt="Inheritance graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1IContainer__inherit__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html" title="com::xuggle::xuggler::Container" alt="" coords="7,162,231,188"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="11,7,227,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for com::xuggle::xuggler::IContainer:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1IContainer__coll__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1IContainer__coll__map" alt="Collaboration graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1IContainer__coll__map">
<area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="13,100,229,126"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1AtomicInteger.html" title="Internal only." alt="" coords="5,6,237,33"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classcom_1_1xuggle_1_1xuggler_1_1IContainer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A file (or network data source) that contains one or more <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> objects of audio and video data. 
<p>
Typical usage for reading looks like this: <pre>
 <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> container = <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b3ec74db19c1b9e28443be7cae0738bd" title="Create a new container object.">IContainer.make()</a>;</pre><p>
<pre> if (container.open("myfile.flv", IContainer.Type.READ, null) &lt;0)
 &nbsp;&nbsp;throw new RuntimeException("failed to open");</pre><p>
<pre> int numStreams = container.getNumStreams();
 for(i = 0; i &lt; numStreams; i++) {
 &nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer.">IStream</a> stream = container.getStream(i);
 &nbsp;&nbsp;...query <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer.">IStream</a> for stream information...
 }</pre><p>
<pre> <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a> packet = <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">IPacket.make()</a>;
 while(container.readNextPacket(packet) &gt;= 0)
 {
   &nbsp;&nbsp;... Do something with the packet...
 }
 container.close();
 </pre> <p>
Typical usage for writing looks like this (makes an FLV file with one audio track encoded as mp3 data):  <pre>
 <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> container = <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b3ec74db19c1b9e28443be7cae0738bd" title="Create a new container object.">IContainer.make()</a>;</pre><p>
<pre> if (container.open("myfile.flv", IContainer.Type.WRITE, null) &lt;0)
 &nbsp;&nbsp;throw new RuntimeException("failed to open");</pre><p>
<pre> <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer.">IStream</a> stream = container.addNewStream(0);</pre><p>
<pre> <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> coder = stream.getStreamCoder();</pre><p>
<pre> coder.setCodec(ICodec.ID.CODEC_ID_MP3);
 coder.setSampleRate(22050);
 coder.setChannels(2);
 coder.setBitRate(64000);</pre><p>
<pre> if (coder.open()&lt;0) throw new RuntimeException("could not open coder");</pre><p>
<pre> if (container.writeHeader() &lt; 0) throw new RuntimeException();</pre><p>
<pre> <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a> packet = <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">IPacket.make()</a>;</pre><p>
<pre> while( ... have more data to process ... ) {
 &nbsp;&nbsp;... Use the coder to encode audio data into packets
 &nbsp;&nbsp;then assuming it generated an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a> for you...
 &nbsp;&nbsp;if (container.writePacket(packet)&lt;0)
 &nbsp;&nbsp;&nbsp;&nbsp;throw new RuntimeException("could not write packet");
 }</pre><p>
<pre> if (container.writeTrailer() &lt;0) throw new RuntimeException();</pre><p>
<pre> container.close();
 </pre> 
<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00099">99</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> { <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a>, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The different types of Containers Xuggler supports.  <a href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a> { <br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a7987284411a02d212f96b05ed272b6ef">FLAG_GENPTS</a> = 0x0001, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02ab348340c2fd3a581f94fe8b58478e9a3">FLAG_IGNIDX</a> = 0x0002, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a21382b12ed5dd4e750552ee4b268a78a">FLAG_NONBLOCK</a> = 0x0004, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a4ac52d5e21626ccc3df9415b15e43a77">FLAG_IGNDTS</a> = 0x0008, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a061c1a8261750e6fdcc29cb489423697">FLAG_NOFILLIN</a> = 0x0010, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a8aa27f77e85211923bf92631324273c5">FLAG_NOPARSE</a> = 0x0020, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02ac81b5c0734d461f4289019006fde8dae">FLAG_RTP_HINT</a> = 0x0040
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#38b0b9d59587da84e5f46129fcbe96c3">setInputBufferLength</a> (uint32_t size)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffer length Xuggler will suggest to FFMPEG for reading inputs.  <a href="#38b0b9d59587da84e5f46129fcbe96c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#55cd201f53a1ba5164ebe1450aa9f4cf">getInputBufferLength</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the input buffer length.  <a href="#55cd201f53a1ba5164ebe1450aa9f4cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#7a9582bad53dceece938ced81a948326">isOpened</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this container opened?  <a href="#7a9582bad53dceece938ced81a948326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#23d39d461a6c1f42fd2b37d63dfc9573">isHeaderWritten</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has a header been successfully written?  <a href="#23d39d461a6c1f42fd2b37d63dfc9573"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c4ebd5f91b50093a33a03b9891b09af">open</a> (const char *url, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> type, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *pContainerFormat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open this container and make it ready for reading or writing.  <a href="#1c4ebd5f91b50093a33a03b9891b09af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1fb363cc644d10e07c95868c2e3ce66d">open</a> (const char *url, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> type, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *pContainerFormat, bool aStreamsCanBeAddedDynamically, bool aQueryStreamMetaData)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open this container and make it ready for reading or writing, optionally reading as far into the container as necessary to find all streams.  <a href="#1fb363cc644d10e07c95868c2e3ce66d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#aa5c811008064fb4c630e972d1fc0ca3">getContainerFormat</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object being used for this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a>, or null if the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> doesn't yet know.  <a href="#aa5c811008064fb4c630e972d1fc0ca3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ddca0a2734d52075a38368018eb671f5">close</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the container.  <a href="#ddca0a2734d52075a38368018eb671f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#da0f091c4272a46c83b3d1f9fd73e732">getType</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find out the type of this container.  <a href="#da0f091c4272a46c83b3d1f9fd73e732"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#10d95ce646db22b3a9a09e684bb76663">getNumStreams</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of streams in this container.  <a href="#10d95ce646db22b3a9a09e684bb76663"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#4f5f866cf02b17802411d18edc554083">getStream</a> (uint32_t streamIndex)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the stream at the given position.  <a href="#4f5f866cf02b17802411d18edc554083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#3a6d69e1efc872094a2332dff86ca1f9">addNewStream</a> (int32_t id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new stream in this container and returns it.  <a href="#3a6d69e1efc872094a2332dff86ca1f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">writeHeader</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a header, if needed, for this container.  <a href="#5f130eca02f4a0ca729836f68cf75513"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b951e5d5469db4cb1029a4af71e689df">writeTrailer</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a trailer, if needed, for this container.  <a href="#b951e5d5469db4cb1029a4af71e689df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#aa5604ff560da4cb93c3a8d363a08fe3">readNextPacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the next packet into the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a>.  <a href="#aa5604ff560da4cb93c3a8d363a08fe3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17580f71444c579fa2a8c29ec382c7c6">writePacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, bool forceInterleave)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the contents of the packet to the container.  <a href="#17580f71444c579fa2a8c29ec382c7c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e0b96a4e7be3e0391ba5b41bdcc1a75d">writePacket</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the contents of the packet to the container, but make sure the packets are interleaved.  <a href="#e0b96a4e7be3e0391ba5b41bdcc1a75d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2d212870b29f797cbb39eed5c65094c4">queryStreamMetaData</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to read all the meta data in this stream, potentially by reading ahead and decoding packets.  <a href="#2d212870b29f797cbb39eed5c65094c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#095c2693bb17c3c92da831cd2e5d17da">seekKeyFrame</a> (int32_t streamIndex, int64_t timestamp, int32_t flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeks to the key frame at (or the first one after) the given timestamp.  <a href="#095c2693bb17c3c92da831cd2e5d17da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#46210689b9ae96925e7e193930bb9fb0">getDuration</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the duration, if known, of this container.  <a href="#46210689b9ae96925e7e193930bb9fb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a4854bfde32fd18dfa4146c5fdf16802">getStartTime</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the starting timestamp in microseconds of the first packet of the earliest stream in this container.  <a href="#a4854bfde32fd18dfa4146c5fdf16802"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#34a28d2cea2d7769f9220034a1e8ef77">getFileSize</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file size in bytes of this container.  <a href="#34a28d2cea2d7769f9220034a1e8ef77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d24ebd9fa679dc4e03b5c745cbdf3bd">getBitRate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the calculated overall bit rate of this file.  <a href="#1d24ebd9fa679dc4e03b5c745cbdf3bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1a8ee4550ef8ae857ac96126657e6e9a">getNumProperties</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of settable properties on this object.  <a href="#1a8ee4550ef8ae857ac96126657e6e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c0c2f30bba223aab4fa028eb4427249">getPropertyMetaData</a> (int32_t propertyNo)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#1c0c2f30bba223aab4fa028eb4427249"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a1325d8c31034d9883c805b2f3ddcde7">getPropertyMetaData</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#a1325d8c31034d9883c805b2f3ddcde7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#193d39a27e22a7b3b8221dabbe6da4cd">setProperty</a> (const char *name, const char *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a property on this Object.  <a href="#193d39a27e22a7b3b8221dabbe6da4cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2ef795b1f539a9165e6115a87bb968be">setProperty</a> (const char *name, double value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#2ef795b1f539a9165e6115a87bb968be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#156bd0b2f9cf0664d3cae72c7b0fc25d">setProperty</a> (const char *name, int64_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#156bd0b2f9cf0664d3cae72c7b0fc25d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#0e4f0ab8ee56dfa12a05c07682c53b5d">setProperty</a> (const char *name, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#0e4f0ab8ee56dfa12a05c07682c53b5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e3604cbb97d2059eca19688e192dcd26">setProperty</a> (const char *name, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#e3604cbb97d2059eca19688e192dcd26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d1e4b2c4bbf93fc86c70e517c8e9578">getPropertyAsString</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a property on this Object.  <a href="#1d1e4b2c4bbf93fc86c70e517c8e9578"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#8eb0ee5298eeecaa2028b2e4ae3a43f5">getPropertyAsDouble</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a double;.  <a href="#8eb0ee5298eeecaa2028b2e4ae3a43f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f6a4994a87d3246c90ca49a876b1cdd6">getPropertyAsLong</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an long;.  <a href="#f6a4994a87d3246c90ca49a876b1cdd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b9c88e910ff0fbc79fe222bfd3cd9c43">getPropertyAsRational</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;.  <a href="#b9c88e910ff0fbc79fe222bfd3cd9c43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1d2a804668a41b04c0428ce48dc10c12">getPropertyAsBoolean</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a boolean.  <a href="#1d2a804668a41b04c0428ce48dc10c12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#38c5b1ae3388b104f4be7d764b437906">getFlags</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flags associated with this object.  <a href="#38c5b1ae3388b104f4be7d764b437906"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a371e8fc5ba1b4717c4750b26cb69037">setFlags</a> (int32_t newFlags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flags to use with this object.  <a href="#a371e8fc5ba1b4717c4750b26cb69037"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#a2cb2aecf555dc3b0e37a8d261d7f595">getFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a> flag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the setting for the specified flag.  <a href="#a2cb2aecf555dc3b0e37a8d261d7f595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#668d5d01c638cc5bbd5b28d0aaa4b684">setFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flag.  <a href="#668d5d01c638cc5bbd5b28d0aaa4b684"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e111c3ee0deb32a534aae9cd033f0a7a">getURL</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the URL the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> was opened with.  <a href="#e111c3ee0deb32a534aae9cd033f0a7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f18be848a461be8efde6cee3f1c06dbf">flushPackets</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush all packets to output.  <a href="#f18be848a461be8efde6cee3f1c06dbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#490b52a2589e490d0d34247d382151ef">getReadRetryCount</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of times <a class="el" href="">IContainer#readNextPacket(IPacket)</a> will retry a read if it gets a <a class="el" href="">IError.Type#ERROR_AGAIN</a> value back.  <a href="#490b52a2589e490d0d34247d382151ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#e881592ff0c456c35d566ee2b9b66f3b">setReadRetryCount</a> (int32_t count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the read retry count.  <a href="#e881592ff0c456c35d566ee2b9b66f3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#9c7066428bc1ead1130f16920bd1d47e">getParameters</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parameters that will be used when opening.  <a href="#9c7066428bc1ead1130f16920bd1d47e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#589d287bb2170a8605e8983e81ae6586">setParameters</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *parameters)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the parameters for this container.  <a href="#589d287bb2170a8605e8983e81ae6586"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#afe2fbcf6616eb5c256c436e384e0868">canStreamsBeAddedDynamically</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can streams be added dynamically to this container?  <a href="#afe2fbcf6616eb5c256c436e384e0868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d1788ab8398aea307081d6a8cacf4107">getMetaData</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> for this object, or null if none.  <a href="#d1788ab8398aea307081d6a8cacf4107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#03b7ee2a3b40ba44176d2b8f8b081564">setMetaData</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> on this object, overriding any previous meta data.  <a href="#03b7ee2a3b40ba44176d2b8f8b081564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#97736a47ff6836e1d931e8f40a64191c">createSDPData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *buffer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the given buffer with a null-terminated ASCII set of bytes representing SDP data that is suitable for use with an RTSP-based system.  <a href="#97736a47ff6836e1d931e8f40a64191c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d8cb3efd249708f1620d52005afc58d1">setForcedAudioCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all audio streams are encoded with the given audio codec when demuxing.  <a href="#d8cb3efd249708f1620d52005afc58d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5a496ddd025c3017181887538fab29e5">setForcedVideoCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all video streams are encoded with the given video codec when demuxing.  <a href="#5a496ddd025c3017181887538fab29e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#f1a4ae51498242dfce13bb238ec10775">setForcedSubtitleCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all subtitle streams are encoded with the given subtitle codec when demuxing.  <a href="#f1a4ae51498242dfce13bb238ec10775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#afbb7a5d43a2e06bd33a45b6b3083786">seekKeyFrame</a> (int32_t streamIndex, int64_t minTimeStamp, int64_t targetTimeStamp, int64_t maxTimeStamp, int32_t flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EXPERIMENTAL - Seeks to timestamp in the container.  <a href="#afbb7a5d43a2e06bd33a45b6b3083786"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#c1e45fa674401ff262116000654b9ead">setPreload</a> (int32_t preload)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the container has not already been opened, sets the AVFormatContext.preload property which can be useful in some circumstances such as when dealing with mpeg formats.  <a href="#c1e45fa674401ff262116000654b9ead"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2bc101a4e88efed7dbfd6a0385c78c63">getPreload</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The amount container will attemtp to preload.  <a href="#2bc101a4e88efed7dbfd6a0385c78c63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ffd6269c4f5468f5fa78970138cf4f42">setMaxDelay</a> (int32_t maxdelay)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the max delay for the AVFormatContext.max_delay property.  <a href="#ffd6269c4f5468f5fa78970138cf4f42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#cfc7e16b076f706ec8dfb2576909148a">getMaxDelay</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the AVFormatContext.max_delay property if possible.  <a href="#cfc7e16b076f706ec8dfb2576909148a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b3ec74db19c1b9e28443be7cae0738bd">make</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new container object.  <a href="#b3ec74db19c1b9e28443be7cae0738bd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d18e85998ab0cb1b624cfda4a5f240c2">SEEK_FLAG_BACKWARDS</a> = 1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag; Seek backwards.  <a href="#d18e85998ab0cb1b624cfda4a5f240c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ce79de394dbc46e9f1f7542cee176445">SEEK_FLAG_BYTE</a> = 2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag; Use bytes instead of time stamps for seeking.  <a href="#ce79de394dbc46e9f1f7542cee176445"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d77e67f96064168bc6bae9ac720970e1">SEEK_FLAG_ANY</a> = 4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag; Seek to any frame, even non-keyframes.  <a href="#d77e67f96064168bc6bae9ac720970e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17bda2e9f78c72f87c3b6b01ae2d0a1a">SEEK_FLAG_FRAME</a> = 8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag; Seek based on frame number instead of time stamps.  <a href="#17bda2e9f78c72f87c3b6b01ae2d0a1a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#0bacb53552aaf9e243abeddd67ecde0b">~IContainer</a> ()=0</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="eb6fa73bec032bc1045d17f8fea0e7a5"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::Type" ref="eb6fa73bec032bc1045d17f8fea0e7a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">com::xuggle::xuggler::IContainer::Type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The different types of Containers Xuggler supports. 
<p>
A container may only be opened in a uni-directional mode. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c"></a><!-- doxytag: member="READ" ref="eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c" args="" -->READ</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703"></a><!-- doxytag: member="WRITE" ref="eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703" args="" -->WRITE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00106">106</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00106"></a>00106                  {
<a name="l00107"></a>00107       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5b0fa65ac900b080663eac2a9e520750c">READ</a>,
<a name="l00108"></a>00108       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a589a3eb526e29f1983119c41407900703">WRITE</a>,
<a name="l00109"></a>00109     } <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5" title="The different types of Containers Xuggler supports.">Type</a>;
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::Flags" ref="fc8e4e7d878d36da6a5137577b00c02a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">com::xuggle::xuggler::IContainer::Flags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a7987284411a02d212f96b05ed272b6ef"></a><!-- doxytag: member="FLAG_GENPTS" ref="fc8e4e7d878d36da6a5137577b00c02a7987284411a02d212f96b05ed272b6ef" args="" -->FLAG_GENPTS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02ab348340c2fd3a581f94fe8b58478e9a3"></a><!-- doxytag: member="FLAG_IGNIDX" ref="fc8e4e7d878d36da6a5137577b00c02ab348340c2fd3a581f94fe8b58478e9a3" args="" -->FLAG_IGNIDX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a21382b12ed5dd4e750552ee4b268a78a"></a><!-- doxytag: member="FLAG_NONBLOCK" ref="fc8e4e7d878d36da6a5137577b00c02a21382b12ed5dd4e750552ee4b268a78a" args="" -->FLAG_NONBLOCK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a4ac52d5e21626ccc3df9415b15e43a77"></a><!-- doxytag: member="FLAG_IGNDTS" ref="fc8e4e7d878d36da6a5137577b00c02a4ac52d5e21626ccc3df9415b15e43a77" args="" -->FLAG_IGNDTS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a061c1a8261750e6fdcc29cb489423697"></a><!-- doxytag: member="FLAG_NOFILLIN" ref="fc8e4e7d878d36da6a5137577b00c02a061c1a8261750e6fdcc29cb489423697" args="" -->FLAG_NOFILLIN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02a8aa27f77e85211923bf92631324273c5"></a><!-- doxytag: member="FLAG_NOPARSE" ref="fc8e4e7d878d36da6a5137577b00c02a8aa27f77e85211923bf92631324273c5" args="" -->FLAG_NOPARSE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="fc8e4e7d878d36da6a5137577b00c02ac81b5c0734d461f4289019006fde8dae"></a><!-- doxytag: member="FLAG_RTP_HINT" ref="fc8e4e7d878d36da6a5137577b00c02ac81b5c0734d461f4289019006fde8dae" args="" -->FLAG_RTP_HINT</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00631">631</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00631"></a>00631                  {
<a name="l00632"></a>00632       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a7987284411a02d212f96b05ed272b6ef">FLAG_GENPTS</a>=0x0001,
<a name="l00633"></a>00633       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02ab348340c2fd3a581f94fe8b58478e9a3">FLAG_IGNIDX</a>=0x0002,
<a name="l00634"></a>00634       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a21382b12ed5dd4e750552ee4b268a78a">FLAG_NONBLOCK</a>=0x0004,
<a name="l00635"></a>00635       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a4ac52d5e21626ccc3df9415b15e43a77">FLAG_IGNDTS</a>=0x0008,
<a name="l00636"></a>00636       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a061c1a8261750e6fdcc29cb489423697">FLAG_NOFILLIN</a>=0x0010,
<a name="l00637"></a>00637       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a8aa27f77e85211923bf92631324273c5">FLAG_NOPARSE</a>=0x0020,
<a name="l00638"></a>00638       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02ac81b5c0734d461f4289019006fde8dae">FLAG_RTP_HINT</a>=0x0040
<a name="l00639"></a>00639     } <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a>;
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0bacb53552aaf9e243abeddd67ecde0b"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::~IContainer" ref="0bacb53552aaf9e243abeddd67ecde0b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::IContainer::~IContainer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="IContainer_8cpp-source.html#l00026">26</a> of file <a class="el" href="IContainer_8cpp-source.html">IContainer.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00027"></a>00027   {
<a name="l00028"></a>00028   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="38b0b9d59587da84e5f46129fcbe96c3"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setInputBufferLength" ref="38b0b9d59587da84e5f46129fcbe96c3" args="(uint32_t size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setInputBufferLength           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the buffer length Xuggler will suggest to FFMPEG for reading inputs. 
<p>
If called when a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> is open, the call is ignored and -1 is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The suggested buffer size. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>size on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a88474b8409fddb99f53b5bc2f6a860b">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="55cd201f53a1ba5164ebe1450aa9f4cf"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getInputBufferLength" ref="55cd201f53a1ba5164ebe1450aa9f4cf" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t com::xuggle::xuggler::IContainer::getInputBufferLength           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the input buffer length. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The input buffer length Xuggler's told FFMPEG to assume. 0 means FFMPEG should choose it's own size (and it'll probably be 32768). </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4d0aefbe2c8213d2566e7a6df83fc017">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="7a9582bad53dceece938ced81a948326"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::isOpened" ref="7a9582bad53dceece938ced81a948326" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IContainer::isOpened           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this container opened? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if opened; false if not. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#5c1433736092da13424735411f92cf99">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="23d39d461a6c1f42fd2b37d63dfc9573"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::isHeaderWritten" ref="23d39d461a6c1f42fd2b37d63dfc9573" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IContainer::isHeaderWritten           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Has a header been successfully written? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if yes, false if no. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bff6463a42d13ce72b8f4ff122fc9b15">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c4ebd5f91b50093a33a03b9891b09af"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::open" ref="1c4ebd5f91b50093a33a03b9891b09af" args="(const char *url, Type type, IContainerFormat *pContainerFormat)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td>
          <td class="paramname"> <em>pContainerFormat</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open this container and make it ready for reading or writing. 
<p>
The caller must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ddca0a2734d52075a38368018eb671f5">close()</a> when done, but if not, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will eventually close them later but warn to the logging system.  <p>
This just forwards to <a class="el" href="">open(String, Type, IContainerFormat, boolean, boolean)</a> passing false for aStreamsCanBeAddedDynamically, and true for aLookForAllStreams. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>The resource to open; The format of this string is any url that FFMPEG supports (including additional protocols if added through the <a class="el" href="namespacecom_1_1xuggle_1_1xuggler_1_1io.html" title="This package contains the XUGGLER IO library which is used to register callbacks...">xuggler.io</a> library). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pContainerFormat</em>&nbsp;</td><td>A pointer to a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ContainerFormat.html">ContainerFormat</a> object specifying the format of this container, or 0 (NULL) if you want us to guess.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#958973be9670bf5c3090ce246360b070">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1fb363cc644d10e07c95868c2e3ce66d"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::open" ref="1fb363cc644d10e07c95868c2e3ce66d" args="(const char *url, Type type, IContainerFormat *pContainerFormat, bool aStreamsCanBeAddedDynamically, bool aQueryStreamMetaData)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::open           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a> *&nbsp;</td>
          <td class="paramname"> <em>pContainerFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aStreamsCanBeAddedDynamically</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aQueryStreamMetaData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open this container and make it ready for reading or writing, optionally reading as far into the container as necessary to find all streams. 
<p>
The caller must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ddca0a2734d52075a38368018eb671f5">close()</a> when done, but if not, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will eventually close them later but warn to the logging system. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>The resource to open; The format of this string is any url that FFMPEG supports (including additional protocols if added through the <a class="el" href="namespacecom_1_1xuggle_1_1xuggler_1_1io.html" title="This package contains the XUGGLER IO library which is used to register callbacks...">xuggler.io</a> library). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of this container. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pContainerFormat</em>&nbsp;</td><td>A pointer to a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ContainerFormat.html">ContainerFormat</a> object specifying the format of this container, or 0 (NULL) if you want us to guess. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStreamsCanBeAddedDynamically</em>&nbsp;</td><td>If true, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c4ebd5f91b50093a33a03b9891b09af" title="Open this container and make it ready for reading or writing.">open()</a> will expect that new streams can be added at any time, even after the format header has been read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aQueryStreamMetaData</em>&nbsp;</td><td>If true, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c4ebd5f91b50093a33a03b9891b09af" title="Open this container and make it ready for reading or writing.">open()</a> will call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#2d212870b29f797cbb39eed5c65094c4">queryStreamMetaData()</a> on this container, which will potentially block until it has ready enough data to find all streams in a container. If false, it will only block to read a minimal header for this container format.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#1171e6664c2238563e35b6182ff073eb">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="aa5c811008064fb4c630e972d1fc0ca3"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getContainerFormat" ref="aa5c811008064fb4c630e972d1fc0ca3" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html">IContainerFormat</a>* com::xuggle::xuggler::IContainer::getContainerFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object being used for this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a>, or null if the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> doesn't yet know. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html" title="Specifies format information than can be used to configure an IContainer for input...">IContainerFormat</a> object, or null. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fe5f6450c9f1a38cc1617baf98e5a7bf">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="ddca0a2734d52075a38368018eb671f5"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::close" ref="ddca0a2734d52075a38368018eb671f5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the container. 
<p>
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#1c4ebd5f91b50093a33a03b9891b09af" title="Open this container and make it ready for reading or writing.">open()</a> must have been called first, or else an error is returned.<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>.  <p>
If this method exits because of an interruption, all resources will be closed anyway. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#8db00c9340d6aafa29ce46d66429dbb5">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="da0f091c4272a46c83b3d1f9fd73e732"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getType" ref="da0f091c4272a46c83b3d1f9fd73e732" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#eb6fa73bec032bc1045d17f8fea0e7a5">Type</a> com::xuggle::xuggler::IContainer::getType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find out the type of this container. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Type of this container. <a class="el" href="">IContainer.Type#READ</a> if not yet opened. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#cb30481cf91632e1e6de7674e1ef92f8">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="10d95ce646db22b3a9a09e684bb76663"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getNumStreams" ref="10d95ce646db22b3a9a09e684bb76663" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getNumStreams           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of streams in this container. 
<p>
If opened in <a class="el" href="">IContainer.Type#READ</a> mode, this will query the stream and find out how many streams are in it.<p>
If opened in <a class="el" href="">IContainer.Type#WRITE</a> mode, this will return the number of streams the caller has added to date.<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of streams in this container. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#91feaac97271cd5e8308729f18e84760">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f5f866cf02b17802411d18edc554083"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getStream" ref="4f5f866cf02b17802411d18edc554083" args="(uint32_t streamIndex)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a>* com::xuggle::xuggler::IContainer::getStream           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the stream at the given position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>the index of this stream in the container </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The stream at that position in the container, or null if none there. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbc015aeee158dbb7e571500cf0018db">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="3a6d69e1efc872094a2332dff86ca1f9"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::addNewStream" ref="3a6d69e1efc872094a2332dff86ca1f9" args="(int32_t id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a>* com::xuggle::xuggler::IContainer::addNewStream           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new stream in this container and returns it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>A format-dependent id for this stream.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new stream. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ca9af5946b65f4f2280241ad57b860cc">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="5f130eca02f4a0ca729836f68cf75513"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::writeHeader" ref="5f130eca02f4a0ca729836f68cf75513" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::writeHeader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a header, if needed, for this container. 
<p>
Call this AFTER you've added all streams you want to add, opened all IStreamCoders for those streams (with proper configuration) and before you write the first frame. If you attempt to write a header but haven't opened all codecs, this method will log a warning, and your output file will likely be corrupt. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful. &lt; 0 if not. Always -1 if this is a READ container. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#894bffc35224c8f0e3947aa7fb821ed7">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="b951e5d5469db4cb1029a4af71e689df"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::writeTrailer" ref="b951e5d5469db4cb1029a4af71e689df" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::writeTrailer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a trailer, if needed, for this container. 
<p>
Call this AFTER you've written all data you're going to write to this container but BEFORE you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b">IStreamCoder#close()</a> on your <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> objects. <p>
You must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">writeHeader()</a> before you call this (and if you don't, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will warn loudly and not actually write the trailer).  <p>
If you have closed any of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> objects that were open when you called <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">writeHeader()</a>, then this method will fail. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful. &lt; 0 if not. Always &lt;0 if this is a READ container. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a819c2aa3e1509493132f600012a1b5b">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="aa5604ff560da4cb93c3a8d363a08fe3"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::readNextPacket" ref="aa5604ff560da4cb93c3a8d363a08fe3" args="(IPacket *packet)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::readNextPacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the next packet into the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given...">IPacket</a>. 
<p>
This method will release any buffers currently held by this packet and allocate new ones. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In/Out] The packet the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> will read into.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if successful, or &lt;0 if not. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#2e4dca124e41521350735e78a5e0fd59">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="17580f71444c579fa2a8c29ec382c7c6"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::writePacket" ref="17580f71444c579fa2a8c29ec382c7c6" args="(IPacket *packet, bool forceInterleave)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::writePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forceInterleave</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the contents of the packet to the container. 
<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In] The packet to write out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>forceInterleave</em>&nbsp;</td><td>[In] If true, then this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> will make sure all packets are interleaved by DTS (even across streams in a container). If false, the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> won't, and it's up to the caller to interleave if necessary.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd># of bytes written if successful, or &lt;0 if not. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#7d41ce13583cbedfd55a0f2b8f38b7b6">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="e0b96a4e7be3e0391ba5b41bdcc1a75d"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::writePacket" ref="e0b96a4e7be3e0391ba5b41bdcc1a75d" args="(IPacket *packet)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::writePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the contents of the packet to the container, but make sure the packets are interleaved. 
<p>
This means the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> may have to queue up packets from one stream while waiting for packets from another. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>[In] The packet to write out.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd># of bytes written if successful, or &lt;0 if not. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#b01206e3ec2168f3fb6eabfb1525f1d8">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="b3ec74db19c1b9e28443be7cae0738bd"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::make" ref="b3ec74db19c1b9e28443be7cae0738bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> * com::xuggle::xuggler::IContainer::make           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new container object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new container, or null on error. </dd></dl>

<p>Definition at line <a class="el" href="IContainer_8cpp-source.html#l00031">31</a> of file <a class="el" href="IContainer_8cpp-source.html">IContainer.cpp</a>.</p>

<p>References <a class="el" href="Global_8cpp-source.html#l00156">com::xuggle::xuggler::Global::init()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00032"></a>00032   {
<a name="l00033"></a>00033     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#d4f1787e8c9f61cf8cb31eceddaa477f" title="Internal Only.">Global::init</a>();
<a name="l00034"></a>00034     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#b3ec74db19c1b9e28443be7cae0738bd" title="Create a new container object.">Container::make</a>();
<a name="l00035"></a>00035   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2d212870b29f797cbb39eed5c65094c4"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::queryStreamMetaData" ref="2d212870b29f797cbb39eed5c65094c4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::queryStreamMetaData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempts to read all the meta data in this stream, potentially by reading ahead and decoding packets. 
<p>
Any packets this method reads ahead will be cached and correctly returned when you read packets, but this method can be non-blocking potentially until end of container to get all meta data. Take care when you call it. <p>
After this method is called, other meta data methods like <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#46210689b9ae96925e7e193930bb9fb0">getDuration()</a> should work. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on failure. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9b1fcb51b448e84a4e62d97bf07b716">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="095c2693bb17c3c92da831cd2e5d17da"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::seekKeyFrame" ref="095c2693bb17c3c92da831cd2e5d17da" args="(int32_t streamIndex, int64_t timestamp, int32_t flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::seekKeyFrame           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeks to the key frame at (or the first one after) the given timestamp. 
<p>
This method will always fail for any <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> that is not seekable (e.g. is streamed). When successful the next call to <a class="el" href="">readNextPacket(IPacket)</a> will get the next keyframe from the sought for stream.<p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>.  <p>
<b>WARNING:</b>: This method will be deprecated in a future Xuggler release and replaced with the new API <a class="el" href="">seekKeyFrame(int, long, long, long, int)</a>. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>The stream to search for the keyframe in; must be a stream the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> has either queried meta-data about or already ready a packet for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The timestamp, in the timebase of the stream you're looking in (not necessarily Microseconds). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to pass to com.xuggle.xuggler.io.IURLProtocolHandler's seek method.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="46210689b9ae96925e7e193930bb9fb0"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getDuration" ref="46210689b9ae96925e7e193930bb9fb0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IContainer::getDuration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the duration, if known, of this container. 
<p>
This will only work for non-streamable containers where <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> can calculate the container size.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The duration, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382">Global#NO_PTS</a> if not known. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#3d26cf3a258c11367468802b75fabcd1">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="a4854bfde32fd18dfa4146c5fdf16802"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getStartTime" ref="a4854bfde32fd18dfa4146c5fdf16802" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IContainer::getStartTime           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the starting timestamp in microseconds of the first packet of the earliest stream in this container. 
<p>
This will only return value values either either (a) for non-streamable containers where <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> can calculate the container size or (b) after <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> has actually read the first packet from a streamable source. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The starting timestamp in microseconds, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382">Global#NO_PTS</a> if not known. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d5f4120e63c0bc4dccf2ee8c37771364">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="34a28d2cea2d7769f9220034a1e8ef77"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getFileSize" ref="34a28d2cea2d7769f9220034a1e8ef77" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IContainer::getFileSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the file size in bytes of this container. 
<p>
This will only return a valid value if the container is non-streamed and supports seek.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The file size in bytes, or &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#316b8205188f0ac40f60ad00fcbf2983">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1d24ebd9fa679dc4e03b5c745cbdf3bd"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getBitRate" ref="1d24ebd9fa679dc4e03b5c745cbdf3bd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getBitRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the calculated overall bit rate of this file. 
<p>
This will only return a valid value if the container is non-streamed and supports seek.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>The overall bit rate in bytes per second, or &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#a8a88f87119ac97f667b292aa1d19eb6">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1a8ee4550ef8ae857ac96126657e6e9a"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getNumProperties" ref="1a8ee4550ef8ae857ac96126657e6e9a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getNumProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of settable properties on this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>total number of options (not including constant definitions) </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4100ba10f4ed468f93e0e406d8df966f">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c0c2f30bba223aab4fa028eb4427249"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyMetaData" ref="1c0c2f30bba223aab4fa028eb4427249" args="(int32_t propertyNo)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a>* com::xuggle::xuggler::IContainer::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>propertyNo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>propertyNo</em>&nbsp;</td><td>The property number in the options list.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#53a5cc27420bd775af445db84c5ec95a">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="a1325d8c31034d9883c805b2f3ddcde7"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyMetaData" ref="a1325d8c31034d9883c805b2f3ddcde7" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a>* com::xuggle::xuggler::IContainer::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#36743c0c7add3bcd5653296bbab941af">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="193d39a27e22a7b3b8221dabbe6da4cd"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setProperty" ref="193d39a27e22a7b3b8221dabbe6da4cd" args="(const char *name, const char *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a property on this Object. 
<p>
All AVOptions supported by the underlying AVClass are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name. For example "b" for bit-rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 if the property was successfully set; &lt;0 on error </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#19db2d967d4470afb196a3237a96681d">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ef795b1f539a9165e6115a87bb968be"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setProperty" ref="2ef795b1f539a9165e6115a87bb968be" args="(const char *name, double value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#f7f620dc708bf23f978efaa39230ab07">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="156bd0b2f9cf0664d3cae72c7b0fc25d"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setProperty" ref="156bd0b2f9cf0664d3cae72c7b0fc25d" args="(const char *name, int64_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#661c4c4c35c42b56947ab186d3a183ad">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="0e4f0ab8ee56dfa12a05c07682c53b5d"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setProperty" ref="0e4f0ab8ee56dfa12a05c07682c53b5d" args="(const char *name, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c91b7be505f35547be20061e4462d377">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="e3604cbb97d2059eca19688e192dcd26"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setProperty" ref="e3604cbb97d2059eca19688e192dcd26" args="(const char *name, IRational *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#92404787199b49ef1d33348db55f629d">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1d1e4b2c4bbf93fc86c70e517c8e9578"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyAsString" ref="1d1e4b2c4bbf93fc86c70e517c8e9578" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* com::xuggle::xuggler::IContainer::getPropertyAsString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a property on this Object. 
<p>
Note for C++ callers; you must free the returned array with delete[] in order to avoid a memory leak. If you call from Java or any other language, you don't need to worry about this. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>property name</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an string copy of the option value, or null if the option doesn't exist. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d249081d220c772f8e0d7c9f569a6d5b">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="8eb0ee5298eeecaa2028b2e4ae3a43f5"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyAsDouble" ref="8eb0ee5298eeecaa2028b2e4ae3a43f5" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double com::xuggle::xuggler::IContainer::getPropertyAsDouble           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a double;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ae0d0772742776f6a91c6b1763917242">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="f6a4994a87d3246c90ca49a876b1cdd6"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyAsLong" ref="f6a4994a87d3246c90ca49a876b1cdd6" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IContainer::getPropertyAsLong           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an long;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c2576ac8fb9b1c5cf9257b47f0081b56">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="b9c88e910ff0fbc79fe222bfd3cd9c43"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyAsRational" ref="b9c88e910ff0fbc79fe222bfd3cd9c43" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a>* com::xuggle::xuggler::IContainer::getPropertyAsRational           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#9820ba26dd86a4db0d185d047454916f">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="1d2a804668a41b04c0428ce48dc10c12"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPropertyAsBoolean" ref="1d2a804668a41b04c0428ce48dc10c12" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IContainer::getPropertyAsBoolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value of property, or false on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#bbf3ccc481d3c88a0b2c4d1a508d56c0">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="38c5b1ae3388b104f4be7d764b437906"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getFlags" ref="38c5b1ae3388b104f4be7d764b437906" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the flags associated with this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The (compacted) value of all flags set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#34b5a0ead185e980905b1b379bbd6291">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="a371e8fc5ba1b4717c4750b26cb69037"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setFlags" ref="a371e8fc5ba1b4717c4750b26cb69037" args="(int32_t newFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IContainer::setFlags           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flags to use with this object. 
<p>
All values must be ORed (|) together.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFlags</em>&nbsp;</td><td>The new set flags for this codec. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#83173a1086878cdef9f645c7f8c14a8c">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="a2cb2aecf555dc3b0e37a8d261d7f595"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getFlag" ref="a2cb2aecf555dc3b0e37a8d261d7f595" args="(Flags flag)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IContainer::getFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the setting for the specified flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag you want to find the setting for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for false; non-zero for true </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#0214b27eb3bddf589d2b4bc481091c5d">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="668d5d01c638cc5bbd5b28d0aaa4b684"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setFlag" ref="668d5d01c638cc5bbd5b28d0aaa4b684" args="(Flags flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IContainer::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#fc8e4e7d878d36da6a5137577b00c02a">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set it to (true or false) </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#6812f6402105fd2424f01b3ed34b059f">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="e111c3ee0deb32a534aae9cd033f0a7a"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getURL" ref="e111c3ee0deb32a534aae9cd033f0a7a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* com::xuggle::xuggler::IContainer::getURL           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the URL the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> was opened with. 
<p>
May return null if unknown. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the URL opened, or null. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c60bbfd16ab2e713ed98c330189135f5">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="f18be848a461be8efde6cee3f1c06dbf"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::flushPackets" ref="f18be848a461be8efde6cee3f1c06dbf" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::flushPackets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush all packets to output. 
<p>
Will only work on <a class="el" href="">IContainer.Type#WRITE</a> containers. <p>
If the current thread is interrupted while this blocking method is running the method will return with a negative value. To check if the method exited because of an interruption pass the return value to <a class="el" href="">IError#make(int)</a> and then check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IError.html#9cb0f3dc72593d9b6ef444ce10a9e79a">IError#getType()</a> to see if it is <a class="el" href="">IError.Type#ERROR_INTERRUPTED</a>. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c9e8a8e23fefa87a8ca34ee132c9d16a">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="490b52a2589e490d0d34247d382151ef"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getReadRetryCount" ref="490b52a2589e490d0d34247d382151ef" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getReadRetryCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of times <a class="el" href="">IContainer#readNextPacket(IPacket)</a> will retry a read if it gets a <a class="el" href="">IError.Type#ERROR_AGAIN</a> value back. 
<p>
Defaults to 1 times. &lt;0 means it will keep retrying indefinitely.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the read retry count </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#68fd2f39ddf1be3cbe7db4d95ccfbf12">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="e881592ff0c456c35d566ee2b9b66f3b"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setReadRetryCount" ref="e881592ff0c456c35d566ee2b9b66f3b" args="(int32_t count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IContainer::setReadRetryCount           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the read retry count. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#490b52a2589e490d0d34247d382151ef" title="Get the number of times IContainer#readNextPacket(IPacket) will retry a read if it...">getReadRetryCount()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The read retry count. &lt;0 means keep trying. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#e069c6c46b2566530a9d5f5ed236473c">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="9c7066428bc1ead1130f16920bd1d47e"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getParameters" ref="9c7066428bc1ead1130f16920bd1d47e" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a>* com::xuggle::xuggler::IContainer::getParameters           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parameters that will be used when opening. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>setParameters(IContainerParameters)</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The parameters </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#ac1057eaa815ad8cc1492f823112141b">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="589d287bb2170a8605e8983e81ae6586"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setParameters" ref="589d287bb2170a8605e8983e81ae6586" args="(IContainerParameters *parameters)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IContainer::setParameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerParameters.html">IContainerParameters</a> *&nbsp;</td>
          <td class="paramname"> <em>parameters</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the parameters for this container. 
<p>
Normally this is not required, but if you're opening something like a webcam, you need to specify to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> parameters such as a time base, width, height, etc.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parameters</em>&nbsp;</td><td>The parameters to set. Ignored if null. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#4b08ae798f60caf917852e56351b71bb">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="afe2fbcf6616eb5c256c436e384e0868"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::canStreamsBeAddedDynamically" ref="afe2fbcf6616eb5c256c436e384e0868" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IContainer::canStreamsBeAddedDynamically           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can streams be added dynamically to this container? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if streams can be added dynamically </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#0ebc043b97ce12dfd43f28f26f3cced8">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="d1788ab8398aea307081d6a8cacf4107"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getMetaData" ref="d1788ab8398aea307081d6a8cacf4107" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a>* com::xuggle::xuggler::IContainer::getMetaData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> for this object, or null if none. 
<p>
If the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> object that this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> came from was opened for reading, then changes via <a class="el" href="">IMetaData#setValue(String, String)</a> will have no effect on the underlying media.  <p>
If the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> object that this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> came from was opened for writing, then changes via <a class="el" href="">IMetaData#setValue(String, String)</a> will have no effect after <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">IContainer#writeHeader()</a> is called.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a>. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#668b512eb384f55c03dfd3961ca1462a">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="03b7ee2a3b40ba44176d2b8f8b081564"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setMetaData" ref="03b7ee2a3b40ba44176d2b8f8b081564" args="(IMetaData *data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IContainer::setMetaData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMetaData.html">IMetaData</a> on this object, overriding any previous meta data. 
<p>
You should call this method on writable containers and before you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#5f130eca02f4a0ca729836f68cf75513">IContainer#writeHeader</a>, as it probably won't do anything after that.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d1788ab8398aea307081d6a8cacf4107" title="Get the IMetaData for this object, or null if none.">getMetaData()</a> </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#1242ab31447bb274441dbf0f97c68771">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="97736a47ff6836e1d931e8f40a64191c"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::createSDPData" ref="97736a47ff6836e1d931e8f40a64191c" args="(com::xuggle::ferry::IBuffer *buffer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::createSDPData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the given buffer with a null-terminated ASCII set of bytes representing SDP data that is suitable for use with an RTSP-based system. 
<p>
This method only works if Xuggler is linking against a version of FFmpeg that supports RTSP.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>the <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com.xuggle.ferry.IBuffer</a> object to fill with data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written, including the terminating 0 byte, or &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#f901720a3ce47813525d459a54f3c3ad">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="d8cb3efd249708f1620d52005afc58d1"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setForcedAudioCodec" ref="d8cb3efd249708f1620d52005afc58d1" args="(ICodec::ID id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setForcedAudioCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all audio streams are encoded with the given audio codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an audio codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#005b81a5cef01432eb74f74873c64185">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="5a496ddd025c3017181887538fab29e5"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setForcedVideoCodec" ref="5a496ddd025c3017181887538fab29e5" args="(ICodec::ID id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setForcedVideoCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all video streams are encoded with the given video codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an video codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#875da3ccedd3927a024857cc52c35640">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="f1a4ae51498242dfce13bb238ec10775"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setForcedSubtitleCodec" ref="f1a4ae51498242dfce13bb238ec10775" args="(ICodec::ID id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setForcedSubtitleCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> to assume all subtitle streams are encoded with the given subtitle codec when demuxing. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The codec id </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&lt; 0 on error (e.g. not an subtitle codec); &gt;= 0 on success. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#5eb5146e5f01df2fc0ab2029ca75488c">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="afbb7a5d43a2e06bd33a45b6b3083786"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::seekKeyFrame" ref="afbb7a5d43a2e06bd33a45b6b3083786" args="(int32_t streamIndex, int64_t minTimeStamp, int64_t targetTimeStamp, int64_t maxTimeStamp, int32_t flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::seekKeyFrame           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>minTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>targetTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>maxTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
EXPERIMENTAL - Seeks to timestamp in the container. 
<p>
Seeking will be done so that the point from which all active streams can be presented successfully will be closest to <code>targetTimeStamp</code> and within <code> minTimeStamp/maxTimeStamp</code>.  <p>
If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ce79de394dbc46e9f1f7542cee176445">SEEK_FLAG_BYTE</a>, then all time stamps are in bytes and are the file position (this may not be supported by all demuxers). If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17bda2e9f78c72f87c3b6b01ae2d0a1a">SEEK_FLAG_FRAME</a>, then all time stamps are in frames in the stream with <code>streamIndex</code> (this may not be supported by all demuxers). Otherwise all time stamps are in units of the stream selected by stream_index or if stream_index is -1, in microseconds. If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d77e67f96064168bc6bae9ac720970e1">SEEK_FLAG_ANY</a>, then non-keyframes are treated as keyframes (this may not be supported by all demuxers). If flags contain <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d18e85998ab0cb1b624cfda4a5f240c2">SEEK_FLAG_BACKWARDS</a>, then we will attempt to search backwards in the container (this may not be supported by all demuxers and file protocols).  <p>
This is part of the new seek API which is still under construction. It may change in future Xuggler versions.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>index of the stream which is used as time base reference </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minTimeStamp</em>&nbsp;</td><td>smallest acceptable time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetTimeStamp</em>&nbsp;</td><td>target time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxTimeStamp</em>&nbsp;</td><td>largest acceptable time stamp. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A bitmask of the <code>SEEK_FLAG_*</code> flags, or 0 to turn all flags off. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;=0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.4 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#c71a98f5487b92fab88cc5f36299b536">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1e45fa674401ff262116000654b9ead"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setPreload" ref="c1e45fa674401ff262116000654b9ead" args="(int32_t preload)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setPreload           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>preload</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the container has not already been opened, sets the AVFormatContext.preload property which can be useful in some circumstances such as when dealing with mpeg formats. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>preload</em>&nbsp;</td><td>amount to preload </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fdce37ee74b7a4cc8f45a2b9ecc06d41">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="2bc101a4e88efed7dbfd6a0385c78c63"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getPreload" ref="2bc101a4e88efed7dbfd6a0385c78c63" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getPreload           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The amount container will attemtp to preload. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The amount to preload, error code otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#d1b240a1bb3a040814ae513cd78c7f91">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="ffd6269c4f5468f5fa78970138cf4f42"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::setMaxDelay" ref="ffd6269c4f5468f5fa78970138cf4f42" args="(int32_t maxdelay)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::setMaxDelay           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxdelay</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the max delay for the AVFormatContext.max_delay property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxdelay</em>&nbsp;</td><td>maximum delay for container </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success, error code otherwise </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#e74c019ad63453cc2584f0a752fd79f8">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<a class="anchor" name="cfc7e16b076f706ec8dfb2576909148a"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::getMaxDelay" ref="cfc7e16b076f706ec8dfb2576909148a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IContainer::getMaxDelay           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the AVFormatContext.max_delay property if possible. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The max delay, error code otherwise. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>4.0 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html#fda72b06c5c37e1de2b962e691581290">com::xuggle::xuggler::Container</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="d18e85998ab0cb1b624cfda4a5f240c2"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::SEEK_FLAG_BACKWARDS" ref="d18e85998ab0cb1b624cfda4a5f240c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d18e85998ab0cb1b624cfda4a5f240c2">com::xuggle::xuggler::IContainer::SEEK_FLAG_BACKWARDS</a> = 1<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag; Seek backwards. 
<p>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00844">844</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ce79de394dbc46e9f1f7542cee176445"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::SEEK_FLAG_BYTE" ref="ce79de394dbc46e9f1f7542cee176445" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#ce79de394dbc46e9f1f7542cee176445">com::xuggle::xuggler::IContainer::SEEK_FLAG_BYTE</a> = 2<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag; Use bytes instead of time stamps for seeking. 
<p>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00846">846</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d77e67f96064168bc6bae9ac720970e1"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::SEEK_FLAG_ANY" ref="d77e67f96064168bc6bae9ac720970e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#d77e67f96064168bc6bae9ac720970e1">com::xuggle::xuggler::IContainer::SEEK_FLAG_ANY</a> = 4<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag; Seek to any frame, even non-keyframes. 
<p>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00848">848</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="17bda2e9f78c72f87c3b6b01ae2d0a1a"></a><!-- doxytag: member="com::xuggle::xuggler::IContainer::SEEK_FLAG_FRAME" ref="17bda2e9f78c72f87c3b6b01ae2d0a1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html#17bda2e9f78c72f87c3b6b01ae2d0a1a">com::xuggle::xuggler::IContainer::SEEK_FLAG_FRAME</a> = 8<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag; Seek based on frame number instead of time stamps. 
<p>

<p>Definition at line <a class="el" href="IContainer_8h-source.html#l00850">850</a> of file <a class="el" href="IContainer_8h-source.html">IContainer.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>csrc/com/xuggle/xuggler/<a class="el" href="IContainer_8h-source.html">IContainer.h</a><li>csrc/com/xuggle/xuggler/<a class="el" href="IContainer_8cpp-source.html">IContainer.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 11 07:40:09 2011 for Xuggle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
