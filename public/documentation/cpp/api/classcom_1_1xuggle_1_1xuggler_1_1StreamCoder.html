<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xuggle: com::xuggle::xuggler::StreamCoder Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecom.html">com</a>::<a class="el" href="namespacecom_1_1xuggle.html">xuggle</a>::<a class="el" href="namespacecom_1_1xuggle_1_1xuggler.html">xuggler</a>::<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>
  </div>
</div>
<div class="contents">
<h1>com::xuggle::xuggler::StreamCoder Class Reference</h1><!-- doxytag: class="com::xuggle::xuggler::StreamCoder" --><!-- doxytag: inherits="com::xuggle::xuggler::IStreamCoder" --><code>#include &lt;<a class="el" href="StreamCoder_8h-source.html">StreamCoder.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for com::xuggle::xuggler::StreamCoder:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder__inherit__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1StreamCoder__inherit__map" alt="Inheritance graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1StreamCoder__inherit__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing..." alt="" coords="5,84,256,111"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="23,7,239,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for com::xuggle::xuggler::StreamCoder:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder__coll__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1StreamCoder__coll__map" alt="Collaboration graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1StreamCoder__coll__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html" title="com::xuggle::xuggler::Stream" alt="" coords="2229,77,2440,104"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing..." alt="" coords="924,108,1175,134"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="357,86,573,113"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html" title="Allows Java code to get data from a native buffers, and optionally modify native..." alt="" coords="684,158,868,185"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer." alt="" coords="943,5,1156,32"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio..." alt="" coords="663,57,889,84"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1AtomicInteger.html" title="Internal only." alt="" coords="7,86,239,113"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="com::xuggle::ferry::RefPointer\&lt; com::xuggle::ferry::IBuffer \&gt;" alt="" coords="1200,158,1600,185"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++." alt="" coords="655,209,897,236"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1Container.html" title="com::xuggle::xuggler::Container" alt="" coords="1624,57,1848,84"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="StreamCoder_8h-source.html#l00035">35</a> of file <a class="el" href="StreamCoder_8h-source.html">StreamCoder.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6b832d9a8c2525e5df94b86ba02c958a">getDirection</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the direction.  <a href="#6b832d9a8c2525e5df94b86ba02c958a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#64063f8de647eb0f803d46286cbffe85">getStream</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The associated <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> we're working on.  <a href="#64063f8de647eb0f803d46286cbffe85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc">getCodec</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will use.  <a href="#38d1c2a946f744d7294c77d03f8a88dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4">ICodec::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7">getCodecType</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a>.getType().  <a href="#6ce7836919f663224cac2581894af3b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5c725f733f5a79b77b07634fcc697f4f">getCodecID</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a>.getID().  <a href="#5c725f733f5a79b77b07634fcc697f4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9">setCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to the passed in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a>, discarding the old <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> if set.  <a href="#0d1c8aa67e3989f47ee5a11d82aaf2a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3b5395bc02d83e3238de554373694a79">setCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it.  <a href="#3b5395bc02d83e3238de554373694a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#aeb23b6d11c94150844c8eb4590681fa">setCodecID</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it.  <a href="#aeb23b6d11c94150844c8eb4590681fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3ad76901b42de384c16bc717a131bda4">getBitRate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bit rate.  <a href="#3ad76901b42de384c16bc717a131bda4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b62eccf1830d7855da19c9fc6d680159">setBitRate</a> (int32_t rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When ENCODING, sets the bit rate to use.  <a href="#b62eccf1830d7855da19c9fc6d680159"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0118c37786830ca1cf6b0c9d0ba9fcf7">getBitRateTolerance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bit rate tolerance.  <a href="#0118c37786830ca1cf6b0c9d0ba9fcf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b01fdd1a48ba21f453f21af54af2b494">setBitRateTolerance</a> (int32_t tolerance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When ENCODING set the bit rate tolerance.  <a href="#b01fdd1a48ba21f453f21af54af2b494"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469">getHeight</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The height, in pixels.  <a href="#4769d9bd31fdc7713ab8dfbd48215469"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#296b5949d5a4d95efc7b22759d21fbc3">setHeight</a> (int32_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the height, in pixels.  <a href="#296b5949d5a4d95efc7b22759d21fbc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4">getWidth</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The width, in pixels.  <a href="#fdd15f63bad7f537ed57d16cb514e7f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#72e99ee4873a1ac9beae122566bb6deb">setWidth</a> (int32_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the width, in pixels.  <a href="#72e99ee4873a1ac9beae122566bb6deb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448">getTimeBase</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time base this stream will ENCODE in, or the time base we detect while DECODING.  <a href="#1cb4b1a1f636f6c9cfa929202e12c448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#577fe228e82875a2f7336761bd414ecf">setTimeBase</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *newTimeBase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the time base we'll use to ENCODE with.  <a href="#577fe228e82875a2f7336761bd414ecf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b73447096b1ab3bbf1d4ac347ee90a9b">getFrameRate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate we'll claim we're using when ENCODING.  <a href="#b73447096b1ab3bbf1d4ac347ee90a9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed7307d0ffe04784b4123dd546cfb748">setFrameRate</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *newFrameRate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the frame rate we'll set in the headers of this stream while ENCODING.  <a href="#ed7307d0ffe04784b4123dd546cfb748"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#9362cb328c007ce98ee74cb5abd106a5">getNumPicturesInGroupOfPictures</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The the number of pictures in this Group of Pictures (GOP).  <a href="#9362cb328c007ce98ee74cb5abd106a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#37182d1c20e019bb80a52d4da4189f7e">setNumPicturesInGroupOfPictures</a> (int32_t gops)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the GOPS on this stream.  <a href="#37182d1c20e019bb80a52d4da4189f7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168">getPixelType</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For Video streams, get the Pixel Format in use by the stream.  <a href="#6d1e20892c0edccaf8df3164fa7cd168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f86d01c6b6c439ab59a005ba4a738d39">setPixelType</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a> pixelFmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pixel format to ENCODE with.  <a href="#f86d01c6b6c439ab59a005ba4a738d39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2">getSampleRate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sample rate we use for this stream.  <a href="#e406f7f0aaa28b55cc5194b61e4f41a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3be6a2991af4984bbff29986ba06fd15">setSampleRate</a> (int32_t sampleRate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sample rate to use when ENCODING.  <a href="#3be6a2991af4984bbff29986ba06fd15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d">getChannels</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of channels in this audio stream.  <a href="#f191e14f7153360d1cffd337c5274d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f9e830b559daf6b97441eb78e7161ca0">setChannels</a> (int32_t channels)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of channels to use when ENCODING.  <a href="#f9e830b559daf6b97441eb78e7161ca0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#97e41cec0c1d23cdb701b5b57d969b35">getSampleFormat</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the audio sample format.  <a href="#97e41cec0c1d23cdb701b5b57d969b35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8d7694b0fcfaeaf2cd102aea3064be02">setSampleFormat</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a> aFormat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sample format when ENCODING.  <a href="#8d7694b0fcfaeaf2cd102aea3064be02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0492afbd477f99707ebb0f2442b0aad9">getGlobalQuality</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality setting this codec uses for video if a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> doesn't have a quality set.  <a href="#0492afbd477f99707ebb0f2442b0aad9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#bae0a8f7611f878e77c0db6ec4cadecd">setGlobalQuality</a> (int32_t newQuality)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality to a new value.  <a href="#bae0a8f7611f878e77c0db6ec4cadecd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#be713a5c2457120817fe3156a6445bb1">getFlags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flags associated with this codec.  <a href="#be713a5c2457120817fe3156a6445bb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#810f00ec624a5fea2668df9414d79b38">setFlags</a> (int32_t newFlags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the FFMPEG flags to use with this codec.  <a href="#810f00ec624a5fea2668df9414d79b38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#63e5caa7dd85559c9ea81cd1f3cd9e2f">getFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a> flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the setting for the specified flag.  <a href="#63e5caa7dd85559c9ea81cd1f3cd9e2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#c3999550315918737d0f5e1b4b765737">setFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a> flag, bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flag.  <a href="#c3999550315918737d0f5e1b4b765737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#7215694c124919baeaf61cb59d2611ef">getAudioFrameSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For this stream, get the number of audio samples that are represented in a packet of information.  <a href="#7215694c124919baeaf61cb59d2611ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f63b93f7ee8907256f45b1abf1f0dd5d">open</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> associated with this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#f63b93f7ee8907256f45b1abf1f0dd5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#adadc04f0940c3afa23655ab67e86b73">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> that was opened on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#adadc04f0940c3afa23655ab67e86b73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5077165e8e719fedfce7810ce4016cd7">decodeAudio</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *pOutSamples, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, int32_t byteOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode this packet into pOutSamples.  <a href="#5077165e8e719fedfce7810ce4016cd7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5febedd0e02c02da5cdb0d56de264835">decodeVideo</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *pOutFrame, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, int32_t byteOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode this packet into pOutFrame.  <a href="#5febedd0e02c02da5cdb0d56de264835"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4e8e90c3ba84aab18d7e17379c59c865">encodeVideo</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *pOutPacket, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *pFrame, int32_t suggestedBufferSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode the given frame using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#4e8e90c3ba84aab18d7e17379c59c865"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#81102eae7e5d013057c3a38f9e636cbc">encodeAudio</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *pOutPacket, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *pSamples, uint32_t sampleToStartFrom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode the given samples using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#81102eae7e5d013057c3a38f9e636cbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#322018854233516dabd22740fbc9e5e3">getNextPredictedPts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For this stream, get the next Pts that we expect to decode.  <a href="#322018854233516dabd22740fbc9e5e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#afc7dd7a6f0ee4157beeafc6c0561ac9">getCodecTag</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the 4-byte FOURCC tag (Least Significant Byte first).  <a href="#afc7dd7a6f0ee4157beeafc6c0561ac9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#44de26df5c2b94ff6a05edb0a25eb749">setCodecTag</a> (int32_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the 4-byte FOURCC tag for this coder.  <a href="#44de26df5c2b94ff6a05edb0a25eb749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4b46738b73578892a602c9e4f5d86b9a">getNumProperties</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of settable properties on this object.  <a href="#4b46738b73578892a602c9e4f5d86b9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e455a70c2e5117f2606aef6e78851eb9">getPropertyMetaData</a> (int32_t propertyNo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#e455a70c2e5117f2606aef6e78851eb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#986ce910417e9eae24db40582628fc36">getPropertyMetaData</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#986ce910417e9eae24db40582628fc36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#11e185722fd04e12b149a920acccda58">setProperty</a> (const char *name, const char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a property on this Object.  <a href="#11e185722fd04e12b149a920acccda58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#a3c98a470f35ea37de9b09e59051adb4">setProperty</a> (const char *name, double value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#a3c98a470f35ea37de9b09e59051adb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#c088c801ac620c2408a2d772ef0d4106">setProperty</a> (const char *name, int64_t value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#c088c801ac620c2408a2d772ef0d4106"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0b410e91987886c9aaa054409bd264f6">setProperty</a> (const char *name, bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#0b410e91987886c9aaa054409bd264f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#745884fb6d54f10306298ec51c37c1aa">setProperty</a> (const char *name, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#745884fb6d54f10306298ec51c37c1aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#46ad55458a7bc58e68773cefc7a2bb46">getPropertyAsString</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a property on this Object.  <a href="#46ad55458a7bc58e68773cefc7a2bb46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#860e21eba8f6a01bbd89658b62f9c51d">getPropertyAsDouble</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a double;.  <a href="#860e21eba8f6a01bbd89658b62f9c51d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#577f109de16549bebcfda6c275cd63c8">getPropertyAsLong</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an long;.  <a href="#577f109de16549bebcfda6c275cd63c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#67ec2cafa9879d66f862cdcd18ed831b">getPropertyAsRational</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;.  <a href="#67ec2cafa9879d66f862cdcd18ed831b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8198a8c1864f7e80360a32e3464e4be4">getPropertyAsBoolean</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a boolean.  <a href="#8198a8c1864f7e80360a32e3464e4be4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0fd9b5cc2bcabf4d605923f9559cef52">isOpen</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> is currently open.  <a href="#0fd9b5cc2bcabf4d605923f9559cef52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#35c1957cd69edc56727d8cb124ff0c64">getDefaultAudioFrameSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default audio frame size (in samples).  <a href="#35c1957cd69edc56727d8cb124ff0c64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#559e498fccb1698f959fd021948988bf">setDefaultAudioFrameSize</a> (int32_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default audio frame size.  <a href="#559e498fccb1698f959fd021948988bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1f07e402d43b4a3c577d5c2d3a09d604">setCodec</a> (int32_t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#256e4138f677f8cb183cc60254182ca5">setStream</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *, bool assumeOnlyStream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#877735e5549d26eb3e22c67b11b7b4b3">streamClosed</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#dfb0fb4245829c6b69d0199794cbdab0">getNumDroppedFrames</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of frames this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> had to drop to encode at the specified <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448">getTimeBase()</a>.  <a href="#dfb0fb4245829c6b69d0199794cbdab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8fb1b9a720ffc81d4cfe813992619239">setAutomaticallyStampPacketsForStream</a> (bool value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for.  <a href="#8fb1b9a720ffc81d4cfe813992619239"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#cbb4270459aff43a8016d9cffc3ba466">getAutomaticallyStampPacketsForStream</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for.  <a href="#cbb4270459aff43a8016d9cffc3ba466"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0131a9f0262286143fe03caf5528f860">acquire</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal Only.  <a href="#0131a9f0262286143fe03caf5528f860"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal Only.  <a href="#1255b6ea6a270ed2391edcb0eab63c5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#308231743dc003b0eb2a50b66948c8ca">setExtraData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *src, int32_t offset, int32_t length, bool allocNew)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from the given buffer into the extra-data area maintained by encoders.  <a href="#308231743dc003b0eb2a50b66948c8ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b3a67a201a8d07c137d3e3583dbdd1f4">getExtraData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *dest, int32_t offset, int32_t maxBytesToCopy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the current content of the extra-data buffer maintained by this codec (e.g.  <a href="#b3a67a201a8d07c137d3e3583dbdd1f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#82786dc6502d13f4d33b4defc7cef81f">getExtraDataSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current number of bytes of data maintained in the coder extra-data area.  <a href="#82786dc6502d13f4d33b4defc7cef81f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> direction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method creates a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that is not tied to any container or stream.  <a href="#ce525892dddad9328378e914560b6465"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e0854001b5bcb9f727719dd343481696">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> direction, AVCodecContext *context, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method creates a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that is tied to a specific stream in a container.  <a href="#e0854001b5bcb9f727719dd343481696"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#42c718c11e25574010f6b2921228a490">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> direction, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *copyCoder)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed979bf4a49888aaaa4d26101451cb65">StreamCoder</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b9ceaa868d141ebab683005a5ccbaddf">~StreamCoder</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ed979bf4a49888aaaa4d26101451cb65"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::StreamCoder" ref="ed979bf4a49888aaaa4d26101451cb65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::StreamCoder::StreamCoder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00045">45</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="IStreamCoder_8h-source.html#l00053">com::xuggle::xuggler::IStreamCoder::DECODING</a>, <a class="el" href="IRational_8cpp-source.html#l00079">com::xuggle::xuggler::IRational::make()</a>, and <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00045"></a>00045                          :
<a name="l00046"></a>00046   mCodec(0)
<a name="l00047"></a>00047 {
<a name="l00048"></a>00048   mCodecContext = 0;
<a name="l00049"></a>00049   <span class="comment">// default to DECODING.</span>
<a name="l00050"></a>00050   mDirection = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6">DECODING</a>;
<a name="l00051"></a>00051   mOpened = <span class="keyword">false</span>;
<a name="l00052"></a>00052   mStream = 0;
<a name="l00053"></a>00053   mAudioFrameBuffer = 0;
<a name="l00054"></a>00054   mBytesInFrameBuffer = 0;
<a name="l00055"></a>00055   mFakePtsTimeBase = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html#af5ff8225c1afcdaed9ab85018806b89" title="Get a new rational that will be set to 0/0.">IRational::make</a>(1, AV_TIME_BASE);
<a name="l00056"></a>00056   mFakeNextPts = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00057"></a>00057   mFakeCurrPts = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00058"></a>00058   mLastPtsEncoded = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00059"></a>00059   mSamplesCoded = 0;
<a name="l00060"></a>00060   mLastExternallySetTimeStamp = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00061"></a>00061   mDefaultAudioFrameSize = 576;
<a name="l00062"></a>00062   mNumDroppedFrames = 0;
<a name="l00063"></a>00063   mAutomaticallyStampPacketsForStream = <span class="keyword">true</span>;
<a name="l00064"></a>00064   <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; <span class="keyword">sizeof</span>(mPtsBuffer)/<span class="keyword">sizeof</span>(mPtsBuffer[0]); i++)
<a name="l00065"></a>00065   {
<a name="l00066"></a>00066     mPtsBuffer[i] = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00067"></a>00067   }
<a name="l00068"></a>00068 }

</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b9ceaa868d141ebab683005a5ccbaddf"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::~StreamCoder" ref="b9ceaa868d141ebab683005a5ccbaddf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::StreamCoder::~StreamCoder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00070">70</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00071"></a>00071 {
<a name="l00072"></a>00072   reset();
<a name="l00073"></a>00073 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6b832d9a8c2525e5df94b86ba02c958a"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getDirection" ref="6b832d9a8c2525e5df94b86ba02c958a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> com::xuggle::xuggler::StreamCoder::getDirection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the direction. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The direction this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> works in. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b508aae561f4617d9871b4dabd71a2e1">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8h-source.html#l00044">44</a> of file <a class="el" href="StreamCoder_8h-source.html">StreamCoder.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 { <span class="keywordflow">return</span> mDirection; }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="64063f8de647eb0f803d46286cbffe85"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getStream" ref="64063f8de647eb0f803d46286cbffe85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> * com::xuggle::xuggler::StreamCoder::getStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The associated <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> we're working on. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The stream associated with this object. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3193aeab178e76155937dc4bf934fb21">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00224">224</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="RefCounted_8h-source.html#l00223">VS_REF_ACQUIRE</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00100">make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00225"></a>00225 {
<a name="l00226"></a>00226   <span class="comment">// Acquire for the caller.</span>
<a name="l00227"></a>00227   <a class="code" href="RefCounted_8h.html#92c5a30381107853982caf61e1b29e39">VS_REF_ACQUIRE</a>(mStream);
<a name="l00228"></a>00228   <span class="keywordflow">return</span> mStream;
<a name="l00229"></a>00229 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="38d1c2a946f744d7294c77d03f8a88dc"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getCodec" ref="38d1c2a946f744d7294c77d03f8a88dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> * com::xuggle::xuggler::StreamCoder::getCodec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will use. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> used by this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>, or 0 (null) if none. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00232">232</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="StreamCoder_8cpp-source.html#l00277">setCodec()</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00569">open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00233"></a>00233 {
<a name="l00234"></a>00234   ICodec *retval = 0;
<a name="l00235"></a>00235   <span class="keywordflow">if</span> (!mCodec &amp;&amp; mCodecContext)
<a name="l00236"></a>00236   {
<a name="l00237"></a>00237     <span class="comment">// Try getting it from the context</span>
<a name="l00238"></a>00238     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9" title="Set the Codec to the passed in Codec, discarding the old Codec if set.">setCodec</a>(mCodecContext-&gt;codec_id);
<a name="l00239"></a>00239   }
<a name="l00240"></a>00240   <span class="keywordflow">if</span> (mCodec)
<a name="l00241"></a>00241     retval = mCodec.get();
<a name="l00242"></a>00242 
<a name="l00243"></a>00243   <span class="keywordflow">return</span> retval;
<a name="l00244"></a>00244 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6ce7836919f663224cac2581894af3b7"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getCodecType" ref="6ce7836919f663224cac2581894af3b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4">ICodec::Type</a> com::xuggle::xuggler::StreamCoder::getCodecType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a>.getType(). 
<p>
<b> Note for Native (C++) users: </b>  If you actually write code like the above from Native code, you'd leak a Codec() since you didn't call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f" title="Internal Only.">release()</a> on it. This method is a short hand way to avoid you having to worry about releasing in between.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Type of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> we'll use. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#731f039e513526ee80766a7f583cd083">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00247">247</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00365">com::xuggle::xuggler::ICodec::CODEC_TYPE_UNKNOWN</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">decodeVideo()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01230">encodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01007">encodeVideo()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l00569">open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00248"></a>00248 {
<a name="l00249"></a>00249   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4" title="The different types of Codecs that can exist in the system.">ICodec::Type</a> retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd48b16195d60f5ae9c3588254baea1f896">ICodec::CODEC_TYPE_UNKNOWN</a>;
<a name="l00250"></a>00250   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00251"></a>00251   {
<a name="l00252"></a>00252     retval = (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4" title="The different types of Codecs that can exist in the system.">ICodec::Type</a>) mCodecContext-&gt;codec_type;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254   <span class="keywordflow">else</span>
<a name="l00255"></a>00255   {
<a name="l00256"></a>00256     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempt to get CodecType from uninitialized StreamCoder"</span>);
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258   <span class="keywordflow">return</span> retval;
<a name="l00259"></a>00259 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5c725f733f5a79b77b07634fcc697f4f"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getCodecID" ref="5c725f733f5a79b77b07634fcc697f4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> com::xuggle::xuggler::StreamCoder::getCodecID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a>.getID(). 
<p>
<b> Note for Native (C++) users: </b>  If you actually write code like the above from Native code, you'd leak a Codec() since you didn't call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f" title="Internal Only.">release()</a> on it. This method is a short hand way to avoid you having to worry about releasing in between.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ID of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> we'll use. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7ada56e38b03a00aa3a032b2334ab0fc">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00262">262</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00053">com::xuggle::xuggler::ICodec::CODEC_ID_NONE</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00263"></a>00263 {
<a name="l00264"></a>00264   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28" title="These are the codecs this library currently supports.">ICodec::ID</a> retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28f87075e4ac81f926f81204f4d000bb6e">ICodec::CODEC_ID_NONE</a>;
<a name="l00265"></a>00265   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00266"></a>00266   {
<a name="l00267"></a>00267     retval = (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28" title="These are the codecs this library currently supports.">ICodec::ID</a>) mCodecContext-&gt;codec_id;
<a name="l00268"></a>00268   }
<a name="l00269"></a>00269   <span class="keywordflow">else</span>
<a name="l00270"></a>00270   {
<a name="l00271"></a>00271     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempt to get CodecID from uninitialized StreamCoder"</span>);
<a name="l00272"></a>00272   }
<a name="l00273"></a>00273   <span class="keywordflow">return</span> retval;
<a name="l00274"></a>00274 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0d1c8aa67e3989f47ee5a11d82aaf2a9"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setCodec" ref="0d1c8aa67e3989f47ee5a11d82aaf2a9" args="(ICodec *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *&nbsp;</td>
          <td class="paramname"> <em>codec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to the passed in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a>, discarding the old <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> if set. 
<p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>codec</em>&nbsp;</td><td><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to set. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#48f1f4b8179f54921de7ecba9ced0b8d">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00277">277</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Logger_8h-source.html#l00188">VS_LOG_INFO</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00232">getCodec()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00100">make()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00303">setCodec()</a>, and <a class="el" href="StreamCoder_8h-source.html#l00054">setCodecID()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00278"></a>00278 {
<a name="l00279"></a>00279   <span class="comment">// reset our code and acquire the one passed in</span>
<a name="l00280"></a>00280   <span class="keywordflow">if</span> (mCodec.value() != newCodec)
<a name="l00281"></a>00281   {
<a name="l00282"></a>00282     mCodec.reset(dynamic_cast&lt;Codec*&gt; (newCodec), <span class="keyword">true</span>);
<a name="l00283"></a>00283     <span class="comment">// Check that the new codec can do the right</span>
<a name="l00284"></a>00284     <span class="comment">// thing</span>
<a name="l00285"></a>00285     <span class="keywordflow">if</span> (mCodec &amp;&amp; mCodecContext &amp;&amp; !mOpened)
<a name="l00286"></a>00286     {
<a name="l00287"></a>00287       mCodecContext-&gt;codec_type = (<span class="keyword">enum</span> AVMediaType) mCodec-&gt;getType();
<a name="l00288"></a>00288       <span class="comment">//      if (mDirection == ENCODING)</span>
<a name="l00289"></a>00289       <span class="comment">//      {</span>
<a name="l00290"></a>00290       <span class="comment">//        avcodec_get_context_defaults2(mCodecContext, mCodecContext-&gt;codec_type);</span>
<a name="l00291"></a>00291       <span class="comment">//      }</span>
<a name="l00292"></a>00292       mCodecContext-&gt;codec_id = (<span class="keyword">enum</span> CodecID) mCodec-&gt;getIDAsInt();
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294     <span class="keywordflow">else</span>
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296       <a class="code" href="Logger_8h.html#d4421bb17c246dcfb6440dbb63312063">VS_LOG_INFO</a>(<span class="stringliteral">"Cannot set Codec because StreamCoder is either not initialized or already open"</span>);
<a name="l00297"></a>00297       mCodec = 0;
<a name="l00298"></a>00298     }
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3b5395bc02d83e3238de554373694a79"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setCodec" ref="3b5395bc02d83e3238de554373694a79" args="(ICodec::ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it. 
<p>
To see if you actually set the correct ID, call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a> and check for 0 (null).  <p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>ID of codec to set. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#4becff2779c996a1c4c546742a616add">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00303">303</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="StreamCoder_8cpp-source.html#l00277">setCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00304"></a>00304 {
<a name="l00305"></a>00305   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9" title="Set the Codec to the passed in Codec, discarding the old Codec if set.">setCodec</a>((int32_t) <span class="keywordtype">id</span>);
<a name="l00306"></a>00306 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="aeb23b6d11c94150844c8eb4590681fa"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setCodecID" ref="aeb23b6d11c94150844c8eb4590681fa" args="(ICodec::ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::StreamCoder::setCodecID           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it. 
<p>
Forwards to <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#aeb23b6d11c94150844c8eb4590681fa">setCodecID(com.xuggle.xuggler.ICodec.ID)</a>  <p>
To see if you actually set the correct ID, call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec()</a> and check for 0 (null).  <p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>ID of codec to set. </td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#45a4e37591aabf5e12cb78b2b154fc44">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8h-source.html#l00054">54</a> of file <a class="el" href="StreamCoder_8h-source.html">StreamCoder.h</a>.</p>

<p>References <a class="el" href="StreamCoder_8cpp-source.html#l00277">setCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00054"></a>00054 { <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9" title="Set the Codec to the passed in Codec, discarding the old Codec if set.">setCodec</a>(<span class="keywordtype">id</span>); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3ad76901b42de384c16bc717a131bda4"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getBitRate" ref="3ad76901b42de384c16bc717a131bda4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getBitRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bit rate. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The bit-rate the stream is, or will be, encoded in. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#721d05712a3bbadb4e9cb296c31f06c5">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00331">331</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00332"></a>00332 {
<a name="l00333"></a>00333   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;bit_rate : -1);
<a name="l00334"></a>00334 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b62eccf1830d7855da19c9fc6d680159"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setBitRate" ref="b62eccf1830d7855da19c9fc6d680159" args="(int32_t rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setBitRate           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When ENCODING, sets the bit rate to use. 
<p>
No-op when DECODING. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3ad76901b42de384c16bc717a131bda4" title="The bit rate.">getBitRate()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>The bit rate to use. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d7e0d1ab0062890a09d16520eac7f7fb">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00336">336</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00337"></a>00337 {
<a name="l00338"></a>00338   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00339"></a>00339     mCodecContext-&gt;bit_rate = val;
<a name="l00340"></a>00340 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0118c37786830ca1cf6b0c9d0ba9fcf7"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getBitRateTolerance" ref="0118c37786830ca1cf6b0c9d0ba9fcf7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getBitRateTolerance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bit rate tolerance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The bit-rate tolerance </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0daab96eace6c53c2fef0e76f0893400">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00342">342</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00343"></a>00343 {
<a name="l00344"></a>00344   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;bit_rate_tolerance : -1);
<a name="l00345"></a>00345 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b01fdd1a48ba21f453f21af54af2b494"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setBitRateTolerance" ref="b01fdd1a48ba21f453f21af54af2b494" args="(int32_t tolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setBitRateTolerance           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When ENCODING set the bit rate tolerance. 
<p>
No-op when DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>The bit rate tolerance </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#730d5312efc1f4c3d75a495781824618">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00347">347</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00348"></a>00348 {
<a name="l00349"></a>00349   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00350"></a>00350     mCodecContext-&gt;bit_rate_tolerance = val;
<a name="l00351"></a>00351 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4769d9bd31fdc7713ab8dfbd48215469"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getHeight" ref="4769d9bd31fdc7713ab8dfbd48215469" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getHeight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The height, in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The height of the video frames in the attached stream or -1 if an audio stream, or we cannot determine the height. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#30d036216176596621aa86988366b498">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00353">353</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00861">decodeVideo()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l01007">encodeVideo()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00354"></a>00354 {
<a name="l00355"></a>00355   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;height : -1);
<a name="l00356"></a>00356 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="296b5949d5a4d95efc7b22759d21fbc3"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setHeight" ref="296b5949d5a4d95efc7b22759d21fbc3" args="(int32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setHeight           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>height</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the height, in pixels. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469" title="The height, in pixels.">getHeight()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Sets the height of video frames we'll encode. No-op when DECODING. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#934fbd205a2f93b0eae1ebf309ab88ea">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00359">359</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00360"></a>00360 {
<a name="l00361"></a>00361   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00362"></a>00362     mCodecContext-&gt;height = val;
<a name="l00363"></a>00363 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="fdd15f63bad7f537ed57d16cb514e7f4"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getWidth" ref="fdd15f63bad7f537ed57d16cb514e7f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The width, in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The width of the video frames in the attached stream or -1 if an audio stream, or we cannot determine the width. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#833b9a4f028740f5d5829de0c70d2208">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00366">366</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00861">decodeVideo()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l01007">encodeVideo()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00367"></a>00367 {
<a name="l00368"></a>00368   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;width : -1);
<a name="l00369"></a>00369 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="72e99ee4873a1ac9beae122566bb6deb"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setWidth" ref="72e99ee4873a1ac9beae122566bb6deb" args="(int32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setWidth           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>width</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the width, in pixels. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4" title="The width, in pixels.">getWidth()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Sets the width of video frames we'll encode. No-op when DECODING. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b6c9be1de92dfa7e4f8a12c552a5a7c9">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00372">372</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00373"></a>00373 {
<a name="l00374"></a>00374   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00375"></a>00375     mCodecContext-&gt;width = val;
<a name="l00376"></a>00376 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1cb4b1a1f636f6c9cfa929202e12c448"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getTimeBase" ref="1cb4b1a1f636f6c9cfa929202e12c448" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> * com::xuggle::xuggler::StreamCoder::getTimeBase           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the time base this stream will ENCODE in, or the time base we detect while DECODING. 
<p>
Caller must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f" title="Internal Only.">release()</a> on the returned value.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The time base this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> is using. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00379">379</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Stream_8cpp-source.html#l00132">com::xuggle::xuggler::Stream::getTimeBase()</a>, and <a class="el" href="IRational_8cpp-source.html#l00079">com::xuggle::xuggler::IRational::make()</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">decodeVideo()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01230">encodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01007">encodeVideo()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l00100">make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00380"></a>00380 {
<a name="l00381"></a>00381   <span class="comment">// we make a new value and return it; caller must</span>
<a name="l00382"></a>00382   <span class="comment">// release.</span>
<a name="l00383"></a>00383   IRational *retval = 0;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">// annoyingly, some codec contexts will NOT have</span>
<a name="l00386"></a>00386   <span class="comment">// a timebase... so we take it from stream then.</span>
<a name="l00387"></a>00387   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; mCodecContext-&gt;time_base.den
<a name="l00388"></a>00388       &amp;&amp; mCodecContext-&gt;time_base.num)
<a name="l00389"></a>00389   {
<a name="l00390"></a>00390     retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html#af5ff8225c1afcdaed9ab85018806b89" title="Get a new rational that will be set to 0/0.">Rational::make</a>(&amp;mCodecContext-&gt;time_base);
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mAutomaticallyStampPacketsForStream)
<a name="l00393"></a>00393   {
<a name="l00394"></a>00394     retval = mStream ? mStream-&gt;getTimeBase() : 0;
<a name="l00395"></a>00395   }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397   <span class="keywordflow">return</span> retval;
<a name="l00398"></a>00398 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="577fe228e82875a2f7336761bd414ecf"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setTimeBase" ref="577fe228e82875a2f7336761bd414ecf" args="(IRational *newTimeBase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setTimeBase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>newTimeBase</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time base we'll use to ENCODE with. 
<p>
A no-op when DECODING.<p>
As a convenience, we forward this call to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html#3525579ab1a040d62cf04cfea7815410">Stream::setTimeBase()</a> method.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newTimeBase</em>&nbsp;</td><td>The new time base to use. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b2d539f28acdf1b569dfc6a8602bf5ae">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00401">401</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html#20c880398422224e8d9d2ea9168bcc3e">com::xuggle::xuggler::IRational::getDenominator()</a>, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html#ed0b2f7a83754d6642d6d60d1bf31fb9">com::xuggle::xuggler::IRational::getNumerator()</a>, and <a class="el" href="Logger_8h-source.html#l00188">VS_LOG_INFO</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00402"></a>00402 {
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; src &amp;&amp; !mOpened)
<a name="l00404"></a>00404   {
<a name="l00405"></a>00405     mCodecContext-&gt;time_base.num = src-&gt;getNumerator();
<a name="l00406"></a>00406     mCodecContext-&gt;time_base.den = src-&gt;getDenominator();
<a name="l00407"></a>00407   }
<a name="l00408"></a>00408   <span class="keywordflow">else</span>
<a name="l00409"></a>00409   {
<a name="l00410"></a>00410     <a class="code" href="Logger_8h.html#d4421bb17c246dcfb6440dbb63312063">VS_LOG_INFO</a>(<span class="stringliteral">"Failed to setTimeBase on StreamCoder"</span>);
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b73447096b1ab3bbf1d4ac347ee90a9b"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getFrameRate" ref="b73447096b1ab3bbf1d4ac347ee90a9b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> * com::xuggle::xuggler::StreamCoder::getFrameRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate we'll claim we're using when ENCODING. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The frame rate. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#f9f2c9b61bf00102711d42fa4b86eb9b">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00421">421</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Stream_8cpp-source.html#l00121">com::xuggle::xuggler::Stream::getFrameRate()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00422"></a>00422 {
<a name="l00423"></a>00423   <span class="keywordflow">return</span> (mStream ? mStream-&gt;getFrameRate() : 0);
<a name="l00424"></a>00424 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ed7307d0ffe04784b4123dd546cfb748"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setFrameRate" ref="ed7307d0ffe04784b4123dd546cfb748" args="(IRational *newFrameRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setFrameRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>newFrameRate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the frame rate we'll set in the headers of this stream while ENCODING. 
<p>
Note that you can set whatever frame-rate you'd like, but the TimeBase and the PTS you set on the encoded audio and video frames can override this.<p>
As a convenience, we forward this call to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html#c0410f0b5c8ae709ecf42f46650854cf">Stream::setFrameRate()</a> method.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b73447096b1ab3bbf1d4ac347ee90a9b" title="Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate...">getFrameRate()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFrameRate</em>&nbsp;</td><td>The new frame rate to use. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3fdbe34d0a17f1a65b506bd4e678bfd6">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00427">427</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Stream_8cpp-source.html#l00151">com::xuggle::xuggler::Stream::setFrameRate()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00428"></a>00428 {
<a name="l00429"></a>00429   <span class="keywordflow">if</span> (mStream &amp;&amp; !mOpened)
<a name="l00430"></a>00430     mStream-&gt;setFrameRate(src);
<a name="l00431"></a>00431 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9362cb328c007ce98ee74cb5abd106a5"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getNumPicturesInGroupOfPictures" ref="9362cb328c007ce98ee74cb5abd106a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getNumPicturesInGroupOfPictures           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The the number of pictures in this Group of Pictures (GOP). 
<p>
See the MPEG specs for what a GOP is officially, but this is the minimum number of frames between key-frames (or Intra-Frames in MPEG speak).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the GOPS for this stream. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bb1cdc689646b3599267bbc0ea42f646">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00434">434</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00435"></a>00435 {
<a name="l00436"></a>00436   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;gop_size : -1);
<a name="l00437"></a>00437 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="37182d1c20e019bb80a52d4da4189f7e"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setNumPicturesInGroupOfPictures" ref="37182d1c20e019bb80a52d4da4189f7e" args="(int32_t gops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setNumPicturesInGroupOfPictures           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>gops</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the GOPS on this stream. 
<p>
Ignored if DECODING.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#9362cb328c007ce98ee74cb5abd106a5" title="The the number of pictures in this Group of Pictures (GOP).">getNumPicturesInGroupOfPictures()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gops</em>&nbsp;</td><td>The new GOPS for the stream we're encoding. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d7efb17b72661318751f73bf3d890d5a">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00440">440</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00441"></a>00441 {
<a name="l00442"></a>00442   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00443"></a>00443     mCodecContext-&gt;gop_size = val;
<a name="l00444"></a>00444 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6d1e20892c0edccaf8df3164fa7cd168"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPixelType" ref="6d1e20892c0edccaf8df3164fa7cd168" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a> com::xuggle::xuggler::StreamCoder::getPixelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For Video streams, get the Pixel Format in use by the stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Pixel format, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742914b9479e5b8850fe395b69648e00fb0">IPixelFormat::NONE</a> if audio. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3b014e161a955d302d03fac3d39a5d37">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00447">447</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="IPixelFormat_8h-source.html#l00059">com::xuggle::xuggler::IPixelFormat::NONE</a>, and <a class="el" href="Logger_8h-source.html#l00182">VS_LOG_ERROR</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00861">decodeVideo()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l01007">encodeVideo()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00448"></a>00448 {
<a name="l00449"></a>00449   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742" title="Pixel format.">IPixelFormat::Type</a> retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742914b9479e5b8850fe395b69648e00fb0">IPixelFormat::NONE</a>;
<a name="l00450"></a>00450   int32_t type = 0;
<a name="l00451"></a>00451   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00452"></a>00452   {
<a name="l00453"></a>00453     retval = (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742" title="Pixel format.">IPixelFormat::Type</a>) mCodecContext-&gt;pix_fmt;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455     <span class="comment">// little check here to see if we have an undefined int32_t.</span>
<a name="l00456"></a>00456     type = (int32_t) retval;
<a name="l00457"></a>00457     <span class="keywordflow">if</span> (type != mCodecContext-&gt;pix_fmt) {
<a name="l00458"></a>00458       <a class="code" href="Logger_8h.html#2c82c858d2f918174d3fac9eb760752e">VS_LOG_ERROR</a>(<span class="stringliteral">"Undefined pixel format type: %d"</span>, mCodecContext-&gt;pix_fmt);
<a name="l00459"></a>00459       retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742914b9479e5b8850fe395b69648e00fb0">IPixelFormat::NONE</a>;
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462   <span class="keywordflow">return</span> retval;
<a name="l00463"></a>00463 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f86d01c6b6c439ab59a005ba4a738d39"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setPixelType" ref="f86d01c6b6c439ab59a005ba4a738d39" args="(IPixelFormat::Type pixelFmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setPixelType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a>&nbsp;</td>
          <td class="paramname"> <em>pixelFmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the pixel format to ENCODE with. 
<p>
Ignored if audio or DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixelFmt</em>&nbsp;</td><td>Pixel format to use. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c3a41a11704b3c0abb8b6e55d9f57eb3">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00466">466</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00467"></a>00467 {
<a name="l00468"></a>00468   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened)
<a name="l00469"></a>00469   {
<a name="l00470"></a>00470     mCodecContext-&gt;pix_fmt = (<span class="keyword">enum</span> PixelFormat) type;
<a name="l00471"></a>00471   }
<a name="l00472"></a>00472 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e406f7f0aaa28b55cc5194b61e4f41a2"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getSampleRate" ref="e406f7f0aaa28b55cc5194b61e4f41a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getSampleRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the sample rate we use for this stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample rate (in Hz) we use for this stream, or -1 if unknown or video. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#554e763894f9274d0fcb9a3f3d51c632">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00475">475</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">decodeAudio()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l01230">encodeAudio()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00476"></a>00476 {
<a name="l00477"></a>00477   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;sample_rate : -1);
<a name="l00478"></a>00478 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3be6a2991af4984bbff29986ba06fd15"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setSampleRate" ref="3be6a2991af4984bbff29986ba06fd15" args="(int32_t sampleRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setSampleRate           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sample rate to use when ENCODING. 
<p>
Ignored if DECODING or a non-audio stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>New sample rate (in Hz) to use. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#fd3688dc5215dbb7e1d9e68f1ce2ddb6">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00481">481</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00482"></a>00482 {
<a name="l00483"></a>00483   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened &amp;&amp; val &gt; 0)
<a name="l00484"></a>00484     mCodecContext-&gt;sample_rate = val;
<a name="l00485"></a>00485 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f191e14f7153360d1cffd337c5274d8d"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getChannels" ref="f191e14f7153360d1cffd337c5274d8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getChannels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of channels in this audio stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample rate (in Hz) we use for this stream, or 0 if unknown. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#9a7316327de43f4f6e8c991a386ee3e0">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00502">502</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01230">encodeAudio()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l00569">open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00503"></a>00503 {
<a name="l00504"></a>00504   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;channels : -1);
<a name="l00505"></a>00505 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f9e830b559daf6b97441eb78e7161ca0"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setChannels" ref="f9e830b559daf6b97441eb78e7161ca0" args="(int32_t channels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setChannels           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>channels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of channels to use when ENCODING. 
<p>
Ignored if a non audio stream, or if DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>The number of channels we'll encode with. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#eb351995ac5cac009e37535c31bfa32b">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00508">508</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00509"></a>00509 {
<a name="l00510"></a>00510   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened &amp;&amp; val &gt; 0)
<a name="l00511"></a>00511     mCodecContext-&gt;channels = val;
<a name="l00512"></a>00512 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="97e41cec0c1d23cdb701b5b57d969b35"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getSampleFormat" ref="97e41cec0c1d23cdb701b5b57d969b35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a> com::xuggle::xuggler::StreamCoder::getSampleFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the audio sample format. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample format of samples for encoding/decoding. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#87b8ea7de46bfc8606f2414235983f5c">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00488">488</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00489"></a>00489 {
<a name="l00490"></a>00490   <span class="keywordflow">return</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a>) (mCodecContext ? mCodecContext-&gt;sample_fmt
<a name="l00491"></a>00491       : -1);
<a name="l00492"></a>00492 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8d7694b0fcfaeaf2cd102aea3064be02"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setSampleFormat" ref="8d7694b0fcfaeaf2cd102aea3064be02" args="(IAudioSamples::Format aFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setSampleFormat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a>&nbsp;</td>
          <td class="paramname"> <em>aFormat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sample format when ENCODING. 
<p>
Ignored if DECODING or if the coder is already open.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aFormat</em>&nbsp;</td><td>The sample format. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#2264cb4521e09417588444d68ead4daa">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00495">495</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00496"></a>00496 {
<a name="l00497"></a>00497   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; !mOpened &amp;&amp; val &gt; 0)
<a name="l00498"></a>00498     mCodecContext-&gt;sample_fmt = (SampleFormat) val;
<a name="l00499"></a>00499 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0492afbd477f99707ebb0f2442b0aad9"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getGlobalQuality" ref="0492afbd477f99707ebb0f2442b0aad9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getGlobalQuality           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality setting this codec uses for video if a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> doesn't have a quality set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The global quality. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#85940f0d668670d37d624515ee52110a">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00515">515</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00516"></a>00516 {
<a name="l00517"></a>00517   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;global_quality : FF_LAMBDA_MAX);
<a name="l00518"></a>00518 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bae0a8f7611f878e77c0db6ec4cadecd"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setGlobalQuality" ref="bae0a8f7611f878e77c0db6ec4cadecd" args="(int32_t newQuality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setGlobalQuality           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newQuality</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality to a new value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newQuality</em>&nbsp;</td><td>The new global quality. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0cc039ca3dbf242e8f5bb8c1f785623d">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00521">521</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00522"></a>00522 {
<a name="l00523"></a>00523   <span class="keywordflow">if</span> (newQuality &lt; 0 || newQuality &gt; FF_LAMBDA_MAX)
<a name="l00524"></a>00524     newQuality = FF_LAMBDA_MAX;
<a name="l00525"></a>00525   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00526"></a>00526     mCodecContext-&gt;global_quality = newQuality;
<a name="l00527"></a>00527 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="be713a5c2457120817fe3156a6445bb1"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getFlags" ref="be713a5c2457120817fe3156a6445bb1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the flags associated with this codec. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The (compacted) value of all flags set. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#70815810fd45c4b35a2e8bb46ca55936">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00530">530</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00531"></a>00531 {
<a name="l00532"></a>00532   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;flags : 0);
<a name="l00533"></a>00533 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="810f00ec624a5fea2668df9414d79b38"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setFlags" ref="810f00ec624a5fea2668df9414d79b38" args="(int32_t newFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setFlags           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the FFMPEG flags to use with this codec. 
<p>
All values must be ORed (|) together.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879" title="XUGGLER Flags that can be passed to the setFlag(Flags, bool) method.">Flags</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFlags</em>&nbsp;</td><td>The new set flags for this codec. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#1b758ae82cb98f8a8168de4883e9dcd1">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00536">536</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00537"></a>00537 {
<a name="l00538"></a>00538   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00539"></a>00539     mCodecContext-&gt;flags = newFlags;
<a name="l00540"></a>00540 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="63e5caa7dd85559c9ea81cd1f3cd9e2f"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getFlag" ref="63e5caa7dd85559c9ea81cd1f3cd9e2f" args="(Flags flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::StreamCoder::getFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the setting for the specified flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag you want to find the setting for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for false; non-zero for true </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ba73e8620429bd95f4de9f3b09ea2807">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00543">543</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00544"></a>00544 {
<a name="l00545"></a>00545   <span class="keywordtype">bool</span> result = <span class="keyword">false</span>;
<a name="l00546"></a>00546   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00547"></a>00547     result = mCodecContext-&gt;flags &amp; flag;
<a name="l00548"></a>00548   <span class="keywordflow">return</span> result;
<a name="l00549"></a>00549 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c3999550315918737d0f5e1b4b765737"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setFlag" ref="c3999550315918737d0f5e1b4b765737" args="(Flags flag, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set it to (true or false) </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b484b81ddb23803694376582ebc63dcc">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00552">552</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00569">open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00553"></a>00553 {
<a name="l00554"></a>00554   <span class="keywordflow">if</span> (mCodecContext)
<a name="l00555"></a>00555   {
<a name="l00556"></a>00556     <span class="keywordflow">if</span> (value)
<a name="l00557"></a>00557     {
<a name="l00558"></a>00558       mCodecContext-&gt;flags |= flag;
<a name="l00559"></a>00559     }
<a name="l00560"></a>00560     <span class="keywordflow">else</span>
<a name="l00561"></a>00561     {
<a name="l00562"></a>00562       mCodecContext-&gt;flags &amp;= (~flag);
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564   }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7215694c124919baeaf61cb59d2611ef"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getAudioFrameSize" ref="7215694c124919baeaf61cb59d2611ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getAudioFrameSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For this stream, get the number of audio samples that are represented in a packet of information. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of samples per 'frame' of encoded audio </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0d55705562c299cb8c1eeff383b94128">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01616">1616</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00367">com::xuggle::xuggler::ICodec::CODEC_TYPE_AUDIO</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l01763">getDefaultAudioFrameSize()</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l01230">encodeAudio()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l00569">open()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01617"></a>01617 {
<a name="l01618"></a>01618   int32_t retval = 0;
<a name="l01619"></a>01619   <span class="keywordflow">if</span> (mCodec &amp;&amp; mCodec-&gt;getType() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>)
<a name="l01620"></a>01620   {
<a name="l01621"></a>01621     <span class="keywordflow">if</span> (mCodecContext-&gt;frame_size &lt;= 1)
<a name="l01622"></a>01622     {
<a name="l01623"></a>01623       <span class="comment">// Rats; some PCM encoders give a frame size of 1, which is too</span>
<a name="l01624"></a>01624       <span class="comment">//small.  We pick a more sensible value.</span>
<a name="l01625"></a>01625       retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#35c1957cd69edc56727d8cb124ff0c64" title="Get the default audio frame size (in samples).">getDefaultAudioFrameSize</a>();
<a name="l01626"></a>01626     }
<a name="l01627"></a>01627     <span class="keywordflow">else</span>
<a name="l01628"></a>01628     {
<a name="l01629"></a>01629       retval = mCodecContext-&gt;frame_size;
<a name="l01630"></a>01630     }
<a name="l01631"></a>01631   }
<a name="l01632"></a>01632   <span class="keywordflow">return</span> retval;
<a name="l01633"></a>01633 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f63b93f7ee8907256f45b1abf1f0dd5d"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::open" ref="f63b93f7ee8907256f45b1abf1f0dd5d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> associated with this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
You can get the codec through getCodec(...) and set it with setCodec(...). You cannot call any set* methods after you've called <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f63b93f7ee8907256f45b1abf1f0dd5d" title="Open the Codec associated with this StreamCoder.">open()</a> on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> until you <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#adadc04f0940c3afa23655ab67e86b73" title="Close a Codec that was opened on this StreamCoder.">close()</a> it.<p>
You must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#adadc04f0940c3afa23655ab67e86b73" title="Close a Codec that was opened on this StreamCoder.">close()</a> when you're done, but if you don't, the container will clean up after you (but yell at you) when it is closed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ecbfccf54f0b4aa1efd9c029891bb398">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00569">569</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00367">com::xuggle::xuggler::ICodec::CODEC_TYPE_AUDIO</a>, <a class="el" href="IStreamCoder_8h-source.html#l00052">com::xuggle::xuggler::IStreamCoder::ENCODING</a>, <a class="el" href="IAudioSamples_8cpp-source.html#l00038">com::xuggle::xuggler::IAudioSamples::findSampleBitDepth()</a>, <a class="el" href="IStreamCoder_8h-source.html#l00085">com::xuggle::xuggler::IStreamCoder::FLAG_GLOBAL_HEADER</a>, <a class="el" href="IContainerFormat_8h-source.html#l00113">com::xuggle::xuggler::IContainerFormat::FLAG_GLOBALHEADER</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01616">getAudioFrameSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00502">getChannels()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00232">getCodec()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00247">getCodecType()</a>, <a class="el" href="Stream_8cpp-source.html#l00264">com::xuggle::xuggler::Stream::getContainer()</a>, <a class="el" href="IBuffer_8cpp-source.html#l00048">com::xuggle::ferry::IBuffer::make()</a>, <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00552">setFlag()</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00570"></a>00570 {
<a name="l00571"></a>00571   int32_t retval = -1;
<a name="l00572"></a>00572   <span class="keywordflow">try</span>
<a name="l00573"></a>00573   {
<a name="l00574"></a>00574     <span class="keywordflow">if</span> (!mCodecContext)
<a name="l00575"></a>00575       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no codec context"</span>);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="keywordflow">if</span> (!mCodec)
<a name="l00578"></a>00578     {
<a name="l00579"></a>00579       RefPointer&lt;ICodec&gt; codec = this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc" title="The Codec this StreamCoder will use.">getCodec</a>();
<a name="l00580"></a>00580       <span class="comment">// This should set mCodec and then release</span>
<a name="l00581"></a>00581       <span class="comment">// the local reference.</span>
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">if</span> (!mCodec)
<a name="l00585"></a>00585       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no codec set for coder"</span>);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="comment">// don't allow us to open a coder without a time base</span>
<a name="l00588"></a>00588     <span class="keywordflow">if</span> (mDirection == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a> &amp;&amp; mCodecContext-&gt;time_base.num == 0)
<a name="l00589"></a>00589     {
<a name="l00590"></a>00590       <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>)
<a name="l00591"></a>00591       {
<a name="l00592"></a>00592         <span class="keywordflow">if</span> (mCodecContext-&gt;sample_rate &gt; 0)
<a name="l00593"></a>00593         {
<a name="l00594"></a>00594           mCodecContext-&gt;time_base.num = 1;
<a name="l00595"></a>00595           mCodecContext-&gt;time_base.den = mCodecContext-&gt;sample_rate;
<a name="l00596"></a>00596         }
<a name="l00597"></a>00597         <span class="keywordflow">else</span>
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599           <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no sample rate set on coder"</span>);
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601       }
<a name="l00602"></a>00602       <span class="keywordflow">else</span>
<a name="l00603"></a>00603         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"no timebase set on coder"</span>);
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="comment">// Fix for issue #14: http://code.google.com/p/xuggle/issues/detail?id=14</span>
<a name="l00607"></a>00607     <span class="keywordflow">if</span> (mStream)
<a name="l00608"></a>00608     {
<a name="l00609"></a>00609       RefPointer&lt;IContainer&gt; container = mStream-&gt;getContainer();
<a name="l00610"></a>00610       <span class="keywordflow">if</span> (container)
<a name="l00611"></a>00611       {
<a name="l00612"></a>00612         RefPointer&lt;IContainerFormat&gt; format = container-&gt;getContainerFormat();
<a name="l00613"></a>00613         <span class="keywordflow">if</span> (format &amp;&amp; mDirection == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a> &amp;&amp; format-&gt;getOutputFlag(
<a name="l00614"></a>00614             <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IContainerFormat.html#6319ffd5e863b1864389eaf6cf8f23ce02c4d4e501cb50ebc6efaf9aafeddae0">IContainerFormat::FLAG_GLOBALHEADER</a>))
<a name="l00615"></a>00615         {
<a name="l00616"></a>00616           this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#c3999550315918737d0f5e1b4b765737" title="Set the flag.">setFlag</a>(<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87983559921c3d9f8ad6f68483e27e50ae6">FLAG_GLOBAL_HEADER</a>, <span class="keyword">true</span>);
<a name="l00617"></a>00617         }
<a name="l00618"></a>00618       }
<a name="l00619"></a>00619     }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     retval = avcodec_open(mCodecContext, mCodec-&gt;getAVCodec());
<a name="l00622"></a>00622 
<a name="l00623"></a>00623     <span class="keywordflow">if</span> (retval &lt; 0)
<a name="l00624"></a>00624       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"could not open codec"</span>);
<a name="l00625"></a>00625     mOpened = <span class="keyword">true</span>;
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     mNumDroppedFrames = 0;
<a name="l00628"></a>00628     mSamplesCoded = mSamplesForEncoding = mLastExternallySetTimeStamp = 0;
<a name="l00629"></a>00629     mFakeCurrPts = mFakeNextPts = mLastPtsEncoded = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00630"></a>00630     <span class="keywordflow">for</span>(uint32_t i = 0; i &lt; <span class="keyword">sizeof</span>(mPtsBuffer)/<span class="keyword">sizeof</span>(mPtsBuffer[0]); i++)
<a name="l00631"></a>00631     {
<a name="l00632"></a>00632       mPtsBuffer[i] = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00633"></a>00633     }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635     <span class="comment">// Do any post open initialization here.</span>
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>)
<a name="l00637"></a>00637     {
<a name="l00638"></a>00638       int32_t frame_bytes = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#7215694c124919baeaf61cb59d2611ef" title="For this stream, get the number of audio samples that are represented in a packet...">getAudioFrameSize</a>() * <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>()
<a name="l00639"></a>00639           * <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#23b6a9d950557e6e4b6935243a520215" title="A convenience method that returns the # of bits in a given format.">IAudioSamples::findSampleBitDepth</a>(
<a name="l00640"></a>00640               (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a>) mCodecContext-&gt;sample_fmt) / 8;
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (frame_bytes &lt;= 0)
<a name="l00642"></a>00642         frame_bytes = AVCODEC_MAX_AUDIO_FRAME_SIZE;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644       <span class="keywordflow">if</span> (!mAudioFrameBuffer || mAudioFrameBuffer-&gt;getBufferSize()
<a name="l00645"></a>00645           &lt; frame_bytes)
<a name="l00646"></a>00646         <span class="comment">// Re-create it.</span>
<a name="l00647"></a>00647         mAudioFrameBuffer = <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#85bac77dd94f5cb30fecc0bb83a1d7fb" title="Allocate a new buffer by wrapping a native buffer.">IBuffer::make</a>(<span class="keyword">this</span>, frame_bytes);
<a name="l00648"></a>00648       mBytesInFrameBuffer = 0;
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651   <span class="keywordflow">catch</span> (std::bad_alloc &amp; e)
<a name="l00652"></a>00652   {
<a name="l00653"></a>00653     <span class="keywordflow">throw</span> e;
<a name="l00654"></a>00654   }
<a name="l00655"></a>00655   <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l00656"></a>00656   {
<a name="l00657"></a>00657     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00658"></a>00658     retval = -1;
<a name="l00659"></a>00659   }
<a name="l00660"></a>00660   <span class="keywordflow">return</span> retval;
<a name="l00661"></a>00661 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="adadc04f0940c3afa23655ab67e86b73"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::close" ref="adadc04f0940c3afa23655ab67e86b73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> that was opened on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00664">664</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00665"></a>00665 {
<a name="l00666"></a>00666   int32_t retval = -1;
<a name="l00667"></a>00667   <span class="keywordflow">if</span> (mCodecContext &amp;&amp; mOpened)
<a name="l00668"></a>00668   {
<a name="l00669"></a>00669     retval = avcodec_close(mCodecContext);
<a name="l00670"></a>00670     mOpened = <span class="keyword">false</span>;
<a name="l00671"></a>00671   }
<a name="l00672"></a>00672   mBytesInFrameBuffer = 0;
<a name="l00673"></a>00673   <span class="keywordflow">return</span> retval;
<a name="l00674"></a>00674 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5077165e8e719fedfce7810ce4016cd7"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::decodeAudio" ref="5077165e8e719fedfce7810ce4016cd7" args="(IAudioSamples *pOutSamples, IPacket *packet, int32_t byteOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::decodeAudio           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>byteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode this packet into pOutSamples. 
<p>
It will try to fill up the audio samples object, starting from the byteOffset inside this packet. <p>
The caller is responsible for allocating the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html" title="A set of raw (decoded) samples, plus a timestamp for when to play those samples relative...">IAudioSamples</a> object. This function will overwrite any data in the samples object.  <p>
Note that the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html" title="A set of raw (decoded) samples, plus a timestamp for when to play those samples relative...">IAudioSamples</a> object passed in must have a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#625af0c15015922f5af4b6308bb29bf9">IAudioSamples#getMaxBufferSize()</a> of at least 192kbytes. Sorry, but this requirement is imposed on us via FFmpeg. If the buffer is not large enough, this method will reallocate the underlying buffers to make them at least 192kbytes.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutSamples</em>&nbsp;</td><td>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1AudioSamples.html">AudioSamples</a> we decode to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet we're attempting to decode from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteOffset</em>&nbsp;</td><td>Where in the packet payload to start decoding</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes actually processed from the packet, or negative for error </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#97801fddf4414d619b712fdcbac8940d">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00677">677</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00367">com::xuggle::xuggler::ICodec::CODEC_TYPE_AUDIO</a>, <a class="el" href="IStreamCoder_8h-source.html#l00053">com::xuggle::xuggler::IStreamCoder::DECODING</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00088">com::xuggle::xuggler::AudioSamples::ensureCapacity()</a>, <a class="el" href="IAudioSamples_8cpp-source.html#l00038">com::xuggle::xuggler::IAudioSamples::findSampleBitDepth()</a>, <a class="el" href="Packet_8h-source.html#l00081">com::xuggle::xuggler::Packet::getAVPacket()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00502">getChannels()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00247">getCodecType()</a>, <a class="el" href="Packet_8cpp-source.html#l00171">com::xuggle::xuggler::Packet::getData()</a>, <a class="el" href="Packet_8cpp-source.html#l00073">com::xuggle::xuggler::Packet::getDts()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00224">com::xuggle::xuggler::AudioSamples::getMaxBufferSize()</a>, <a class="el" href="Packet_8cpp-source.html#l00061">com::xuggle::xuggler::Packet::getPts()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00107">com::xuggle::xuggler::AudioSamples::getRawSamples()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00475">getSampleRate()</a>, <a class="el" href="Packet_8cpp-source.html#l00085">com::xuggle::xuggler::Packet::getSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00379">getTimeBase()</a>, <a class="el" href="Stream_8cpp-source.html#l00132">com::xuggle::xuggler::Stream::getTimeBase()</a>, <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, <a class="el" href="IAudioSamples_8cpp-source.html#l00069">com::xuggle::xuggler::IAudioSamples::samplesToDefaultPts()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00263">com::xuggle::xuggler::AudioSamples::setComplete()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00679"></a>00679 {
<a name="l00680"></a>00680   int32_t retval = -1;
<a name="l00681"></a>00681   AudioSamples *samples = <span class="keyword">dynamic_cast&lt;</span>AudioSamples*<span class="keyword">&gt;</span> (pOutSamples);
<a name="l00682"></a>00682   Packet* packet = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span> (pPacket);
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="keywordflow">if</span> (samples)
<a name="l00685"></a>00685     <span class="comment">// reset the samples</span>
<a name="l00686"></a>00686     samples-&gt;setComplete(<span class="keyword">false</span>, 0, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>(),
<a name="l00687"></a>00687         (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a>) mCodecContext-&gt;sample_fmt, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>);
<a name="l00688"></a>00688   <span class="keywordflow">if</span> (!samples) {
<a name="l00689"></a>00689     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; no samples"</span>);
<a name="l00690"></a>00690     <span class="keywordflow">return</span> retval;
<a name="l00691"></a>00691   }
<a name="l00692"></a>00692   <span class="keywordflow">if</span> (!packet) {
<a name="l00693"></a>00693     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; no packet"</span>);
<a name="l00694"></a>00694     <span class="keywordflow">return</span> retval;
<a name="l00695"></a>00695   }
<a name="l00696"></a>00696   <span class="keywordflow">if</span> (!mOpened) {
<a name="l00697"></a>00697     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec not opened"</span>);
<a name="l00698"></a>00698     <span class="keywordflow">return</span> retval;
<a name="l00699"></a>00699   }
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (!mCodecContext) {
<a name="l00701"></a>00701     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; internal context not allocated"</span>);
<a name="l00702"></a>00702     <span class="keywordflow">return</span> retval;
<a name="l00703"></a>00703   }
<a name="l00704"></a>00704   <span class="keywordflow">if</span> (mDirection != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6">DECODING</a>) {
<a name="l00705"></a>00705     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; StreamCoder is set to encode, not decode"</span>);
<a name="l00706"></a>00706     <span class="keywordflow">return</span> retval;
<a name="l00707"></a>00707   }
<a name="l00708"></a>00708   <span class="keywordflow">if</span> (!mCodec || !mCodec-&gt;canDecode()) {
<a name="l00709"></a>00709     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec set cannot decode"</span>);
<a name="l00710"></a>00710     <span class="keywordflow">return</span> retval;
<a name="l00711"></a>00711   }
<a name="l00712"></a>00712   <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>) {
<a name="l00713"></a>00713     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec set is not an audio codec"</span>);
<a name="l00714"></a>00714     <span class="keywordflow">return</span> retval;
<a name="l00715"></a>00715   }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keywordtype">int</span> outBufSize = 0;
<a name="l00719"></a>00719   int32_t inBufSize = 0;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721   <span class="comment">// When decoding with FFMPEG, ffmpeg needs the sample buffer</span>
<a name="l00722"></a>00722   <span class="comment">// to be at least this long.</span>
<a name="l00723"></a>00723   samples-&gt;ensureCapacity(AVCODEC_MAX_AUDIO_FRAME_SIZE);
<a name="l00724"></a>00724   outBufSize = samples-&gt;getMaxBufferSize();
<a name="l00725"></a>00725   inBufSize = packet-&gt;getSize() - startingByte;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="keywordflow">if</span> (inBufSize &gt; 0 &amp;&amp; outBufSize &gt; 0)
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     RefPointer&lt;IBuffer&gt; buffer = packet-&gt;getData();
<a name="l00730"></a>00730     uint8_t * inBuf = 0;
<a name="l00731"></a>00731     int16_t * outBuf = 0;
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(buffer, <span class="stringliteral">"no buffer in packet!"</span>);
<a name="l00734"></a>00734     <span class="keywordflow">if</span> (buffer)
<a name="l00735"></a>00735       inBuf = (uint8_t*) buffer-&gt;getBytes(startingByte, inBufSize);
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     outBuf = samples-&gt;getRawSamples(0);
<a name="l00738"></a>00738 
<a name="l00739"></a>00739     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(inBuf, <span class="stringliteral">"no in buffer"</span>);
<a name="l00740"></a>00740     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(outBuf, <span class="stringliteral">"no out buffer"</span>);
<a name="l00741"></a>00741     <span class="keywordflow">if</span> (outBuf &amp;&amp; inBuf)
<a name="l00742"></a>00742     {
<a name="l00743"></a>00743       <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Attempting decodeAudio(%p, %p, %d, %p, %d);"</span>,
<a name="l00744"></a>00744           mCodecContext,
<a name="l00745"></a>00745           outBuf,
<a name="l00746"></a>00746           outBufSize,
<a name="l00747"></a>00747           inBuf,
<a name="l00748"></a>00748           inBufSize);
<a name="l00749"></a>00749       AVPacket pkt;
<a name="l00750"></a>00750       av_init_packet(&amp;pkt);
<a name="l00751"></a>00751       <span class="keywordflow">if</span> (packet &amp;&amp; packet-&gt;getAVPacket())
<a name="l00752"></a>00752         pkt = *packet-&gt;getAVPacket();
<a name="l00753"></a>00753       <span class="comment">// copy in our buffer</span>
<a name="l00754"></a>00754       pkt.data = inBuf;
<a name="l00755"></a>00755       pkt.size = inBufSize;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757       mCodecContext-&gt;reordered_opaque = packet-&gt;getPts();
<a name="l00758"></a>00758       retval
<a name="l00759"></a>00759       = avcodec_decode_audio3(mCodecContext, outBuf, &amp;outBufSize, &amp;pkt);
<a name="l00760"></a>00760       <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Finished %d decodeAudio(%p, %p, %d, %p, %d);"</span>,
<a name="l00761"></a>00761           retval,
<a name="l00762"></a>00762           mCodecContext,
<a name="l00763"></a>00763           outBuf,
<a name="l00764"></a>00764           outBufSize,
<a name="l00765"></a>00765           inBuf,
<a name="l00766"></a>00766           inBufSize);
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768     <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l00769"></a>00769     {
<a name="l00770"></a>00770       <span class="comment">// outBufSize is an In-Out parameter</span>
<a name="l00771"></a>00771       <span class="keywordflow">if</span> (outBufSize &lt; 0)
<a name="l00772"></a>00772         <span class="comment">// this can happen for some MPEG decoders</span>
<a name="l00773"></a>00773         outBufSize = 0;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a> format =
<a name="l00776"></a>00776           (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a>) mCodecContext-&gt;sample_fmt;
<a name="l00777"></a>00777       int32_t bytesPerSample = (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#23b6a9d950557e6e4b6935243a520215" title="A convenience method that returns the # of bits in a given format.">IAudioSamples::findSampleBitDepth</a>(format) / 8
<a name="l00778"></a>00778           * <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>());
<a name="l00779"></a>00779       int32_t numSamples = outBufSize / bytesPerSample;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781       <span class="comment">// The audio decoder doesn't set a PTS, so we need to manufacture one.</span>
<a name="l00782"></a>00782       RefPointer&lt;IRational&gt; timeBase =
<a name="l00783"></a>00783           this-&gt;mStream ? this-&gt;mStream-&gt;getTimeBase() : 0;
<a name="l00784"></a>00784       <span class="keywordflow">if</span> (!timeBase)
<a name="l00785"></a>00785         timeBase = this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase</a>();
<a name="l00786"></a>00786 
<a name="l00787"></a>00787       int64_t packetTs = packet-&gt;getPts();
<a name="l00788"></a>00788       <span class="keywordflow">if</span> (packetTs == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00789"></a>00789         packetTs = packet-&gt;getDts();
<a name="l00790"></a>00790 
<a name="l00791"></a>00791       <span class="keywordflow">if</span> (packetTs == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a> &amp;&amp; mFakeNextPts == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00792"></a>00792       {
<a name="l00793"></a>00793         <span class="comment">// the container doesn't have time stamps; assume we start</span>
<a name="l00794"></a>00794         <span class="comment">// at zero</span>
<a name="l00795"></a>00795         <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Setting fake pts to 0"</span>);
<a name="l00796"></a>00796         mFakeNextPts = 0;
<a name="l00797"></a>00797       }
<a name="l00798"></a>00798       <span class="keywordflow">if</span> (packetTs != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00799"></a>00799       {
<a name="l00800"></a>00800         <span class="comment">// The packet had a valid stream, and a valid time base</span>
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (timeBase-&gt;getNumerator() != 0 &amp;&amp; timeBase-&gt;getDenominator() != 0)
<a name="l00802"></a>00802         {
<a name="l00803"></a>00803           int64_t tsDelta = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00804"></a>00804           <span class="keywordflow">if</span> (mFakeNextPts != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00805"></a>00805           {
<a name="l00806"></a>00806             int64_t fakeTsInStreamTimeBase = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>;
<a name="l00807"></a>00807             <span class="comment">// rescale our fake into the time base of stream</span>
<a name="l00808"></a>00808             fakeTsInStreamTimeBase = timeBase-&gt;rescale(mFakeNextPts,
<a name="l00809"></a>00809                 mFakePtsTimeBase.value());
<a name="l00810"></a>00810             tsDelta = fakeTsInStreamTimeBase - packetTs;
<a name="l00811"></a>00811           }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813           <span class="comment">// now, compare it to our internal value;  if our internally calculated value</span>
<a name="l00814"></a>00814           <span class="comment">// is within 1 tick of the packet's time stamp (in the packet's time base),</span>
<a name="l00815"></a>00815           <span class="comment">// then we're probably right;</span>
<a name="l00816"></a>00816           <span class="comment">// otherwise, we should reset the stream's fake time stamp based on this</span>
<a name="l00817"></a>00817           <span class="comment">// packet</span>
<a name="l00818"></a>00818           <span class="keywordflow">if</span> (mFakeNextPts != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a> &amp;&amp; (tsDelta &gt;= -1 &amp;&amp; tsDelta
<a name="l00819"></a>00819               &lt;= 1))
<a name="l00820"></a>00820           {
<a name="l00821"></a>00821             <span class="comment">// we're the right value; keep our fake next pts</span>
<a name="l00822"></a>00822             <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Keeping mFakeNextPts: %lld"</span>, mFakeNextPts);
<a name="l00823"></a>00823           }
<a name="l00824"></a>00824           <span class="keywordflow">else</span>
<a name="l00825"></a>00825           {
<a name="l00826"></a>00826             <span class="comment">// rescale to our internal timebase</span>
<a name="l00827"></a>00827             int64_t packetTsInMicroseconds = mFakePtsTimeBase-&gt;rescale(
<a name="l00828"></a>00828                 packetTs, timeBase.value());
<a name="l00829"></a>00829             <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"%p Gap in audio (%lld); Resetting calculated ts from %lld to %lld"</span>,
<a name="l00830"></a>00830                 <span class="keyword">this</span>,
<a name="l00831"></a>00831                 tsDelta,
<a name="l00832"></a>00832                 mFakeNextPts,
<a name="l00833"></a>00833                 packetTsInMicroseconds);
<a name="l00834"></a>00834             mLastExternallySetTimeStamp = packetTsInMicroseconds;
<a name="l00835"></a>00835             mSamplesCoded = 0;
<a name="l00836"></a>00836             mFakeNextPts = mLastExternallySetTimeStamp;
<a name="l00837"></a>00837           }
<a name="l00838"></a>00838         }
<a name="l00839"></a>00839       }
<a name="l00840"></a>00840       <span class="comment">// Use the last value of the next pts</span>
<a name="l00841"></a>00841       mFakeCurrPts = mFakeNextPts;
<a name="l00842"></a>00842       <span class="comment">// adjust our next Pts pointer</span>
<a name="l00843"></a>00843       <span class="keywordflow">if</span> (numSamples &gt; 0)
<a name="l00844"></a>00844       {
<a name="l00845"></a>00845         mSamplesCoded += numSamples;
<a name="l00846"></a>00846         mFakeNextPts = mLastExternallySetTimeStamp
<a name="l00847"></a>00847             + <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(mSamplesCoded,
<a name="l00848"></a>00848                 <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l00849"></a>00849       }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851       <span class="comment">// copy the packet PTS</span>
<a name="l00852"></a>00852       samples-&gt;setComplete(numSamples &gt; 0, numSamples, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>(),
<a name="l00853"></a>00853           <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>(), format, mFakeCurrPts);
<a name="l00854"></a>00854     }
<a name="l00855"></a>00855   }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   <span class="keywordflow">return</span> retval;
<a name="l00858"></a>00858 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5febedd0e02c02da5cdb0d56de264835"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::decodeVideo" ref="5febedd0e02c02da5cdb0d56de264835" args="(IVideoPicture *pOutFrame, IPacket *packet, int32_t byteOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::decodeVideo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>byteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode this packet into pOutFrame. 
<p>
The caller is responsible for allocating the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html" title="Represents one raw (undecoded) picture in a video stream, plus a timestamp for when...">IVideoPicture</a> object. This function will potentially overwrite any data in the frame object, but you should pass the same <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html" title="Represents one raw (undecoded) picture in a video stream, plus a timestamp for when...">IVideoPicture</a> into this function repeatedly until <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html#e90b6fdbb542140bc25d2e976af24665" title="Is this picture completely decoded?">IVideoPicture::isComplete()</a> is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutFrame</em>&nbsp;</td><td>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1AudioSamples.html">AudioSamples</a> we decode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet we're attempting to decode from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteOffset</em>&nbsp;</td><td>Where in the packet payload to start decoding</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes actually processed from the packet, or negative for error </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#a8fc7f0842531be95981457761adb7b9">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00861">861</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="ICodec_8h-source.html#l00366">com::xuggle::xuggler::ICodec::CODEC_TYPE_VIDEO</a>, <a class="el" href="VideoPicture_8cpp-source.html#l00213">com::xuggle::xuggler::VideoPicture::copyAVFrame()</a>, <a class="el" href="IStreamCoder_8h-source.html#l00053">com::xuggle::xuggler::IStreamCoder::DECODING</a>, <a class="el" href="Packet_8h-source.html#l00081">com::xuggle::xuggler::Packet::getAVPacket()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00247">getCodecType()</a>, <a class="el" href="Packet_8cpp-source.html#l00171">com::xuggle::xuggler::Packet::getData()</a>, <a class="el" href="Packet_8cpp-source.html#l00073">com::xuggle::xuggler::Packet::getDts()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00353">getHeight()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00447">getPixelType()</a>, <a class="el" href="Packet_8cpp-source.html#l00061">com::xuggle::xuggler::Packet::getPts()</a>, <a class="el" href="Packet_8cpp-source.html#l00085">com::xuggle::xuggler::Packet::getSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00379">getTimeBase()</a>, <a class="el" href="Stream_8cpp-source.html#l00132">com::xuggle::xuggler::Stream::getTimeBase()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00366">getWidth()</a>, <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, <a class="el" href="IPixelFormat_8h-source.html#l00059">com::xuggle::xuggler::IPixelFormat::NONE</a>, <a class="el" href="VideoPicture_8cpp-source.html#l00326">com::xuggle::xuggler::VideoPicture::setComplete()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00863"></a>00863 {
<a name="l00864"></a>00864   int32_t retval = -1;
<a name="l00865"></a>00865   VideoPicture* frame = <span class="keyword">dynamic_cast&lt;</span>VideoPicture*<span class="keyword">&gt;</span> (pOutFrame);
<a name="l00866"></a>00866   Packet* packet = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span> (pPacket);
<a name="l00867"></a>00867   <span class="keywordflow">if</span> (frame)
<a name="l00868"></a>00868     <span class="comment">// reset the frame</span>
<a name="l00869"></a>00869     frame-&gt;setComplete(<span class="keyword">false</span>, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742914b9479e5b8850fe395b69648e00fb0">IPixelFormat::NONE</a>, -1, -1, mFakeCurrPts);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="keywordflow">if</span> (!frame) {
<a name="l00872"></a>00872     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; no frame"</span>);
<a name="l00873"></a>00873     <span class="keywordflow">return</span> retval;
<a name="l00874"></a>00874   }
<a name="l00875"></a>00875   <span class="keywordflow">if</span> (!packet) {
<a name="l00876"></a>00876     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; no packet"</span>);
<a name="l00877"></a>00877     <span class="keywordflow">return</span> retval;
<a name="l00878"></a>00878   }
<a name="l00879"></a>00879   <span class="keywordflow">if</span> (!mOpened) {
<a name="l00880"></a>00880     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec not opened"</span>);
<a name="l00881"></a>00881     <span class="keywordflow">return</span> retval;
<a name="l00882"></a>00882   }
<a name="l00883"></a>00883   <span class="keywordflow">if</span> (!mCodecContext) {
<a name="l00884"></a>00884     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; internal context not allocated"</span>);
<a name="l00885"></a>00885     <span class="keywordflow">return</span> retval;
<a name="l00886"></a>00886   }
<a name="l00887"></a>00887   <span class="keywordflow">if</span> (mDirection != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6">DECODING</a>) {
<a name="l00888"></a>00888     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; StreamCoder is set to encode, not decode"</span>);
<a name="l00889"></a>00889     <span class="keywordflow">return</span> retval;
<a name="l00890"></a>00890   }
<a name="l00891"></a>00891   <span class="keywordflow">if</span> (!mCodec || !mCodec-&gt;canDecode()) {
<a name="l00892"></a>00892     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec set cannot decode"</span>);
<a name="l00893"></a>00893     <span class="keywordflow">return</span> retval;
<a name="l00894"></a>00894   }
<a name="l00895"></a>00895   <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd448fc7fdfd7648393fec9774f4f0a10e9">ICodec::CODEC_TYPE_VIDEO</a>) {
<a name="l00896"></a>00896     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to decode when not ready; codec set is not a video codec"</span>);
<a name="l00897"></a>00897     <span class="keywordflow">return</span> retval;
<a name="l00898"></a>00898   }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   AVFrame *avFrame = avcodec_alloc_frame();
<a name="l00901"></a>00901   <span class="keywordflow">if</span> (avFrame)
<a name="l00902"></a>00902   {
<a name="l00903"></a>00903     RefPointer&lt;IBuffer&gt; buffer = packet-&gt;getData();
<a name="l00904"></a>00904     <span class="keywordtype">int</span> frameFinished = 0;
<a name="l00905"></a>00905     int32_t inBufSize = 0;
<a name="l00906"></a>00906     uint8_t * inBuf = 0;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     inBufSize = packet-&gt;getSize() - byteOffset;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(buffer, <span class="stringliteral">"no buffer in packet?"</span>);
<a name="l00911"></a>00911     <span class="keywordflow">if</span> (buffer)
<a name="l00912"></a>00912       inBuf = (uint8_t*) buffer-&gt;getBytes(byteOffset, inBufSize);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(inBuf, <span class="stringliteral">"incorrect size or no data in packet"</span>);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="keywordflow">if</span> (inBufSize &gt; 0 &amp;&amp; inBuf)
<a name="l00917"></a>00917     {
<a name="l00918"></a>00918       <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Attempting decodeVideo(%p, %p, %d, %p, %d);"</span>,
<a name="l00919"></a>00919           mCodecContext,
<a name="l00920"></a>00920           avFrame,
<a name="l00921"></a>00921           frameFinished,
<a name="l00922"></a>00922           inBuf,
<a name="l00923"></a>00923           inBufSize);
<a name="l00924"></a>00924       AVPacket pkt;
<a name="l00925"></a>00925       av_init_packet(&amp;pkt);
<a name="l00926"></a>00926       <span class="keywordflow">if</span> (packet &amp;&amp; packet-&gt;getAVPacket())
<a name="l00927"></a>00927         pkt = *packet-&gt;getAVPacket();
<a name="l00928"></a>00928       <span class="comment">// copy in our buffer</span>
<a name="l00929"></a>00929       pkt.data = inBuf;
<a name="l00930"></a>00930       pkt.size = inBufSize;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932       mCodecContext-&gt;reordered_opaque = packet-&gt;getPts();
<a name="l00933"></a>00933       retval = avcodec_decode_video2(mCodecContext, avFrame, &amp;frameFinished,
<a name="l00934"></a>00934           &amp;pkt);
<a name="l00935"></a>00935       <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Finished %d decodeVideo(%p, %p, %d, %p, %d);"</span>,
<a name="l00936"></a>00936           retval,
<a name="l00937"></a>00937           mCodecContext,
<a name="l00938"></a>00938           avFrame,
<a name="l00939"></a>00939           frameFinished,
<a name="l00940"></a>00940           inBuf,
<a name="l00941"></a>00941           inBufSize);
<a name="l00942"></a>00942       <span class="keywordflow">if</span> (frameFinished)
<a name="l00943"></a>00943       {
<a name="l00944"></a>00944         <span class="comment">// copy FFMPEG's buffer into our buffer; don't try to get efficient</span>
<a name="l00945"></a>00945         <span class="comment">// and reuse the buffer FFMPEG is using; in order to allow our</span>
<a name="l00946"></a>00946         <span class="comment">// buffers to be thread safe, we must do a copy here.</span>
<a name="l00947"></a>00947         frame-&gt;copyAVFrame(avFrame, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168" title="For Video streams, get the Pixel Format in use by the stream.">getPixelType</a>(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4" title="The width, in pixels.">getWidth</a>(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469" title="The height, in pixels.">getHeight</a>());
<a name="l00948"></a>00948         RefPointer&lt;IRational&gt; timeBase = 0;
<a name="l00949"></a>00949         timeBase = this-&gt;mStream ? this-&gt;mStream-&gt;getTimeBase() : 0;
<a name="l00950"></a>00950         <span class="keywordflow">if</span> (!timeBase)
<a name="l00951"></a>00951           timeBase = this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase</a>();
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         int64_t packetTs = avFrame-&gt;reordered_opaque;
<a name="l00954"></a>00954         <span class="comment">// if none, assume this packet's decode time, since</span>
<a name="l00955"></a>00955         <span class="comment">// it's presentation time should have been in reordered_opaque</span>
<a name="l00956"></a>00956         <span class="keywordflow">if</span> (packetTs == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00957"></a>00957           packetTs = packet-&gt;getDts();
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (packetTs != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00960"></a>00960         {
<a name="l00961"></a>00961           <span class="keywordflow">if</span> (timeBase-&gt;getNumerator() != 0)
<a name="l00962"></a>00962           {
<a name="l00963"></a>00963             <span class="comment">// The decoder set a PTS, so we let it override us</span>
<a name="l00964"></a>00964             int64_t nextPts = mFakePtsTimeBase-&gt;rescale(packetTs,
<a name="l00965"></a>00965                 timeBase.value());
<a name="l00966"></a>00966             <span class="comment">// some youtube videos incorrectly return a packet</span>
<a name="l00967"></a>00967             <span class="comment">// with the wrong re-ordered opaque setting.  this</span>
<a name="l00968"></a>00968             <span class="comment">// detects that and uses the PTS from the packet instead.</span>
<a name="l00969"></a>00969             <span class="comment">// See: http://code.google.com/p/xuggle/issues/detail?id=165</span>
<a name="l00970"></a>00970             <span class="comment">// in this way we enforce that timestamps are always</span>
<a name="l00971"></a>00971             <span class="comment">// increasing</span>
<a name="l00972"></a>00972             <span class="keywordflow">if</span> (nextPts &lt; mFakeNextPts &amp;&amp; packet-&gt;getPts() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l00973"></a>00973               nextPts = mFakePtsTimeBase-&gt;rescale(packet-&gt;getPts(),
<a name="l00974"></a>00974                   timeBase.value());
<a name="l00975"></a>00975             mFakeNextPts = nextPts;
<a name="l00976"></a>00976           }
<a name="l00977"></a>00977         }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         <span class="comment">// Use the last value of the next pts</span>
<a name="l00980"></a>00980         mFakeCurrPts = mFakeNextPts;
<a name="l00981"></a>00981         <span class="keywordtype">double</span> frameDelay = av_rescale(timeBase-&gt;getNumerator(),
<a name="l00982"></a>00982             AV_TIME_BASE, timeBase-&gt;getDenominator());
<a name="l00983"></a>00983         frameDelay += avFrame-&gt;repeat_pict * (frameDelay * 0.5);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         <span class="comment">// adjust our next Pts pointer</span>
<a name="l00986"></a>00986         mFakeNextPts += (int64_t) frameDelay;
<a name="l00987"></a>00987         <span class="comment">//          VS_LOG_DEBUG("frame complete: %s; pts: %lld; packet ts: %lld; opaque ts: %lld; tb: %ld/%ld",</span>
<a name="l00988"></a>00988         <span class="comment">//              (frameFinished ? "yes" : "no"),</span>
<a name="l00989"></a>00989         <span class="comment">//              mFakeCurrPts,</span>
<a name="l00990"></a>00990         <span class="comment">//              (packet ? packet-&gt;getDts() : 0),</span>
<a name="l00991"></a>00991         <span class="comment">//              packetTs,</span>
<a name="l00992"></a>00992         <span class="comment">//              timeBase-&gt;getNumerator(),</span>
<a name="l00993"></a>00993         <span class="comment">//              timeBase-&gt;getDenominator()</span>
<a name="l00994"></a>00994         <span class="comment">//          );</span>
<a name="l00995"></a>00995       }
<a name="l00996"></a>00996       frame-&gt;setComplete(frameFinished, this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168" title="For Video streams, get the Pixel Format in use by the stream.">getPixelType</a>(),
<a name="l00997"></a>00997           this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4" title="The width, in pixels.">getWidth</a>(), this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469" title="The height, in pixels.">getHeight</a>(), mFakeCurrPts);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000     av_free(avFrame);
<a name="l01001"></a>01001   }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003   <span class="keywordflow">return</span> retval;
<a name="l01004"></a>01004 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4e8e90c3ba84aab18d7e17379c59c865"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::encodeVideo" ref="4e8e90c3ba84aab18d7e17379c59c865" args="(IPacket *pOutPacket, IVideoPicture *pFrame, int32_t suggestedBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::encodeVideo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>suggestedBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode the given frame using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> will allocate a buffer to use internally for this, and will free it when the frame destroys itself.<p>
Also, when done in order to flush the encoder, caller should call this method passing in 0 (null) for pFrame to tell the encoder to flush any data it was keeping a hold of.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutPacket</em>&nbsp;</td><td>[out] The packet to encode into. It will point to a buffer allocated in the frame. Caller should check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8a905262cb3774db3f36f48749f7e56b" title="Is this packet complete.">IPacket::isComplete()</a> after call to find out if we had enough information to encode a full packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFrame</em>&nbsp;</td><td>[in/out] The frame to encode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suggestedBufferSize</em>&nbsp;</td><td>The suggested buffer size to allocate or -1 for choose ourselves. If -1 we'll allocate a buffer exactly the same size (+1) as the decoded frame with the guess that you're encoding a frame because you want to use LESS space than that.</td></tr>
  </table>
</dl>
@ return &gt;= 0 on success; &lt;0 on error. 
<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d39b98a68e86cbe889b98a053bfc9230">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01007">1007</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00307">com::xuggle::xuggler::Packet::allocateNewPayload()</a>, <a class="el" href="ICodec_8h-source.html#l00366">com::xuggle::xuggler::ICodec::CODEC_TYPE_VIDEO</a>, <a class="el" href="IStreamCoder_8h-source.html#l00052">com::xuggle::xuggler::IStreamCoder::ENCODING</a>, <a class="el" href="VideoPicture_8cpp-source.html#l00200">com::xuggle::xuggler::VideoPicture::fillAVFrame()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00247">getCodecType()</a>, <a class="el" href="Packet_8cpp-source.html#l00171">com::xuggle::xuggler::Packet::getData()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00353">getHeight()</a>, <a class="el" href="VideoPicture_8h-source.html#l00049">com::xuggle::xuggler::VideoPicture::getHeight()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00447">getPixelType()</a>, <a class="el" href="VideoPicture_8h-source.html#l00050">com::xuggle::xuggler::VideoPicture::getPixelType()</a>, <a class="el" href="VideoPicture_8cpp-source.html#l00298">com::xuggle::xuggler::VideoPicture::getPts()</a>, <a class="el" href="VideoPicture_8cpp-source.html#l00363">com::xuggle::xuggler::VideoPicture::getSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00379">getTimeBase()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00366">getWidth()</a>, <a class="el" href="VideoPicture_8h-source.html#l00048">com::xuggle::xuggler::VideoPicture::getWidth()</a>, <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, <a class="el" href="Packet_8cpp-source.html#l00209">com::xuggle::xuggler::Packet::reset()</a>, <a class="el" href="IRational_8h-source.html#l00236">com::xuggle::xuggler::IRational::ROUND_DOWN</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01009"></a>01009 {
<a name="l01010"></a>01010   int32_t retval = -1;
<a name="l01011"></a>01011   VideoPicture *frame = <span class="keyword">dynamic_cast&lt;</span>VideoPicture*<span class="keyword">&gt;</span> (pFrame);
<a name="l01012"></a>01012   Packet *packet = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span> (pOutPacket);
<a name="l01013"></a>01013   RefPointer&lt;IBuffer&gt; encodingBuffer;
<a name="l01014"></a>01014 
<a name="l01015"></a>01015   <span class="keywordflow">try</span>
<a name="l01016"></a>01016   {
<a name="l01017"></a>01017     <span class="keywordflow">if</span> (packet)
<a name="l01018"></a>01018       packet-&gt;reset();
<a name="l01019"></a>01019 
<a name="l01020"></a>01020     <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd448fc7fdfd7648393fec9774f4f0a10e9">ICodec::CODEC_TYPE_VIDEO</a>)
<a name="l01021"></a>01021       <span class="keywordflow">throw</span> std::runtime_error(
<a name="l01022"></a>01022           <span class="stringliteral">"Attempting to encode video with non video coder"</span>);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="keywordflow">if</span> (frame &amp;&amp; frame-&gt;getPixelType() != this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168" title="For Video streams, get the Pixel Format in use by the stream.">getPixelType</a>())
<a name="l01025"></a>01025       <span class="keywordflow">throw</span> std::runtime_error(
<a name="l01026"></a>01026           <span class="stringliteral">"picture is not of the same PixelType as this Coder expected"</span>);
<a name="l01027"></a>01027     <span class="keywordflow">if</span> (frame &amp;&amp; frame-&gt;getWidth() != this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4" title="The width, in pixels.">getWidth</a>())
<a name="l01028"></a>01028       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"picture is not of the same width as this Coder"</span>);
<a name="l01029"></a>01029     <span class="keywordflow">if</span> (frame &amp;&amp; frame-&gt;getHeight() != this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469" title="The height, in pixels.">getHeight</a>())
<a name="l01030"></a>01030       <span class="keywordflow">throw</span> std::runtime_error(
<a name="l01031"></a>01031           <span class="stringliteral">"picture is not of the same height as this Coder"</span>);
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordflow">if</span> (mDirection != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a>)
<a name="l01034"></a>01034       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Decoding StreamCoder not valid for encoding"</span>);
<a name="l01035"></a>01035     <span class="keywordflow">if</span> (!mCodec)
<a name="l01036"></a>01036       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Codec not set"</span>);
<a name="l01037"></a>01037     <span class="keywordflow">if</span> (!mCodec-&gt;canEncode())
<a name="l01038"></a>01038       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Codec cannot be used to encode"</span>);
<a name="l01039"></a>01039     <span class="keywordflow">if</span> (mCodecContext &amp;&amp; mOpened &amp;&amp; mDirection == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a> &amp;&amp; packet)
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041       uint8_t* buf = 0;
<a name="l01042"></a>01042       uint32_t bufLen = 0;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044       <span class="comment">// First, get the right buffer size.</span>
<a name="l01045"></a>01045       <span class="keywordflow">if</span> (suggestedBufferSize &lt;= 0)
<a name="l01046"></a>01046       {
<a name="l01047"></a>01047         <span class="keywordflow">if</span> (frame)
<a name="l01048"></a>01048         {
<a name="l01049"></a>01049           suggestedBufferSize = frame-&gt;getSize();
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051         <span class="keywordflow">else</span>
<a name="l01052"></a>01052         {
<a name="l01053"></a>01053           suggestedBufferSize = avpicture_get_size(
<a name="l01054"></a>01054               (PixelFormat) <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168" title="For Video streams, get the Pixel Format in use by the stream.">getPixelType</a>(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4" title="The width, in pixels.">getWidth</a>(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469" title="The height, in pixels.">getHeight</a>());
<a name="l01055"></a>01055         }
<a name="l01056"></a>01056       }
<a name="l01057"></a>01057       <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(suggestedBufferSize&gt; 0, <span class="stringliteral">"no buffer size in input frame"</span>);
<a name="l01058"></a>01058       suggestedBufferSize = FFMAX(suggestedBufferSize, FF_MIN_BUFFER_SIZE);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060       retval = packet-&gt;allocateNewPayload(suggestedBufferSize);
<a name="l01061"></a>01061       <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l01062"></a>01062       {
<a name="l01063"></a>01063         encodingBuffer = packet-&gt;getData();
<a name="l01064"></a>01064       }
<a name="l01065"></a>01065       <span class="keywordflow">if</span> (encodingBuffer)
<a name="l01066"></a>01066       {
<a name="l01067"></a>01067         buf = (uint8_t*) encodingBuffer-&gt;getBytes(0, suggestedBufferSize);
<a name="l01068"></a>01068         bufLen = encodingBuffer-&gt;getBufferSize();
<a name="l01069"></a>01069       }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071       <span class="keywordflow">if</span> (buf &amp;&amp; bufLen)
<a name="l01072"></a>01072       {
<a name="l01073"></a>01073         <span class="comment">// Change the PTS in our frame to the timebase of the encoded stream</span>
<a name="l01074"></a>01074         RefPointer&lt;IRational&gt; thisTimeBase = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase</a>();
<a name="l01075"></a>01075 
<a name="l01076"></a>01076         <span class="comment">/*</span>
<a name="l01077"></a>01077 <span class="comment">         * We make a copy of the AVFrame object and explicitly copy</span>
<a name="l01078"></a>01078 <span class="comment">         * over the values that we know encoding cares about.</span>
<a name="l01079"></a>01079 <span class="comment">         *</span>
<a name="l01080"></a>01080 <span class="comment">         * This is because often some programs decode into an VideoPicture</span>
<a name="l01081"></a>01081 <span class="comment">         * and just want to pass that to encodeVideo.  If we just</span>
<a name="l01082"></a>01082 <span class="comment">         * leave the values that Ffmpeg had in the AVFrame during</span>
<a name="l01083"></a>01083 <span class="comment">         * decoding, strange errors can result.</span>
<a name="l01084"></a>01084 <span class="comment">         *</span>
<a name="l01085"></a>01085 <span class="comment">         * Plus, this forces us to KNOW what we're passing into the encoder.</span>
<a name="l01086"></a>01086 <span class="comment">         */</span>
<a name="l01087"></a>01087         AVFrame* avFrame = 0;
<a name="l01088"></a>01088         <span class="keywordtype">bool</span> dropFrame = <span class="keyword">false</span>;
<a name="l01089"></a>01089         <span class="keywordflow">if</span> (frame)
<a name="l01090"></a>01090         {
<a name="l01091"></a>01091           avFrame = avcodec_alloc_frame();
<a name="l01092"></a>01092           <span class="keywordflow">if</span> (!avFrame)
<a name="l01093"></a>01093             <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l01094"></a>01094           frame-&gt;fillAVFrame(avFrame);
<a name="l01095"></a>01095 
<a name="l01096"></a>01096           <span class="comment">// convert into the time base that this coder wants</span>
<a name="l01097"></a>01097           <span class="comment">// to output in</span>
<a name="l01098"></a>01098           int64_t codecTimeBasePts = thisTimeBase-&gt;rescale(frame-&gt;getPts(),
<a name="l01099"></a>01099               mFakePtsTimeBase.value(), <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html#56784568d82045a0b4e38501c548dd54417fe90728667072423565138557c95b">IRational::ROUND_DOWN</a>);
<a name="l01100"></a>01100           <span class="keywordflow">if</span> (mLastPtsEncoded != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l01101"></a>01101           {
<a name="l01102"></a>01102             <span class="comment">// adjust for rounding;</span>
<a name="l01103"></a>01103             <span class="comment">// fixes http://code.google.com/p/xuggle/issues/detail?id=180</span>
<a name="l01104"></a>01104             <span class="keywordflow">if</span> (codecTimeBasePts &lt; mLastPtsEncoded)
<a name="l01105"></a>01105             {
<a name="l01106"></a>01106               <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(
<a name="l01107"></a>01107                   <span class="stringliteral">"Dropping frame with timestamp %lld (if coder supports higher time-base use that instead)"</span>,
<a name="l01108"></a>01108                   frame-&gt;getPts());
<a name="l01109"></a>01109               dropFrame = <span class="keyword">true</span>;
<a name="l01110"></a>01110             }
<a name="l01111"></a>01111             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codecTimeBasePts == mLastPtsEncoded)
<a name="l01112"></a>01112             {
<a name="l01113"></a>01113               <span class="comment">// else we're close enough; increment by 1</span>
<a name="l01114"></a>01114               ++codecTimeBasePts;
<a name="l01115"></a>01115             }
<a name="l01116"></a>01116           }
<a name="l01117"></a>01117           <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Rescaling ts: %lld to %lld (last: %lld) (from base %d/%d to %d/%d)"</span>,
<a name="l01118"></a>01118               frame-&gt;getPts(),
<a name="l01119"></a>01119               codecTimeBasePts,
<a name="l01120"></a>01120               mLastPtsEncoded,
<a name="l01121"></a>01121               mFakePtsTimeBase-&gt;getNumerator(),
<a name="l01122"></a>01122               mFakePtsTimeBase-&gt;getDenominator(),
<a name="l01123"></a>01123               thisTimeBase-&gt;getNumerator(),
<a name="l01124"></a>01124               thisTimeBase-&gt;getDenominator());
<a name="l01125"></a>01125           avFrame-&gt;pts = codecTimeBasePts;
<a name="l01126"></a>01126           <span class="keywordflow">if</span> (!dropFrame)
<a name="l01127"></a>01127             mLastPtsEncoded = avFrame-&gt;pts;
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         <span class="keywordflow">if</span> (!dropFrame)
<a name="l01131"></a>01131         {
<a name="l01132"></a>01132           <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Attempting encodeVideo(%p, %p, %d, %p)"</span>,
<a name="l01133"></a>01133               mCodecContext,
<a name="l01134"></a>01134               buf,
<a name="l01135"></a>01135               bufLen,
<a name="l01136"></a>01136               avFrame);
<a name="l01137"></a>01137           retval = avcodec_encode_video(mCodecContext, buf, bufLen, avFrame);
<a name="l01138"></a>01138           <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Finished %d encodeVideo(%p, %p, %d, %p)"</span>,
<a name="l01139"></a>01139               retval,
<a name="l01140"></a>01140               mCodecContext,
<a name="l01141"></a>01141               buf,
<a name="l01142"></a>01142               bufLen,
<a name="l01143"></a>01143               avFrame);
<a name="l01144"></a>01144         }
<a name="l01145"></a>01145         <span class="keywordflow">else</span>
<a name="l01146"></a>01146         {
<a name="l01147"></a>01147           ++mNumDroppedFrames;
<a name="l01148"></a>01148           retval = 0;
<a name="l01149"></a>01149         }
<a name="l01150"></a>01150         <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l01151"></a>01151         {
<a name="l01152"></a>01152           int64_t dts = (avFrame ? mLastPtsEncoded : mLastPtsEncoded + 1);
<a name="l01153"></a>01153           int64_t duration = 1;
<a name="l01154"></a>01154           <span class="keywordflow">if</span> (retval &gt; 0) {
<a name="l01155"></a>01155             int32_t num = thisTimeBase-&gt;getNumerator();
<a name="l01156"></a>01156             int32_t den = thisTimeBase-&gt;getDenominator();
<a name="l01157"></a>01157             <span class="keywordflow">if</span> (num*1000LL &gt; den)
<a name="l01158"></a>01158             {
<a name="l01159"></a>01159               <span class="keywordflow">if</span> (mCodecContext-&gt;coded_frame
<a name="l01160"></a>01160                   &amp;&amp; mCodecContext-&gt;coded_frame-&gt;repeat_pict)
<a name="l01161"></a>01161               {
<a name="l01162"></a>01162                 num = num * (1+mCodecContext-&gt;coded_frame-&gt;repeat_pict);
<a name="l01163"></a>01163               }
<a name="l01164"></a>01164             }
<a name="l01165"></a>01165             duration = av_rescale(1,
<a name="l01166"></a>01166                 num * (int64_t)den * mCodecContext-&gt;ticks_per_frame,
<a name="l01167"></a>01167                 den * (int64_t) thisTimeBase-&gt;getNumerator());
<a name="l01168"></a>01168 
<a name="l01169"></a>01169             <span class="comment">// This will be zero if the Codec does not use b-frames;</span>
<a name="l01170"></a>01170             <span class="comment">// although we provide space for delaying up to the</span>
<a name="l01171"></a>01171             <span class="comment">// max H264 delay, in reality we only need delay by 1 tick.</span>
<a name="l01172"></a>01172             int32_t delay = FFMAX(mCodecContext-&gt;has_b_frames,
<a name="l01173"></a>01173                 !!mCodecContext-&gt;max_b_frames);
<a name="l01174"></a>01174             <span class="keywordflow">if</span> (mCodecContext-&gt;coded_frame
<a name="l01175"></a>01175                 &amp;&amp; mCodecContext-&gt;coded_frame-&gt;pts != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l01176"></a>01176             {
<a name="l01177"></a>01177               int64_t pts = mCodecContext-&gt;coded_frame-&gt;pts;
<a name="l01178"></a>01178               mPtsBuffer[0] = pts;
<a name="l01179"></a>01179               int32_t i;
<a name="l01180"></a>01180               <span class="comment">// If first time through set others to some 'sensible' defaults.</span>
<a name="l01181"></a>01181               <span class="comment">// If the first PTS is zero, this leads to starting negative</span>
<a name="l01182"></a>01182               <span class="comment">// dts values, but FFmpeg allows that so we do too.</span>
<a name="l01183"></a>01183               <span class="keywordflow">for</span>(i = 1; i &lt; delay + 1 &amp;&amp; mPtsBuffer[i] == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>; i++)
<a name="l01184"></a>01184                 mPtsBuffer[i] = pts + (i-delay-1)*duration;
<a name="l01185"></a>01185               <span class="comment">// Order the PTS values in increasing order and the lowest</span>
<a name="l01186"></a>01186               <span class="comment">// one will magically be the DTS we should use for this packet.</span>
<a name="l01187"></a>01187               <span class="keywordflow">for</span>(i = 0; i &lt; delay &amp;&amp; mPtsBuffer[i] &gt; mPtsBuffer[i+1]; i++)
<a name="l01188"></a>01188                 FFSWAP(int64_t, mPtsBuffer[i], mPtsBuffer[i+1]);
<a name="l01189"></a>01189               dts = mPtsBuffer[0];
<a name="l01190"></a>01190 <span class="comment">//              VS_LOG_ERROR("type: %d; output: dts: %lld; pts: %lld",</span>
<a name="l01191"></a>01191 <span class="comment">//                  mCodecContext-&gt;coded_frame-&gt;pict_type,</span>
<a name="l01192"></a>01192 <span class="comment">//                  dts,</span>
<a name="l01193"></a>01193 <span class="comment">//                  pts);</span>
<a name="l01194"></a>01194             }
<a name="l01195"></a>01195           }
<a name="l01196"></a>01196           setPacketParameters(
<a name="l01197"></a>01197               packet,
<a name="l01198"></a>01198               retval,
<a name="l01199"></a>01199               <span class="comment">// if the last packet, increment the pts encoded</span>
<a name="l01200"></a>01200               <span class="comment">// by one</span>
<a name="l01201"></a>01201               dts,
<a name="l01202"></a>01202               thisTimeBase.value(),
<a name="l01203"></a>01203               (mCodecContext-&gt;coded_frame ? mCodecContext-&gt;coded_frame-&gt;key_frame
<a name="l01204"></a>01204                   : 0), duration);
<a name="l01205"></a>01205         }
<a name="l01206"></a>01206         <span class="keywordflow">if</span> (avFrame)
<a name="l01207"></a>01207           av_free(avFrame);
<a name="l01208"></a>01208       }
<a name="l01209"></a>01209     }
<a name="l01210"></a>01210     <span class="keywordflow">else</span>
<a name="l01211"></a>01211     {
<a name="l01212"></a>01212       <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Attempting to encode when not ready"</span>);
<a name="l01213"></a>01213     }
<a name="l01214"></a>01214   }
<a name="l01215"></a>01215   <span class="keywordflow">catch</span> (std::bad_alloc &amp; e)
<a name="l01216"></a>01216   {
<a name="l01217"></a>01217     retval = -1;
<a name="l01218"></a>01218     <span class="keywordflow">throw</span> e;
<a name="l01219"></a>01219   }
<a name="l01220"></a>01220   <span class="keywordflow">catch</span> (std::exception &amp; e)
<a name="l01221"></a>01221   {
<a name="l01222"></a>01222     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Got error: %s"</span>, e.what());
<a name="l01223"></a>01223     retval = -1;
<a name="l01224"></a>01224   }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226   <span class="keywordflow">return</span> retval;
<a name="l01227"></a>01227 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="81102eae7e5d013057c3a38f9e636cbc"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::encodeAudio" ref="81102eae7e5d013057c3a38f9e636cbc" args="(IPacket *pOutPacket, IAudioSamples *pSamples, uint32_t sampleToStartFrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::encodeAudio           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *&nbsp;</td>
          <td class="paramname"> <em>pSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>sampleToStartFrom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode the given samples using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> will allocate a buffer to use internally for this, and will free it when the frame destroys itself.<p>
Callers should call this repeatedly on a set of samples until we consume all the samples.<p>
Also, when done in order to flush the encoder, caller should call this method passing in 0 (null) for pSamples to tell the encoder to flush any data it was keeping a hold of.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutPacket</em>&nbsp;</td><td>[out] The packet to encode into. It will point to a buffer allocated in the frame. Caller should check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8a905262cb3774db3f36f48749f7e56b" title="Is this packet complete.">IPacket::isComplete()</a> after call to find out if we had enough information to encode a full packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pSamples</em>&nbsp;</td><td>[in] The samples to consume </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampleToStartFrom</em>&nbsp;</td><td>[in] Which sample you want to start with This is usually zero, but if you're using a codec that packetizes output with small number of samples, you may need to call encodeAudio repeatedly with different starting samples to consume all of your samples.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of samples we consumed when encoding, or negative for errors. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c47164283b3bfa882e32592ace086206">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01230">1230</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00307">com::xuggle::xuggler::Packet::allocateNewPayload()</a>, <a class="el" href="ICodec_8h-source.html#l00367">com::xuggle::xuggler::ICodec::CODEC_TYPE_AUDIO</a>, <a class="el" href="IStreamCoder_8h-source.html#l00052">com::xuggle::xuggler::IStreamCoder::ENCODING</a>, <a class="el" href="IAudioSamples_8cpp-source.html#l00038">com::xuggle::xuggler::IAudioSamples::findSampleBitDepth()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01616">getAudioFrameSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00502">getChannels()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00212">com::xuggle::xuggler::AudioSamples::getChannels()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00247">getCodecType()</a>, <a class="el" href="Packet_8cpp-source.html#l00171">com::xuggle::xuggler::Packet::getData()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00218">com::xuggle::xuggler::AudioSamples::getNumSamples()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00107">com::xuggle::xuggler::AudioSamples::getRawSamples()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00475">getSampleRate()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00206">com::xuggle::xuggler::AudioSamples::getSampleRate()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00237">com::xuggle::xuggler::AudioSamples::getSampleSize()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00379">getTimeBase()</a>, <a class="el" href="AudioSamples_8h-source.html#l00037">com::xuggle::xuggler::AudioSamples::getTimeStamp()</a>, <a class="el" href="AudioSamples_8cpp-source.html#l00194">com::xuggle::xuggler::AudioSamples::isComplete()</a>, <a class="el" href="Global_8h-source.html#l00051">com::xuggle::xuggler::Global::NO_PTS</a>, <a class="el" href="RefPointer_8h-source.html#l00237">com::xuggle::ferry::RefPointer&lt; T &gt;::reset()</a>, <a class="el" href="Packet_8cpp-source.html#l00209">com::xuggle::xuggler::Packet::reset()</a>, <a class="el" href="IAudioSamples_8cpp-source.html#l00069">com::xuggle::xuggler::IAudioSamples::samplesToDefaultPts()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>, <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>, and <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01232"></a>01232 {
<a name="l01233"></a>01233   int32_t retval = -1;
<a name="l01234"></a>01234   AudioSamples *samples = <span class="keyword">dynamic_cast&lt;</span>AudioSamples*<span class="keyword">&gt;</span> (pSamples);
<a name="l01235"></a>01235   Packet *packet = <span class="keyword">dynamic_cast&lt;</span>Packet*<span class="keyword">&gt;</span> (pOutPacket);
<a name="l01236"></a>01236   RefPointer&lt;IBuffer&gt; encodingBuffer;
<a name="l01237"></a>01237   <span class="keywordtype">bool</span> usingInternalFrameBuffer = <span class="keyword">false</span>;
<a name="l01238"></a>01238 
<a name="l01239"></a>01239   <span class="keywordflow">try</span>
<a name="l01240"></a>01240   {
<a name="l01241"></a>01241     <span class="keywordflow">if</span> (mDirection != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a>)
<a name="l01242"></a>01242       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Decoding StreamCoder not valid for encoding"</span>);
<a name="l01243"></a>01243     <span class="keywordflow">if</span> (!mCodec)
<a name="l01244"></a>01244       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Codec not set"</span>);
<a name="l01245"></a>01245     <span class="keywordflow">if</span> (!mCodec-&gt;canEncode())
<a name="l01246"></a>01246       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Codec cannot be used to encode"</span>);
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     <span class="keywordflow">if</span> (!packet)
<a name="l01249"></a>01249       <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">"Invalid packet to encode to"</span>);
<a name="l01250"></a>01250     <span class="comment">// Zero out our packet</span>
<a name="l01251"></a>01251     packet-&gt;reset();
<a name="l01252"></a>01252 
<a name="l01253"></a>01253     <span class="keywordflow">if</span> (!mCodecContext)
<a name="l01254"></a>01254       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"StreamCoder not initialized properly"</span>);
<a name="l01255"></a>01255     <span class="keywordflow">if</span> (!mOpened)
<a name="l01256"></a>01256       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"StreamCoder not open"</span>);
<a name="l01257"></a>01257     <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7" title="A short hand for getCodec().getType().">getCodecType</a>() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd49b0eab30b8c20c49852bb03e66986cde">ICodec::CODEC_TYPE_AUDIO</a>)
<a name="l01258"></a>01258       <span class="keywordflow">throw</span> std::runtime_error(
<a name="l01259"></a>01259           <span class="stringliteral">"Attempting to encode audio with non audio coder"</span>);
<a name="l01260"></a>01260     <span class="keywordflow">if</span> (!mAudioFrameBuffer)
<a name="l01261"></a>01261       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"Audio Frame Buffer not initialized"</span>);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">// First, how many bytes do we need to encode a packet?</span>
<a name="l01264"></a>01264     int32_t frameSize = 0;
<a name="l01265"></a>01265     int32_t frameBytes = 0;
<a name="l01266"></a>01266     int32_t availableSamples = (samples ? samples-&gt;getNumSamples()
<a name="l01267"></a>01267         - startingSample : 0);
<a name="l01268"></a>01268     int32_t samplesConsumed = 0;
<a name="l01269"></a>01269     int16_t *avSamples = (samples ? samples-&gt;getRawSamples(startingSample) : 0);
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="keywordflow">if</span> (samples)
<a name="l01272"></a>01272     {
<a name="l01273"></a>01273       <span class="keywordflow">if</span> (samples-&gt;getChannels() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>())
<a name="l01274"></a>01274         <span class="keywordflow">throw</span> std::invalid_argument(
<a name="l01275"></a>01275             <span class="stringliteral">"channels in sample do not match StreamCoder"</span>);
<a name="l01276"></a>01276       <span class="keywordflow">if</span> (samples-&gt;getSampleRate() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>())
<a name="l01277"></a>01277         <span class="keywordflow">throw</span> std::invalid_argument(
<a name="l01278"></a>01278             <span class="stringliteral">"sample rate in sample does not match StreamCoder"</span>);
<a name="l01279"></a>01279 
<a name="l01280"></a>01280       <span class="keywordflow">if</span> (!samples-&gt;isComplete())
<a name="l01281"></a>01281         <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">"input samples are not complete"</span>);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283       <span class="keywordflow">if</span> (mFakeNextPts == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a> &amp;&amp; samples-&gt;getTimeStamp()
<a name="l01284"></a>01284           != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l01285"></a>01285         mFakeNextPts = samples-&gt;getTimeStamp()
<a name="l01286"></a>01286             + <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(startingSample,
<a name="l01287"></a>01287                 <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (mFakeNextPts == <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l01292"></a>01292       mFakeNextPts = 0;
<a name="l01293"></a>01293 
<a name="l01294"></a>01294     <span class="keywordflow">if</span> (availableSamples &lt; 0 || (avSamples &amp;&amp; availableSamples == 0))
<a name="l01295"></a>01295       <span class="keywordflow">throw</span> std::invalid_argument(
<a name="l01296"></a>01296           <span class="stringliteral">"no bytes in buffer at specified starting sample"</span>);
<a name="l01297"></a>01297 
<a name="l01298"></a>01298     int32_t bytesPerSample = (samples ? samples-&gt;getSampleSize()
<a name="l01299"></a>01299         : <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#23b6a9d950557e6e4b6935243a520215" title="A convenience method that returns the # of bits in a given format.">IAudioSamples::findSampleBitDepth</a>(
<a name="l01300"></a>01300             (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756" title="The format we use to represent audio.">IAudioSamples::Format</a>) mCodecContext-&gt;sample_fmt) / 8
<a name="l01301"></a>01301             * <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d" title="Get the number of channels in this audio stream.">getChannels</a>());
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     <span class="comment">/*</span>
<a name="l01304"></a>01304 <span class="comment">     * This gets tricky; There may be more audio samples passed to</span>
<a name="l01305"></a>01305 <span class="comment">     * us than can fit in an audio frame, or there may be less.</span>
<a name="l01306"></a>01306 <span class="comment">     *</span>
<a name="l01307"></a>01307 <span class="comment">     * If less, we need to cache for a future call.</span>
<a name="l01308"></a>01308 <span class="comment">     *</span>
<a name="l01309"></a>01309 <span class="comment">     * If more, we need to just use what's needed, and let the caller</span>
<a name="l01310"></a>01310 <span class="comment">     * know the number of samples we used.</span>
<a name="l01311"></a>01311 <span class="comment">     *</span>
<a name="l01312"></a>01312 <span class="comment">     * What happens when we exhaust all audio, but we still don't</span>
<a name="l01313"></a>01313 <span class="comment">     * have enough to decode a frame?  answer: the caller passes us</span>
<a name="l01314"></a>01314 <span class="comment">     * NULL as the pInSamples, and we just silently drop the incomplete</span>
<a name="l01315"></a>01315 <span class="comment">     * frame.</span>
<a name="l01316"></a>01316 <span class="comment">     *</span>
<a name="l01317"></a>01317 <span class="comment">     * To simplify coding here (and hence open for optimization if</span>
<a name="l01318"></a>01318 <span class="comment">     * this ends up being a bottleneck), I always copy audio samples</span>
<a name="l01319"></a>01319 <span class="comment">     * into a frame buffer, and then only encode from the frame buffer</span>
<a name="l01320"></a>01320 <span class="comment">     * in this class.</span>
<a name="l01321"></a>01321 <span class="comment">     */</span>
<a name="l01322"></a>01322     frameSize = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#7215694c124919baeaf61cb59d2611ef" title="For this stream, get the number of audio samples that are represented in a packet...">getAudioFrameSize</a>();
<a name="l01323"></a>01323     frameBytes = frameSize * bytesPerSample;
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     <span class="comment">// More error checking</span>
<a name="l01326"></a>01326     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(frameBytes &lt;= mAudioFrameBuffer-&gt;getBufferSize(),
<a name="l01327"></a>01327         <span class="stringliteral">"did frameSize change from open?"</span>);
<a name="l01328"></a>01328     <span class="keywordflow">if</span> (frameBytes &gt; mAudioFrameBuffer-&gt;getBufferSize())
<a name="l01329"></a>01329       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"not enough memory in internal frame buffer"</span>);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mBytesInFrameBuffer &lt;= frameBytes,
<a name="l01332"></a>01332         <span class="stringliteral">"did frameSize change from open?"</span>);
<a name="l01333"></a>01333     <span class="keywordflow">if</span> (frameBytes &lt; mBytesInFrameBuffer)
<a name="l01334"></a>01334       <span class="keywordflow">throw</span> std::runtime_error(
<a name="l01335"></a>01335           <span class="stringliteral">"too many bytes left over in internal frame buffer"</span>);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * frameBuffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) mAudioFrameBuffer-&gt;getBytes(
<a name="l01338"></a>01338         0, frameBytes);
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (!frameBuffer)
<a name="l01340"></a>01340       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"could not get internal frame buffer"</span>);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     int32_t bytesToCopyToFrameBuffer = frameBytes - mBytesInFrameBuffer;
<a name="l01343"></a>01343     bytesToCopyToFrameBuffer = FFMIN(bytesToCopyToFrameBuffer,
<a name="l01344"></a>01344         availableSamples*bytesPerSample);
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     <span class="keywordflow">if</span> (avSamples)
<a name="l01347"></a>01347     {
<a name="l01348"></a>01348       <span class="keywordflow">if</span> (availableSamples &gt;= frameSize &amp;&amp; mBytesInFrameBuffer == 0)
<a name="l01349"></a>01349       {
<a name="l01350"></a>01350         <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"audioEncode: Using passed in buffer: %d, %d, %d"</span>,
<a name="l01351"></a>01351             availableSamples, frameSize, mBytesInFrameBuffer);
<a name="l01352"></a>01352         frameBuffer = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) avSamples;
<a name="l01353"></a>01353         samplesConsumed = frameSize;
<a name="l01354"></a>01354         usingInternalFrameBuffer = <span class="keyword">false</span>;
<a name="l01355"></a>01355       }
<a name="l01356"></a>01356       <span class="keywordflow">else</span>
<a name="l01357"></a>01357       {
<a name="l01358"></a>01358         <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"audioEncode: Using internal buffer: %d, %d, %d"</span>,
<a name="l01359"></a>01359             availableSamples, frameSize, mBytesInFrameBuffer);
<a name="l01360"></a>01360         memcpy(frameBuffer + mBytesInFrameBuffer, avSamples,
<a name="l01361"></a>01361             bytesToCopyToFrameBuffer);
<a name="l01362"></a>01362         mBytesInFrameBuffer += bytesToCopyToFrameBuffer;
<a name="l01363"></a>01363         samplesConsumed = bytesToCopyToFrameBuffer / bytesPerSample;
<a name="l01364"></a>01364         retval = samplesConsumed;
<a name="l01365"></a>01365         usingInternalFrameBuffer = <span class="keyword">true</span>;
<a name="l01366"></a>01366       }
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368     <span class="keywordflow">else</span>
<a name="l01369"></a>01369     {
<a name="l01370"></a>01370       <span class="comment">// drop everything in the frame buffer, and instead</span>
<a name="l01371"></a>01371       <span class="comment">// just pass a null buffer to the encoder.</span>
<a name="l01372"></a>01372 
<a name="l01373"></a>01373       <span class="comment">// this should happen when the caller passes NULL for the</span>
<a name="l01374"></a>01374       <span class="comment">// input samples</span>
<a name="l01375"></a>01375       frameBuffer = 0;
<a name="l01376"></a>01376     }
<a name="l01377"></a>01377     mSamplesForEncoding += samplesConsumed;
<a name="l01378"></a>01378     <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Consumed %ld for total of %lld"</span>,
<a name="l01379"></a>01379         samplesConsumed, mSamplesForEncoding);
<a name="l01380"></a>01380 
<a name="l01381"></a>01381     <span class="keywordflow">if</span> (!frameBuffer || !usingInternalFrameBuffer || mBytesInFrameBuffer
<a name="l01382"></a>01382         &gt;= frameBytes)
<a name="l01383"></a>01383     {
<a name="l01384"></a>01384       <span class="comment">// First, get the right buffer size.</span>
<a name="l01385"></a>01385       int32_t bufferSize = frameBytes;
<a name="l01386"></a>01386       <span class="keywordflow">if</span> (mCodecContext-&gt;codec-&gt;id == CODEC_ID_FLAC
<a name="l01387"></a>01387               || mCodecContext-&gt;codec-&gt;id == CODEC_ID_VORBIS)
<a name="l01388"></a>01388       {
<a name="l01389"></a>01389         <span class="comment">// FLAC &amp; VORBIS audio for some reason gives an error if your output buffer isn't</span>
<a name="l01390"></a>01390         <span class="comment">// over double the frame size, so we fake it here.  This could be further optimized</span>
<a name="l01391"></a>01391         <span class="comment">// to only require an exact number, but this math is simpler and will always</span>
<a name="l01392"></a>01392         <span class="comment">// be large enough.</span>
<a name="l01393"></a>01393         bufferSize = (64 + <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#7215694c124919baeaf61cb59d2611ef" title="For this stream, get the number of audio samples that are represented in a packet...">getAudioFrameSize</a>() * (bytesPerSample + 1)) * 2;
<a name="l01394"></a>01394       }
<a name="l01395"></a>01395       <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(bufferSize&gt; 0, <span class="stringliteral">"no buffer size in samples"</span>);
<a name="l01396"></a>01396       retval = packet-&gt;allocateNewPayload(bufferSize);
<a name="l01397"></a>01397       <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l01398"></a>01398       {
<a name="l01399"></a>01399         encodingBuffer = packet-&gt;getData();
<a name="l01400"></a>01400       }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402       uint8_t* buf = 0;
<a name="l01403"></a>01403 
<a name="l01404"></a>01404       <span class="keywordflow">if</span> (encodingBuffer)
<a name="l01405"></a>01405       {
<a name="l01406"></a>01406         buf = (uint8_t*) encodingBuffer-&gt;getBytes(0, bufferSize);
<a name="l01407"></a>01407       }
<a name="l01408"></a>01408       <span class="keywordflow">if</span> (buf &amp;&amp; bufferSize)
<a name="l01409"></a>01409       {
<a name="l01410"></a>01410         <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Attempting encodeAudio(%p, %p, %d, %p)"</span>,
<a name="l01411"></a>01411             mCodecContext,
<a name="l01412"></a>01412             buf,
<a name="l01413"></a>01413             bufferSize,
<a name="l01414"></a>01414             frameBuffer);
<a name="l01415"></a>01415 
<a name="l01416"></a>01416         <span class="comment">// This hack works around the fact that PCM's codecs</span>
<a name="l01417"></a>01417         <span class="comment">// calculate samples from buffer length, and sets</span>
<a name="l01418"></a>01418         <span class="comment">// the wrong frame size, but in</span>
<a name="l01419"></a>01419         <span class="comment">// reality we're always passing in 2 byte samples.</span>
<a name="l01420"></a>01420         <span class="keywordtype">double</span> pcmCorrection = 1.0;
<a name="l01421"></a>01421         <span class="keywordflow">switch</span> (mCodecContext-&gt;codec-&gt;id)
<a name="l01422"></a>01422         {
<a name="l01423"></a>01423         <span class="keywordflow">case</span> CODEC_ID_PCM_S32LE:
<a name="l01424"></a>01424         <span class="keywordflow">case</span> CODEC_ID_PCM_S32BE:
<a name="l01425"></a>01425         <span class="keywordflow">case</span> CODEC_ID_PCM_U32LE:
<a name="l01426"></a>01426         <span class="keywordflow">case</span> CODEC_ID_PCM_U32BE:
<a name="l01427"></a>01427           pcmCorrection = 2.0;
<a name="l01428"></a>01428           <span class="keywordflow">break</span>;
<a name="l01429"></a>01429         <span class="keywordflow">case</span> CODEC_ID_PCM_S24LE:
<a name="l01430"></a>01430         <span class="keywordflow">case</span> CODEC_ID_PCM_S24BE:
<a name="l01431"></a>01431         <span class="keywordflow">case</span> CODEC_ID_PCM_U24LE:
<a name="l01432"></a>01432         <span class="keywordflow">case</span> CODEC_ID_PCM_U24BE:
<a name="l01433"></a>01433         <span class="keywordflow">case</span> CODEC_ID_PCM_S24DAUD:
<a name="l01434"></a>01434           pcmCorrection = 1.5;
<a name="l01435"></a>01435           <span class="keywordflow">break</span>;
<a name="l01436"></a>01436         <span class="keywordflow">case</span> CODEC_ID_PCM_S16LE:
<a name="l01437"></a>01437         <span class="keywordflow">case</span> CODEC_ID_PCM_S16BE:
<a name="l01438"></a>01438         <span class="keywordflow">case</span> CODEC_ID_PCM_U16LE:
<a name="l01439"></a>01439         <span class="keywordflow">case</span> CODEC_ID_PCM_U16BE:
<a name="l01440"></a>01440           pcmCorrection = 1.0;
<a name="l01441"></a>01441           <span class="keywordflow">break</span>;
<a name="l01442"></a>01442         <span class="keywordflow">case</span> CODEC_ID_PCM_ALAW:
<a name="l01443"></a>01443         <span class="keywordflow">case</span> CODEC_ID_PCM_MULAW:
<a name="l01444"></a>01444         <span class="keywordflow">case</span> CODEC_ID_PCM_S8:
<a name="l01445"></a>01445         <span class="keywordflow">case</span> CODEC_ID_PCM_U8:
<a name="l01446"></a>01446         <span class="keywordflow">case</span> CODEC_ID_PCM_ZORK:
<a name="l01447"></a>01447           pcmCorrection = 0.5;
<a name="l01448"></a>01448           <span class="keywordflow">break</span>;
<a name="l01449"></a>01449         <span class="keywordflow">default</span>:
<a name="l01450"></a>01450           pcmCorrection = 1.0;
<a name="l01451"></a>01451         }
<a name="l01452"></a>01452         retval = avcodec_encode_audio(mCodecContext, buf, (int32_t) (bufferSize
<a name="l01453"></a>01453             * pcmCorrection), (int16_t*) frameBuffer);
<a name="l01454"></a>01454         <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Finished %d encodeAudio(%p, %p, %d, %p)"</span>,
<a name="l01455"></a>01455             retval,
<a name="l01456"></a>01456             mCodecContext,
<a name="l01457"></a>01457             buf,
<a name="l01458"></a>01458             bufferSize,
<a name="l01459"></a>01459             frameBuffer);
<a name="l01460"></a>01460         <span class="comment">// regardless of what happened, nuke any data in our frame</span>
<a name="l01461"></a>01461         <span class="comment">// buffer.</span>
<a name="l01462"></a>01462         mBytesInFrameBuffer = 0;
<a name="l01463"></a>01463         <span class="keywordflow">if</span> (retval &gt;= 0)
<a name="l01464"></a>01464         {
<a name="l01465"></a>01465           <span class="comment">// and only do this if a packet is returned</span>
<a name="l01466"></a>01466           <span class="keywordflow">if</span> (retval &gt; 0)
<a name="l01467"></a>01467           {
<a name="l01468"></a>01468             mSamplesCoded += frameSize;
<a name="l01469"></a>01469 
<a name="l01470"></a>01470             <span class="comment">// let's check to see if the time stamp of passed in</span>
<a name="l01471"></a>01471             <span class="comment">// samples (if any) are within tolerance of our expected</span>
<a name="l01472"></a>01472             <span class="comment">// time stamp.  if not, this is most likely happening</span>
<a name="l01473"></a>01473             <span class="comment">// because the IStreamCoder's data source lost a packet.</span>
<a name="l01474"></a>01474             <span class="comment">// We will adjust our starting time stamps then for this new</span>
<a name="l01475"></a>01475             <span class="comment">// packet</span>
<a name="l01476"></a>01476             mFakeCurrPts = mFakeNextPts;
<a name="l01477"></a>01477             <span class="keywordflow">if</span> (samples &amp;&amp; samples-&gt;getTimeStamp() != <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382" title="A value that means no time stamp is set for a given object.">Global::NO_PTS</a>)
<a name="l01478"></a>01478             {
<a name="l01479"></a>01479               int64_t samplesTs = samples-&gt;getTimeStamp()
<a name="l01480"></a>01480                   + <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(startingSample
<a name="l01481"></a>01481                       + samplesConsumed, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l01482"></a>01482               int64_t samplesCached = mSamplesForEncoding - mSamplesCoded;
<a name="l01483"></a>01483               int64_t tsDelta = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(
<a name="l01484"></a>01484                   samplesCached, <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l01485"></a>01485               int64_t gap = samplesTs - (mFakeNextPts + tsDelta);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487               <span class="comment">// ignore negative gaps; some containers like WMV</span>
<a name="l01488"></a>01488               <span class="comment">// don't actually set the right time stamps, and we</span>
<a name="l01489"></a>01489               <span class="comment">// can assume a negative gap can't happen</span>
<a name="l01490"></a>01490               <span class="keywordflow">if</span> ((gap &gt; 1))
<a name="l01491"></a>01491               {
<a name="l01492"></a>01492                 <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"reset;"</span>
<a name="l01493"></a>01493                     <span class="stringliteral">"samplesTs:%lld;"</span>
<a name="l01494"></a>01494                     <span class="stringliteral">"samplesConsumed:%ld;"</span>
<a name="l01495"></a>01495                     <span class="stringliteral">"startingSample:%lu;"</span>
<a name="l01496"></a>01496                     <span class="stringliteral">"samplesForEncoding:%lld;"</span>
<a name="l01497"></a>01497                     <span class="stringliteral">"samplesCoded:%lld;"</span>
<a name="l01498"></a>01498                     <span class="stringliteral">"samplesCached:%lld;"</span>
<a name="l01499"></a>01499                     <span class="stringliteral">"tsDelta:%lld;"</span>
<a name="l01500"></a>01500                     <span class="stringliteral">"fakeNextPts:%lld;"</span>
<a name="l01501"></a>01501                     <span class="stringliteral">"gap:%lld;"</span>
<a name="l01502"></a>01502                     <span class="stringliteral">"lastExternallySetTs:%lld;"</span>
<a name="l01503"></a>01503                     <span class="stringliteral">"new fakeNextPts:%lld;"</span>,
<a name="l01504"></a>01504                     samplesTs,
<a name="l01505"></a>01505                     samplesConsumed,
<a name="l01506"></a>01506                     startingSample,
<a name="l01507"></a>01507                     mSamplesForEncoding,
<a name="l01508"></a>01508                     mSamplesCoded,
<a name="l01509"></a>01509                     samplesCached,
<a name="l01510"></a>01510                     tsDelta,
<a name="l01511"></a>01511                     mFakeNextPts,
<a name="l01512"></a>01512                     gap,
<a name="l01513"></a>01513                     mLastExternallySetTimeStamp,
<a name="l01514"></a>01514                     samplesTs - tsDelta);
<a name="l01515"></a>01515                 mLastExternallySetTimeStamp = samplesTs - tsDelta;
<a name="l01516"></a>01516                 mSamplesCoded = 0;
<a name="l01517"></a>01517                 mSamplesForEncoding = samplesCached;
<a name="l01518"></a>01518               }
<a name="l01519"></a>01519             }
<a name="l01520"></a>01520             mFakeNextPts = mLastExternallySetTimeStamp
<a name="l01521"></a>01521                 + <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(mSamplesCoded,
<a name="l01522"></a>01522                     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l01523"></a>01523 
<a name="l01524"></a>01524           }
<a name="l01525"></a>01525           RefPointer&lt;IRational&gt; thisTimeBase = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase</a>();
<a name="l01526"></a>01526           int64_t ts;
<a name="l01527"></a>01527           int64_t duration = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#f5485218ca32b9a3f7c563679758dd4a" title="Converts a number of samples at a given sampleRate into Microseconds.">IAudioSamples::samplesToDefaultPts</a>(frameSize,
<a name="l01528"></a>01528               <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2" title="Get the sample rate we use for this stream.">getSampleRate</a>());
<a name="l01529"></a>01529           <span class="keywordflow">if</span> (!thisTimeBase)
<a name="l01530"></a>01530           {
<a name="l01531"></a>01531             thisTimeBase.reset(mFakePtsTimeBase.value(), <span class="keyword">true</span>);
<a name="l01532"></a>01532             ts = mFakeCurrPts;
<a name="l01533"></a>01533           }
<a name="l01534"></a>01534           <span class="keywordflow">else</span>
<a name="l01535"></a>01535           {
<a name="l01536"></a>01536             ts = thisTimeBase-&gt;rescale(mFakeCurrPts, mFakePtsTimeBase.value());
<a name="l01537"></a>01537             duration
<a name="l01538"></a>01538                 = thisTimeBase-&gt;rescale(duration, mFakePtsTimeBase.value());
<a name="l01539"></a>01539           }
<a name="l01540"></a>01540           setPacketParameters(packet, retval, ts, thisTimeBase.value(), <span class="keyword">true</span>,
<a name="l01541"></a>01541               duration);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543           retval = samplesConsumed;
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545         <span class="keywordflow">else</span>
<a name="l01546"></a>01546         {
<a name="l01547"></a>01547           <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"avcodec_encode_audio failed"</span>);
<a name="l01548"></a>01548         }
<a name="l01549"></a>01549       }
<a name="l01550"></a>01550     }
<a name="l01551"></a>01551   }
<a name="l01552"></a>01552   <span class="keywordflow">catch</span> (std::bad_alloc &amp; e)
<a name="l01553"></a>01553   {
<a name="l01554"></a>01554     <span class="keywordflow">throw</span> e;
<a name="l01555"></a>01555   }
<a name="l01556"></a>01556   <span class="keywordflow">catch</span> (std::exception&amp; e)
<a name="l01557"></a>01557   {
<a name="l01558"></a>01558     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"error: %s"</span>, e.what());
<a name="l01559"></a>01559     retval = -1;
<a name="l01560"></a>01560   }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   <span class="keywordflow">return</span> retval;
<a name="l01563"></a>01563 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="322018854233516dabd22740fbc9e5e3"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getNextPredictedPts" ref="322018854233516dabd22740fbc9e5e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::StreamCoder::getNextPredictedPts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For this stream, get the next Pts that we expect to decode. 
<p>
Note that this may not actually be the next Pts (for example due to transmission packet drops in the input source). Still it can be a useful tool.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next presentation time stamp we expect to decode on this stream. This is always in units of 1/1,000,000 seconds </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#faa50862ae1188ac20ae10539aefce5c">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00415">415</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00416"></a>00416 {
<a name="l00417"></a>00417   <span class="keywordflow">return</span> mFakeNextPts;
<a name="l00418"></a>00418 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="afc7dd7a6f0ee4157beeafc6c0561ac9"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getCodecTag" ref="afc7dd7a6f0ee4157beeafc6c0561ac9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getCodecTag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the 4-byte FOURCC tag (Least Significant Byte first). 
<p>
This is really a packed 4-byte array so it's only useful if you use bit-wise operations on it. Some language wrappings may provide more obvious ways of manipulating, but this is the safest way to do this that will work with all wrappers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the FOURCC tag. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ca7adbeb0262af0e9d368cac4cdd7759">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01666">1666</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01667"></a>01667 {
<a name="l01668"></a>01668   <span class="keywordflow">return</span> (mCodecContext ? mCodecContext-&gt;codec_tag : 0);
<a name="l01669"></a>01669 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="44de26df5c2b94ff6a05edb0a25eb749"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setCodecTag" ref="44de26df5c2b94ff6a05edb0a25eb749" args="(int32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setCodecTag           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>fourcc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the 4-byte FOURCC tag for this coder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fourcc</em>&nbsp;</td><td>The FOURCC to set, with Least Significant Byte first. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#e84f341deb602fc8a093ceb4dd071019">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01672">1672</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01673"></a>01673 {
<a name="l01674"></a>01674   <span class="keywordflow">if</span> (mCodecContext)
<a name="l01675"></a>01675     mCodecContext-&gt;codec_tag = tag;
<a name="l01676"></a>01676 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4b46738b73578892a602c9e4f5d86b9a"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getNumProperties" ref="4b46738b73578892a602c9e4f5d86b9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getNumProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of settable properties on this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>total number of options (not including constant definitions) </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#9b8475c809d1a5684a987f4d74789b17">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01679">1679</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00112">com::xuggle::xuggler::Property::getNumProperties()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01680"></a>01680 {
<a name="l01681"></a>01681   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#875467d8b4b7317d1bbc265e369af806" title="For internal use.">Property::getNumProperties</a>(mCodecContext);
<a name="l01682"></a>01682 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e455a70c2e5117f2606aef6e78851eb9"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyMetaData" ref="e455a70c2e5117f2606aef6e78851eb9" args="(int32_t propertyNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> * com::xuggle::xuggler::StreamCoder::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>propertyNo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>propertyNo</em>&nbsp;</td><td>The property number in the options list.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ccd97f0e68e28c74b31d6fad9edcf2d5">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01685">1685</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00131">com::xuggle::xuggler::Property::getPropertyMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01686"></a>01686 {
<a name="l01687"></a>01687   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#1acff8d5d03d46ed59ccc95cb713dde4" title="Returns the metadata for the numbered property.">Property::getPropertyMetaData</a>(mCodecContext, propertyNo);
<a name="l01688"></a>01688 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="986ce910417e9eae24db40582628fc36"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyMetaData" ref="986ce910417e9eae24db40582628fc36" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> * com::xuggle::xuggler::StreamCoder::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#1092cf8f25a60f0cf41f3762c34a272b">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01691">1691</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00131">com::xuggle::xuggler::Property::getPropertyMetaData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01692"></a>01692 {
<a name="l01693"></a>01693   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#1acff8d5d03d46ed59ccc95cb713dde4" title="Returns the metadata for the numbered property.">Property::getPropertyMetaData</a>(mCodecContext, name);
<a name="l01694"></a>01694 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="11e185722fd04e12b149a920acccda58"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setProperty" ref="11e185722fd04e12b149a920acccda58" args="(const char *name, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a property on this Object. 
<p>
All AVOptions supported by the underlying AVClass are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name. For example "b" for bit-rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 if the property was successfully set; &lt;0 on error </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c4dd45fb064dbcbb4a87f909f31fbaa0">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01697">1697</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01698"></a>01698 {
<a name="l01699"></a>01699   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mCodecContext, aName, aValue);
<a name="l01700"></a>01700 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a3c98a470f35ea37de9b09e59051adb4"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setProperty" ref="a3c98a470f35ea37de9b09e59051adb4" args="(const char *name, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#25c22b581ba91e0879e217ddc6683705">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01703">1703</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01704"></a>01704 {
<a name="l01705"></a>01705   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mCodecContext, aName, aValue);
<a name="l01706"></a>01706 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c088c801ac620c2408a2d772ef0d4106"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setProperty" ref="c088c801ac620c2408a2d772ef0d4106" args="(const char *name, int64_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#2fe9345b2139cd51dae0e34150363aa4">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01709">1709</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01710"></a>01710 {
<a name="l01711"></a>01711   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mCodecContext, aName, aValue);
<a name="l01712"></a>01712 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0b410e91987886c9aaa054409bd264f6"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setProperty" ref="0b410e91987886c9aaa054409bd264f6" args="(const char *name, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#fe37876b910d67ade52eecf582b8d1fe">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01715">1715</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01716"></a>01716 {
<a name="l01717"></a>01717   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mCodecContext, aName, aValue);
<a name="l01718"></a>01718 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="745884fb6d54f10306298ec51c37c1aa"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setProperty" ref="745884fb6d54f10306298ec51c37c1aa" args="(const char *name, IRational *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#218c9b5b0dff04d90962ec87352096fd">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01721">1721</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00199">com::xuggle::xuggler::Property::setProperty()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01722"></a>01722 {
<a name="l01723"></a>01723   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#8314b4b8969a8a0ac21b8a8f3ca2acaa" title="Looks up the property &amp;#39;name&amp;#39; in &amp;#39;context&amp;#39; and sets the value of the...">Property::setProperty</a>(mCodecContext, aName, aValue);
<a name="l01724"></a>01724 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="46ad55458a7bc58e68773cefc7a2bb46"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyAsString" ref="46ad55458a7bc58e68773cefc7a2bb46" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * com::xuggle::xuggler::StreamCoder::getPropertyAsString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a property on this Object. 
<p>
Note for C++ callers; you must free the returned array with delete[] in order to avoid a memory leak. Other language folks need not worry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>property name</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an string copy of the option value, or null if the option doesn't exist. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0a292d948b0b2dbaf8f2b1c34be7a01a">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01727">1727</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00224">com::xuggle::xuggler::Property::getPropertyAsString()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01728"></a>01728 {
<a name="l01729"></a>01729   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#626f8c0b62b95793590b85d6552f9ba6" title="Gets the value of this property, and returns as a new[]ed string.">Property::getPropertyAsString</a>(mCodecContext, aName);
<a name="l01730"></a>01730 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="860e21eba8f6a01bbd89658b62f9c51d"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyAsDouble" ref="860e21eba8f6a01bbd89658b62f9c51d" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double com::xuggle::xuggler::StreamCoder::getPropertyAsDouble           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a double;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c25f79946060059ee021bce8bc05bc4b">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01733">1733</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00407">com::xuggle::xuggler::Property::getPropertyAsDouble()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01734"></a>01734 {
<a name="l01735"></a>01735   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#5b04523742370ac92e85c843c80fda57" title="Gets the value of this property, and returns as a double;.">Property::getPropertyAsDouble</a>(mCodecContext, aName);
<a name="l01736"></a>01736 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="577f109de16549bebcfda6c275cd63c8"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyAsLong" ref="577f109de16549bebcfda6c275cd63c8" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::StreamCoder::getPropertyAsLong           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an long;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#82634d367c065b096cbb224d6caa5a15">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01739">1739</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00430">com::xuggle::xuggler::Property::getPropertyAsLong()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01740"></a>01740 {
<a name="l01741"></a>01741   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#e1eb7b43f0a6d77bb44fa71845b084c4" title="Gets the value of this property, and returns as an long;.">Property::getPropertyAsLong</a>(mCodecContext, aName);
<a name="l01742"></a>01742 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="67ec2cafa9879d66f862cdcd18ed831b"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyAsRational" ref="67ec2cafa9879d66f862cdcd18ed831b" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> * com::xuggle::xuggler::StreamCoder::getPropertyAsRational           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#8c570c4ea02459a2be7225e9d022ff15">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01745">1745</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00453">com::xuggle::xuggler::Property::getPropertyAsRational()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01746"></a>01746 {
<a name="l01747"></a>01747   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#383d3c035f3b6ad95e65247f561fe04c" title="Gets the value of this property, and returns as an IRational;.">Property::getPropertyAsRational</a>(mCodecContext, aName);
<a name="l01748"></a>01748 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8198a8c1864f7e80360a32e3464e4be4"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getPropertyAsBoolean" ref="8198a8c1864f7e80360a32e3464e4be4" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::StreamCoder::getPropertyAsBoolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value of property, or false on error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c64d752357de5237693281b854f927d6">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01751">1751</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Property_8cpp-source.html#l00477">com::xuggle::xuggler::Property::getPropertyAsBoolean()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01752"></a>01752 {
<a name="l01753"></a>01753   <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Property.html#768278773536fdeb44b6f4358baaaf9a" title="Gets the value of this property, and returns as a boolean.">Property::getPropertyAsBoolean</a>(mCodecContext, aName);
<a name="l01754"></a>01754 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0fd9b5cc2bcabf4d605923f9559cef52"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::isOpen" ref="0fd9b5cc2bcabf4d605923f9559cef52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::StreamCoder::isOpen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> is currently open. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if open; false if not </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c9befe352247818b4e0fddafb4764f1a">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01757">1757</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="Stream_8cpp-source.html#l00277">com::xuggle::xuggler::Stream::setStreamCoder()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01758"></a>01758 {
<a name="l01759"></a>01759   <span class="keywordflow">return</span> mOpened;
<a name="l01760"></a>01760 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="35c1957cd69edc56727d8cb124ff0c64"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getDefaultAudioFrameSize" ref="35c1957cd69edc56727d8cb124ff0c64" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getDefaultAudioFrameSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default audio frame size (in samples). 
<p>
Some codecs, especially raw codecs, like PCM, don't have a standard frame size. In those cases, we use the value of this setting to determine how many samples to encode into a single packet.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of samples in an audio frame size if the codec doesn't specify the size. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.21 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#6e2b6aa60e6f05952bfa12d6def2d33f">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01763">1763</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l01616">getAudioFrameSize()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01764"></a>01764 {
<a name="l01765"></a>01765   <span class="keywordflow">return</span> mDefaultAudioFrameSize;
<a name="l01766"></a>01766 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="559e498fccb1698f959fd021948988bf"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setDefaultAudioFrameSize" ref="559e498fccb1698f959fd021948988bf" args="(int32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setDefaultAudioFrameSize           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>aNewSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default audio frame size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aNewSize</em>&nbsp;</td><td>The new number of samples to use to encode samples into a packet. This setting is ignored if &lt;= 0 or if the codec requires it's own frame size (e.g. Nellymoser).</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#35c1957cd69edc56727d8cb124ff0c64" title="Get the default audio frame size (in samples).">getDefaultAudioFrameSize()</a> </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.21 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#dc9c7510ce5706e3cc1f38cfb04883b5">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01769">1769</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01770"></a>01770 {
<a name="l01771"></a>01771   <span class="keywordflow">if</span> (aNewSize &gt; 0)
<a name="l01772"></a>01772     mDefaultAudioFrameSize = aNewSize;
<a name="l01773"></a>01773 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f07e402d43b4a3c577d5c2d3a09d604"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setCodec" ref="1f07e402d43b4a3c577d5c2d3a09d604" args="(int32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setCodec           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00309">309</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="IStreamCoder_8h-source.html#l00052">com::xuggle::xuggler::IStreamCoder::ENCODING</a>, <a class="el" href="Codec_8cpp-source.html#l00126">com::xuggle::xuggler::Codec::findDecodingCodecByIntID()</a>, <a class="el" href="Codec_8cpp-source.html#l00089">com::xuggle::xuggler::Codec::findEncodingCodecByIntID()</a>, <a class="el" href="RefCounted_8cpp-source.html#l00070">com::xuggle::ferry::RefCounted::release()</a>, and <a class="el" href="StreamCoder_8cpp-source.html#l00277">setCodec()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00310"></a>00310 {
<a name="l00311"></a>00311   ICodec *codec = 0;
<a name="l00312"></a>00312   <span class="keywordflow">if</span> (<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a> == mDirection)
<a name="l00313"></a>00313   {
<a name="l00314"></a>00314     codec = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html#8fbf6154e69f9221244c8032b18e2d47" title="Find a codec that can be used for encoding.">Codec::findEncodingCodecByIntID</a>(<span class="keywordtype">id</span>);
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316   <span class="keywordflow">else</span>
<a name="l00317"></a>00317   {
<a name="l00318"></a>00318     codec = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html#38682ae61446c5ae87e680a81c3eca38" title="Find a codec that can be used for decoding.">Codec::findDecodingCodecByIntID</a>(<span class="keywordtype">id</span>);
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320   <span class="keywordflow">if</span> (codec)
<a name="l00321"></a>00321   {
<a name="l00322"></a>00322     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9" title="Set the Codec to the passed in Codec, discarding the old Codec if set.">setCodec</a>(codec);
<a name="l00323"></a>00323     <span class="comment">// release it because the set above should get</span>
<a name="l00324"></a>00324     <span class="comment">// the permanent reference.</span>
<a name="l00325"></a>00325     codec-&gt;release();
<a name="l00326"></a>00326     codec = 0;
<a name="l00327"></a>00327   }
<a name="l00328"></a>00328 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ce525892dddad9328378e914560b6465"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::make" ref="ce525892dddad9328378e914560b6465" args="(Direction direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>* com::xuggle::xuggler::StreamCoder::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method creates a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that is not tied to any container or stream. 
<p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00100">make()</a>, <a class="el" href="Stream_8cpp-source.html#l00072">com::xuggle::xuggler::Stream::make()</a>, and <a class="el" href="IStreamCoder_8cpp-source.html#l00035">com::xuggle::xuggler::IStreamCoder::make()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e0854001b5bcb9f727719dd343481696"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::make" ref="e0854001b5bcb9f727719dd343481696" args="(Direction direction, AVCodecContext *context, Stream *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> * com::xuggle::xuggler::StreamCoder::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AVCodecContext *&nbsp;</td>
          <td class="paramname"> <em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method creates a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that is tied to a specific stream in a container. 
<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00192">192</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465">make()</a>, <a class="el" href="StreamCoder_8h-source.html#l00178">mCodecContext</a>, <a class="el" href="StreamCoder_8h-source.html#l00177">mDirection</a>, <a class="el" href="StreamCoder_8h-source.html#l00179">mStream</a>, and <a class="el" href="RefCounted_8h-source.html#l00230">VS_REF_RELEASE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00194"></a>00194 {
<a name="l00195"></a>00195   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed979bf4a49888aaaa4d26101451cb65">StreamCoder</a> *retval = 0;
<a name="l00196"></a>00196   <span class="keywordflow">if</span> (codecCtx)
<a name="l00197"></a>00197   {
<a name="l00198"></a>00198     <span class="keywordflow">try</span>
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200       retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465" title="This method creates a StreamCoder that is not tied to any container or stream.">StreamCoder::make</a>();
<a name="l00201"></a>00201       <span class="comment">// In FFmpeg r20623 they started defaulting the sample</span>
<a name="l00202"></a>00202       <span class="comment">// format to NONE, but Xuggler uses assume S16, so we</span>
<a name="l00203"></a>00203       <span class="comment">// override that.</span>
<a name="l00204"></a>00204       <span class="keywordflow">if</span> (codecCtx-&gt;sample_fmt == SAMPLE_FMT_NONE)
<a name="l00205"></a>00205         codecCtx-&gt;sample_fmt = SAMPLE_FMT_S16;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       retval-&gt;mCodecContext = codecCtx;
<a name="l00208"></a>00208       retval-&gt;mDirection = direction;
<a name="l00209"></a>00209       retval-&gt;mStream = stream; <span class="comment">//do not ref count.</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211       <span class="comment">// Set the private data to this object.</span>
<a name="l00212"></a>00212       codecCtx-&gt;opaque = retval;
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214     <span class="keywordflow">catch</span> (std::bad_alloc &amp;e)
<a name="l00215"></a>00215     {
<a name="l00216"></a>00216       <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00217"></a>00217       <span class="keywordflow">throw</span> e;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219   }
<a name="l00220"></a>00220   <span class="keywordflow">return</span> retval;
<a name="l00221"></a>00221 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="42c718c11e25574010f6b2921228a490"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::make" ref="42c718c11e25574010f6b2921228a490" args="(Direction direction, IStreamCoder *copyCoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> * com::xuggle::xuggler::StreamCoder::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *&nbsp;</td>
          <td class="paramname"> <em>copyCoder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l00100">100</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388">com::xuggle::xuggler::IStreamCoder::getCodec()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00224">getStream()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00379">getTimeBase()</a>, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465">make()</a>, <a class="el" href="StreamCoder_8h-source.html#l00178">mCodecContext</a>, <a class="el" href="StreamCoder_8h-source.html#l00177">mDirection</a>, <a class="el" href="StreamCoder_8h-source.html#l00179">mStream</a>, <a class="el" href="RefCounted_8cpp-source.html#l00070">com::xuggle::ferry::RefCounted::release()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00277">setCodec()</a>, <a class="el" href="Logger_8h-source.html#l00185">VS_LOG_WARN</a>, and <a class="el" href="RefCounted_8h-source.html#l00230">VS_REF_RELEASE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00101"></a>00101 {
<a name="l00102"></a>00102   <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed979bf4a49888aaaa4d26101451cb65">StreamCoder</a> *retval = 0;
<a name="l00103"></a>00103   <span class="keywordflow">try</span>
<a name="l00104"></a>00104   {
<a name="l00105"></a>00105     AVCodecContext* codecCtx = avcodec_alloc_context();
<a name="l00106"></a>00106     <span class="keywordflow">if</span> (!codecCtx)
<a name="l00107"></a>00107       <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465" title="This method creates a StreamCoder that is not tied to any container or stream.">StreamCoder::make</a>();
<a name="l00110"></a>00110     <span class="keywordflow">if</span> (retval)
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112       retval-&gt;mCodecContext = codecCtx;
<a name="l00113"></a>00113       retval-&gt;mDirection = direction;
<a name="l00114"></a>00114       retval-&gt;mStream = 0;
<a name="l00115"></a>00115       <span class="comment">// Set the private data to this object.</span>
<a name="l00116"></a>00116       codecCtx-&gt;opaque = retval;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed979bf4a49888aaaa4d26101451cb65">StreamCoder</a> *coder = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed979bf4a49888aaaa4d26101451cb65">StreamCoder</a>*<span class="keyword">&gt;</span> (aCoder);
<a name="l00119"></a>00119       <span class="keywordflow">if</span> (aCoder &amp;&amp; !coder)
<a name="l00120"></a>00120         <span class="keywordflow">throw</span> std::runtime_error(
<a name="l00121"></a>00121             <span class="stringliteral">"Passed in stream coder not of expected underlying C++ type"</span>);
<a name="l00122"></a>00122 
<a name="l00123"></a>00123       <span class="keywordflow">if</span> (coder)
<a name="l00124"></a>00124       {
<a name="l00125"></a>00125         <span class="keyword">struct </span>AVCodecContext* codec = retval-&gt;mCodecContext;
<a name="l00126"></a>00126         <span class="keyword">struct </span>AVCodecContext* icodec = coder-&gt;mCodecContext;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         avcodec_copy_context(codec, icodec);
<a name="l00129"></a>00129         <span class="comment">// In FFmpeg r20623 they started defaulting the sample</span>
<a name="l00130"></a>00130         <span class="comment">// format to NONE, but Xuggler uses assume S16, so we</span>
<a name="l00131"></a>00131         <span class="comment">// override that.</span>
<a name="l00132"></a>00132         <span class="keywordflow">if</span> (codec-&gt;sample_fmt == SAMPLE_FMT_NONE)
<a name="l00133"></a>00133           codec-&gt;sample_fmt = SAMPLE_FMT_S16;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         RefPointer&lt;IStream&gt; stream = coder-&gt;getStream();
<a name="l00136"></a>00136         RefPointer&lt;IRational&gt; streamBase = stream ? stream-&gt;getTimeBase() : 0;
<a name="l00137"></a>00137         <span class="keywordtype">double</span> base = streamBase ? streamBase-&gt;getDouble() : 0;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139         <span class="keywordflow">if</span> (base &amp;&amp; av_q2d(icodec-&gt;time_base) * icodec-&gt;ticks_per_frame &gt; base
<a name="l00140"></a>00140             &amp;&amp; base &lt; 1.0 / 1000)
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142           codec-&gt;time_base.num *= icodec-&gt;ticks_per_frame;
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144         <span class="keywordflow">if</span> (!codec-&gt;time_base.num || !codec-&gt;time_base.den)
<a name="l00145"></a>00145         {
<a name="l00146"></a>00146           RefPointer&lt;IRational&gt; iStreamBase = coder-&gt;getTimeBase();
<a name="l00147"></a>00147           <span class="keywordflow">if</span> (iStreamBase)
<a name="l00148"></a>00148           {
<a name="l00149"></a>00149             codec-&gt;time_base.num = iStreamBase-&gt;getNumerator();
<a name="l00150"></a>00150             codec-&gt;time_base.den = iStreamBase-&gt;getDenominator();
<a name="l00151"></a>00151           }
<a name="l00152"></a>00152         }
<a name="l00153"></a>00153         <span class="keywordflow">switch</span> (codec-&gt;codec_type)
<a name="l00154"></a>00154         {
<a name="l00155"></a>00155         <span class="keywordflow">case</span> AVMEDIA_TYPE_AUDIO:
<a name="l00156"></a>00156           <span class="keywordflow">if</span> (codec-&gt;block_align == 1 &amp;&amp; codec-&gt;codec_id == CODEC_ID_MP3)
<a name="l00157"></a>00157             codec-&gt;block_align = 0;
<a name="l00158"></a>00158           <span class="keywordflow">if</span> (codec-&gt;codec_id == CODEC_ID_AC3)
<a name="l00159"></a>00159             codec-&gt;block_align = 0;
<a name="l00160"></a>00160           <span class="keywordflow">break</span>;
<a name="l00161"></a>00161         <span class="keywordflow">default</span>:
<a name="l00162"></a>00162           <span class="keywordflow">break</span>;
<a name="l00163"></a>00163         }
<a name="l00164"></a>00164         <span class="comment">// set the codec to the codec_id</span>
<a name="l00165"></a>00165         ICodec* tempCodec = aCoder-&gt;getCodec();
<a name="l00166"></a>00166         retval-&gt;setCodec(tempCodec);
<a name="l00167"></a>00167         tempCodec-&gt;release();
<a name="l00168"></a>00168       }
<a name="l00169"></a>00169       <span class="keywordflow">else</span>
<a name="l00170"></a>00170       {
<a name="l00171"></a>00171         retval-&gt;mCodecContext-&gt;codec_id = CODEC_ID_PROBE; <span class="comment">// Tell FFMPEG we don't know, but to probe to find out</span>
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (retval-&gt;mCodecContext-&gt;sample_fmt == SAMPLE_FMT_NONE)
<a name="l00173"></a>00173           retval-&gt;mCodecContext-&gt;sample_fmt = SAMPLE_FMT_S16;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 }
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177   }
<a name="l00178"></a>00178   <span class="keywordflow">catch</span> (std::bad_alloc &amp;e)
<a name="l00179"></a>00179   {
<a name="l00180"></a>00180     <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00181"></a>00181     <span class="keywordflow">throw</span> e;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183   <span class="keywordflow">catch</span> (std::exception &amp;e)
<a name="l00184"></a>00184   {
<a name="l00185"></a>00185     <a class="code" href="Logger_8h.html#5c2dd1e8e7e3bc39a9cbf3531cb72eb2">VS_LOG_WARN</a>(<span class="stringliteral">"Error: %s"</span>, e.what());
<a name="l00186"></a>00186     <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188   <span class="keywordflow">return</span> retval;
<a name="l00189"></a>00189 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="256e4138f677f8cb183cc60254182ca5"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setStream" ref="256e4138f677f8cb183cc60254182ca5" args="(Stream *, bool assumeOnlyStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setStream           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assumeOnlyStream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01776">1776</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Stream_8h-source.html#l00079">com::xuggle::xuggler::Stream::getAVStream()</a>.</p>

<p>Referenced by <a class="el" href="Stream_8cpp-source.html#l00277">com::xuggle::xuggler::Stream::setStreamCoder()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01777"></a>01777 {
<a name="l01778"></a>01778   int32_t retval = -1;
<a name="l01779"></a>01779   <span class="keywordflow">if</span> (assumeOnlyStream)
<a name="l01780"></a>01780     mStream = stream;
<a name="l01781"></a>01781   AVStream *avStream = stream ? stream-&gt;getAVStream() : 0;
<a name="l01782"></a>01782   <span class="keywordflow">if</span> (avStream)
<a name="l01783"></a>01783   {
<a name="l01784"></a>01784     <span class="comment">// This handles the case where FFMPEG actually alloced a stream</span>
<a name="l01785"></a>01785     <span class="comment">// codeccontext and thinks it'll free it later when the input</span>
<a name="l01786"></a>01786     <span class="comment">// file closes.  in this case, we free the old value because</span>
<a name="l01787"></a>01787     <span class="comment">// we're about to overwrite it.</span>
<a name="l01788"></a>01788     <span class="keywordflow">if</span> (avStream-&gt;codec)
<a name="l01789"></a>01789       av_free(avStream-&gt;codec);
<a name="l01790"></a>01790     avStream-&gt;codec = mCodecContext;
<a name="l01791"></a>01791   }
<a name="l01792"></a>01792   retval = 0;
<a name="l01793"></a>01793   <span class="keywordflow">return</span> retval;
<a name="l01794"></a>01794 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="877735e5549d26eb3e22c67b11b7b4b3"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::streamClosed" ref="877735e5549d26eb3e22c67b11b7b4b3" args="(Stream *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::streamClosed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01636">1636</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>Referenced by <a class="el" href="Stream_8cpp-source.html#l00189">com::xuggle::xuggler::Stream::containerClosed()</a>, and <a class="el" href="Stream_8cpp-source.html#l00277">com::xuggle::xuggler::Stream::setStreamCoder()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01637"></a>01637 {
<a name="l01638"></a>01638   int32_t retval = 0;
<a name="l01639"></a>01639   <span class="keywordflow">if</span> (stream == mStream)
<a name="l01640"></a>01640   {
<a name="l01641"></a>01641     reset();
<a name="l01642"></a>01642   }
<a name="l01643"></a>01643   <span class="keywordflow">return</span> retval;
<a name="l01644"></a>01644 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dfb0fb4245829c6b69d0199794cbdab0"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getNumDroppedFrames" ref="dfb0fb4245829c6b69d0199794cbdab0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::StreamCoder::getNumDroppedFrames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of frames this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> had to drop to encode at the specified <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448">getTimeBase()</a>. 
<p>
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> objects can encode audio and video, but guarantee that every packet outputted has monotonically increasing timestamps (i.e. 0, 1, 2, 3, 4, 5, etc. without repeats). Sometimes data is passed too quickly into an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> via <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4e8e90c3ba84aab18d7e17379c59c865">encodeVideo</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#81102eae7e5d013057c3a38f9e636cbc">encodeAudio</a>, and the underlying codec can't handle it that quickly. In those cases the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> must drop the most recent frame of data.  <p>
If you're seeing a lot of dropped frames you can try either sending less frequent data to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a>, or adjusting the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448">getTimeBase()</a> to the highest possible resolution. Be warned though; some codecs (such as MPEG2) require fixed time-bases (like 1/25) and so setting a higher resolution time base might end up with the codec not able to encode any data.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of frames dropped. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.1 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#6ed80cd981bef76c4221b1ee2ea8e05d">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01797">1797</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01798"></a>01798 {
<a name="l01799"></a>01799   <span class="keywordflow">return</span> mNumDroppedFrames;
<a name="l01800"></a>01800 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8fb1b9a720ffc81d4cfe813992619239"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setAutomaticallyStampPacketsForStream" ref="8fb1b9a720ffc81d4cfe813992619239" args="(bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::StreamCoder::setAutomaticallyStampPacketsForStream           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for. 
<p>
If this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> does not know which <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is destined for, or this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> isn't used with an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> at all, then this setting is ignored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>true to automatically adjust. </td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#e6ee298bcfd59cc5e462d5d571c1dbe5">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01803">1803</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01804"></a>01804 {
<a name="l01805"></a>01805   <span class="comment">//  VS_LOG_DEBUG("setAutomaticallyStampPacketsForStream: %d", value);</span>
<a name="l01806"></a>01806   mAutomaticallyStampPacketsForStream = value;
<a name="l01807"></a>01807 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cbb4270459aff43a8016d9cffc3ba466"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getAutomaticallyStampPacketsForStream" ref="cbb4270459aff43a8016d9cffc3ba466" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::StreamCoder::getAutomaticallyStampPacketsForStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true for yes; false for no </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>setAutomaticallyStampPacketsForStream(boolean) </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0cd4b393de212b4b7a23ff26ee5830b9">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01810">1810</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01811"></a>01811 {
<a name="l01812"></a>01812   <span class="keywordflow">return</span> mAutomaticallyStampPacketsForStream;
<a name="l01813"></a>01813 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0131a9f0262286143fe03caf5528f860"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::acquire" ref="0131a9f0262286143fe03caf5528f860" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::acquire           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal Only. 
<p>
<b>DO NOT USE FROM JAVA</b>. <p>
Acquire a reference to this object. This increments the native internal ref count in native code by +1.  <p>
This method is called internally by Ferry in Java, and you should not call it without knowing what you are doing. But if you do call it, make sure you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f">release()</a> once for each call you make to this method.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>The refcount after the acquire. Note due to multi-threaded issues, you should not rely on this value, as it may change before the method returns to you. </dd></dl>

<p>Reimplemented from <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#395308babb5ac6d276e138c694d1535c">com::xuggle::ferry::RefCounted</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01648">1648</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="RefCounted_8cpp-source.html#l00063">com::xuggle::ferry::RefCounted::acquire()</a>, and <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01649"></a>01649 {
<a name="l01650"></a>01650   int32_t retval = 0;
<a name="l01651"></a>01651   retval = <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#395308babb5ac6d276e138c694d1535c" title="Internal Only.">RefCounted::acquire</a>();
<a name="l01652"></a>01652   <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Acquired %p: %d"</span>, <span class="keyword">this</span>, retval);
<a name="l01653"></a>01653   <span class="keywordflow">return</span> retval;
<a name="l01654"></a>01654 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1255b6ea6a270ed2391edcb0eab63c5f"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::release" ref="1255b6ea6a270ed2391edcb0eab63c5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal Only. 
<p>
<b>DO NOT USE FROM JAVA</b>. <p>
This decrements the native internal ref count by -1; the object is destroyed if its ref count reaches zero.  <p>
This method is called internally by Ferry in Java, and you should not call it without knowing what you are doing. But if you do call it, make sure you had previously called <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0131a9f0262286143fe03caf5528f860">acquire()</a> once for each call to <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1255b6ea6a270ed2391edcb0eab63c5f">release()</a> you make.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>The ref count after the release. Note due to multi-threaded issues, you should not rely on this value, as it may change before the method returns to you. </dd></dl>

<p>Reimplemented from <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#2b9f941c8693c281e8683bca97704e4d">com::xuggle::ferry::RefCounted</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01657">1657</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="RefCounted_8cpp-source.html#l00070">com::xuggle::ferry::RefCounted::release()</a>, and <a class="el" href="Logger_8h-source.html#l00268">VS_LOG_TRACE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01658"></a>01658 {
<a name="l01659"></a>01659   int32_t retval = 0;
<a name="l01660"></a>01660   retval = <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#2b9f941c8693c281e8683bca97704e4d" title="Internal Only.">RefCounted::release</a>();
<a name="l01661"></a>01661   <a class="code" href="Logger_8h.html#20e4c5462f04bc0531d67e5e7c8051f6">VS_LOG_TRACE</a>(<span class="stringliteral">"Released %p: %d"</span>, <span class="keyword">this</span>, retval);
<a name="l01662"></a>01662   <span class="keywordflow">return</span> retval;
<a name="l01663"></a>01663 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="308231743dc003b0eb2a50b66948c8ca"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::setExtraData" ref="308231743dc003b0eb2a50b66948c8ca" args="(com::xuggle::ferry::IBuffer *src, int32_t offset, int32_t length, bool allocNew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::setExtraData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allocNew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from the given buffer into the extra-data area maintained by encoders. 
<p>
This is an extremely advanced method, and incorrect usage can result in Java crashes so take care. In general people should not need to use this.  <p>
For some codecs (e.g. for H264, this is global header information and for rv10 it is additional flags), Xuggler maintains extra information about the codec in a extra data buffer. In general Xuggler will allocate this data as needed and you never need to set it (or get it). But if you know what you're doing, you can ask Xuggler to replace the existing extra data for the given codec with a copy of the data in the given buffer.  <p>
You should call this method after you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f63b93f7ee8907256f45b1abf1f0dd5d">open()</a> but before you encode or decode any media.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The data to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position, in bytes, to start copying data from src </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to copy from data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocNew</em>&nbsp;</td><td>If true, and there is not enough space in the existing extra data buffer, then Xuggler will discard the old buffer and allocate a new buffer. If false, then Xuggler will attempt to copy the data into the existing buffer and if there is not enough space in the existing buffer, no bytes will be copied and an error will be returned. In general, you should set this to false if that works for you. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes copied, or &lt; 0 on error.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#40b0d59506c404a0d3e55e9e01261d33">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01816">1816</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a">com::xuggle::ferry::IBuffer::getBytes()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01818"></a>01818 {
<a name="l01819"></a>01819   <span class="keywordflow">if</span> (!mCodecContext || !src)
<a name="l01820"></a>01820     <span class="keywordflow">return</span> -1;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822   <span class="keywordtype">void</span>* bytes = src-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a" title="Returns up to length bytes, starting at offset in the underlying buffer we&amp;#39;re...">getBytes</a>(offset, numBytes);
<a name="l01823"></a>01823   <span class="keywordflow">if</span> (!bytes)
<a name="l01824"></a>01824     <span class="keywordflow">return</span> -1;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826   <span class="keywordflow">if</span> (mCodecContext-&gt;extradata_size &lt; numBytes || !mCodecContext-&gt;extradata)
<a name="l01827"></a>01827   {
<a name="l01828"></a>01828     <span class="keywordflow">if</span> (allocNew)
<a name="l01829"></a>01829     {
<a name="l01830"></a>01830       av_free(mCodecContext-&gt;extradata);
<a name="l01831"></a>01831       mCodecContext-&gt;extradata_size = 0;
<a name="l01832"></a>01832       mCodecContext-&gt;extradata = (uint8_t*) av_malloc(numBytes
<a name="l01833"></a>01833           + FF_INPUT_BUFFER_PADDING_SIZE);
<a name="l01834"></a>01834       <span class="keywordflow">if</span> (!mCodecContext-&gt;extradata)
<a name="l01835"></a>01835       {
<a name="l01836"></a>01836         <span class="keywordflow">return</span> -1;
<a name="l01837"></a>01837       }
<a name="l01838"></a>01838       mCodecContext-&gt;extradata_size = numBytes;
<a name="l01839"></a>01839     }
<a name="l01840"></a>01840     <span class="keywordflow">else</span>
<a name="l01841"></a>01841       <span class="keywordflow">return</span> -1;
<a name="l01842"></a>01842   }
<a name="l01843"></a>01843   memcpy(mCodecContext-&gt;extradata, bytes, numBytes);
<a name="l01844"></a>01844   <span class="keywordflow">return</span> numBytes;
<a name="l01845"></a>01845 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b3a67a201a8d07c137d3e3583dbdd1f4"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getExtraData" ref="b3a67a201a8d07c137d3e3583dbdd1f4" args="(com::xuggle::ferry::IBuffer *dest, int32_t offset, int32_t maxBytesToCopy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getExtraData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxBytesToCopy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the current content of the extra-data buffer maintained by this codec (e.g. 
<p>
header bytes) into the dest buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The buffer to copy to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position, in bytes, to start writing data to in dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxBytesToCopy</em>&nbsp;</td><td>The maximum number of bytes to copy. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes copied, or &lt; 0 on error.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#506edb9ae345f485eda9f296f99ac009">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01847">1847</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>

<p>References <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a">com::xuggle::ferry::IBuffer::getBytes()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01849"></a>01849 {
<a name="l01850"></a>01850   <span class="keywordflow">if</span> (!mCodecContext || !mCodecContext-&gt;extradata
<a name="l01851"></a>01851       || mCodecContext-&gt;extradata_size &lt;= 0 || !dest || offset &lt; 0
<a name="l01852"></a>01852       || maxBytesToCopy &lt; 0 || dest-&gt;getSize() &lt; offset + maxBytesToCopy)
<a name="l01853"></a>01853     <span class="keywordflow">return</span> 0;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855   int32_t bytesToCopy = FFMIN(maxBytesToCopy, mCodecContext-&gt;extradata_size);
<a name="l01856"></a>01856   <span class="keywordflow">if</span> (bytesToCopy &lt;= 0)
<a name="l01857"></a>01857     <span class="keywordflow">return</span> 0;
<a name="l01858"></a>01858   <span class="keywordtype">void</span>* bytes = dest-&gt;<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html#1d014bd1ad06d764a0c2fb1b3dcd2d4a" title="Returns up to length bytes, starting at offset in the underlying buffer we&amp;#39;re...">getBytes</a>(offset, bytesToCopy);
<a name="l01859"></a>01859   <span class="keywordflow">if</span> (!bytes)
<a name="l01860"></a>01860     <span class="keywordflow">return</span> 0;
<a name="l01861"></a>01861   memcpy(bytes, mCodecContext-&gt;extradata, bytesToCopy);
<a name="l01862"></a>01862   <span class="keywordflow">return</span> bytesToCopy;
<a name="l01863"></a>01863 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="82786dc6502d13f4d33b4defc7cef81f"></a><!-- doxytag: member="com::xuggle::xuggler::StreamCoder::getExtraDataSize" ref="82786dc6502d13f4d33b4defc7cef81f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::StreamCoder::getExtraDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current number of bytes of data maintained in the coder extra-data area. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes. If 0, then no data is currently available.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#4bad3f363604acec9ad671a9882abada">com::xuggle::xuggler::IStreamCoder</a>.</p>

<p>Definition at line <a class="el" href="StreamCoder_8cpp-source.html#l01866">1866</a> of file <a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01867"></a>01867 {
<a name="l01868"></a>01868   <span class="keywordflow">if</span> (mCodecContext)
<a name="l01869"></a>01869     <span class="keywordflow">return</span> mCodecContext-&gt;extradata_size;
<a name="l01870"></a>01870   <span class="keywordflow">return</span> 0;
<a name="l01871"></a>01871 }
</pre></div>
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>csrc/com/xuggle/xuggler/<a class="el" href="StreamCoder_8h-source.html">StreamCoder.h</a><li>csrc/com/xuggle/xuggler/<a class="el" href="StreamCoder_8cpp-source.html">StreamCoder.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 11 07:40:15 2011 for Xuggle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
