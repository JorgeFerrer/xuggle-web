<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xuggle: com::xuggle::xuggler::IStreamCoder Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecom.html">com</a>::<a class="el" href="namespacecom_1_1xuggle.html">xuggle</a>::<a class="el" href="namespacecom_1_1xuggle_1_1xuggler.html">xuggler</a>::<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a>
  </div>
</div>
<div class="contents">
<h1>com::xuggle::xuggler::IStreamCoder Class Reference</h1><!-- doxytag: class="com::xuggle::xuggler::IStreamCoder" --><!-- doxytag: inherits="com::xuggle::ferry::RefCounted" --><code>#include &lt;<a class="el" href="IStreamCoder_8h-source.html">IStreamCoder.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for com::xuggle::xuggler::IStreamCoder:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder__inherit__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1IStreamCoder__inherit__map" alt="Inheritance graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1IStreamCoder__inherit__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html" title="com::xuggle::xuggler::StreamCoder" alt="" coords="7,162,255,188"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="23,7,239,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for com::xuggle::xuggler::IStreamCoder:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder__coll__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1IStreamCoder__coll__map" alt="Collaboration graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1IStreamCoder__coll__map">
<area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="23,100,239,126"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1AtomicInteger.html" title="Internal only." alt="" coords="15,6,247,33"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The work horse of the Xuggler: Takes <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> data from an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> (representing an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a>) and an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> and allows you to decode or encode that data. 
<p>Definition at line <a class="el" href="IStreamCoder_8h-source.html#l00043">43</a> of file <a class="el" href="IStreamCoder_8h-source.html">IStreamCoder.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> { <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a>, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6">DECODING</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Direction in which this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will work.  <a href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a> { <br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790b5ba77affa50b3f563c1de835aadf1d">FLAG_QSCALE</a> = 0x0002, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790ec6bbf2e3f8109b34d6965a55e95c44">FLAG_4MV</a> = 0x0004, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87949a7588498c33e887697234efb1eea78">FLAG_QPEL</a> = 0x0010, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879a4fd0341ad2bbc161fb2323b05361349">FLAG_GMC</a> = 0x0020, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879137d8098c4df8b742d96176c3f700c9a">FLAG_MV0</a> = 0x0040, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794fb13f83ddb58e8a0da950dee29cf82c">FLAG_PART</a> = 0x0080, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879faa4bf5bb5654c608ee8c213828a06a8">FLAG_INPUT_PRESERVED</a> = 0x0100, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8792376a7b4351d17a81af59d488b311903">FLAG_PASS1</a> = 0x0200, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879da1dd9271336a4923b96a2ce07724e20">FLAG_PASS2</a> = 0x0400, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879de16d8054fd655a2bc0d242664969fd0">FLAG_EXTERN_HUFF</a> = 0x1000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879604016749a1aaa464d527c892c5d73e5">FLAG_GRAY</a> = 0x2000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87982bca59847b219ed498c5b32c9787715">FLAG_EMU_EDGE</a> = 0x4000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879044427ef5ab8727d083cac2448adca62">FLAG_PSNR</a> = 0x8000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879331189b185ba13849ff876111ea673f2">FLAG_TRUNCATED</a> = 0x00010000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87948012cce478a3fea987443d1bc203915">FLAG_NORMALIZE_AQP</a> = 0x00020000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790986ea9985781c4940abeb1647bc9544">FLAG_INTERLACED_DCT</a> = 0x00040000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87926bb157946f80549a09a2b4176185d99">FLAG_LOW_DELAY</a> = 0x00080000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87991ce52afe08088d8b2800807b6933bcc">FLAG_ALT_SCAN</a> = 0x00100000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796ad4676d1e27d942bda614e396d142fb">FLAG_TRELLIS_QUANT</a> = 0x00200000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87983559921c3d9f8ad6f68483e27e50ae6">FLAG_GLOBAL_HEADER</a> = 0x00400000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87914f45b1908b8421be1797ec9e4acbfdb">FLAG_BITEXACT</a> = 0x00800000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794664d5f71e915e52e9ddcf4a87724f6b">FLAG_AC_PRED</a> = 0x01000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87941ac464d9ff56ddcd3833155f6bb184c">FLAG_H263P_UMV</a> = 0x02000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796a766d50b21406c934cba9be3e336b6a">FLAG_CBP_RD</a> = 0x04000000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879e64dd7e26f0e45e3a30318dfcdca5de6">FLAG_QP_RD</a> = 0x08000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87913778bd96ee3822451bba72bd2ff1eed">FLAG_H263P_AIV</a> = 0x00000008, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8791670dbe5caeecca2a9345494d2c7c34d">FLAG_OBMC</a> = 0x00000001, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87974ed4331302ebe605404f8cc902e3e86">FLAG_LOOP_FILTER</a> = 0x00000800, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879105e96e73c7073eaab84989ce60dd8a0">FLAG_H263P_SLICE_STRUCT</a> = 0x10000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879c5c65596cb2da1de27eb16b09512632a">FLAG_INTERLACED_ME</a> = 0x20000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87965fe2f325c48ac298aaf929a34012963">FLAG_SVCD_SCAN_OFFSET</a> = 0x40000000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879ef6e47ba37cec10dd4cef0ff621714bc">FLAG_CLOSED_GOP</a> = 0x80000000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796c7fb2ce0c7ad666bce1be3769152016">FLAG2_FAST</a> = 0x00000001, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798d8a0a67a8a9bcd07648fb505a95f427">FLAG2_STRICT_GOP</a> = 0x00000002, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879db761261af564fe35267e8bfd5e8bb35">FLAG2_NO_OUTPUT</a> = 0x00000004, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87948ad452ffe5243718ea6b1a6b6484df3">FLAG2_LOCAL_HEADER</a> = 0x00000008, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790f433c6717d4f77429f367b06ab8b039">FLAG2_BPYRAMID</a> = 0x00000010, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879a194205e5e6377e390a07b01d554c6b4">FLAG2_WPRED</a> = 0x00000020, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794c7f68946aec0f28b13983e511d5c4f0">FLAG2_MIXED_REFS</a> = 0x00000040, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8793e65e92cc90db94d23cb434257cae67a">FLAG2_8X8DCT</a> = 0x00000080, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798388b48a314e3399fe8ffc655888a984">FLAG2_FASTPSKIP</a> = 0x00000100, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879768e526b734655d7cfd788a2583bb0af">FLAG2_AUD</a> = 0x00000200, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879412e9759c3f63ef5e96b2f1f5dc9f757">FLAG2_BRDO</a> = 0x00000400, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879c7267e6d934987b11fa262f0da1d82d1">FLAG2_INTRA_VLC</a> = 0x00000800, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798cfca8988e1d1f6059c7aa831464d9b3">FLAG2_MEMC_ONLY</a> = 0x00001000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879bdf5bc9565154beb0cc150318aca9d27">FLAG2_DROP_FRAME_TIMECODE</a> = 0x00002000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798dd8a5684263fe8a5a4373e45acd74d0">FLAG2_SKIP_RD</a> = 0x00004000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879194beaf917f8883cca395fcdc99fdef5">FLAG2_CHUNKS</a> = 0x00008000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8797f9e209b5d2dbb95775fb9a4fbe0f480">FLAG2_NON_LINEAR_QUANT</a> = 0x00010000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879b8d674310e24c1b1c6bb1a6ec2836bfe">FLAG2_BIT_RESERVOIR</a> = 0x00020000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87909c486748f5f3f7599d7b3168dfbfb38">FLAG2_MBTREE</a> = 0x00040000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879d73c50803519ff0425d910d32d445165">FLAG2_PSY</a> = 0x00080000, 
<br>
&nbsp;&nbsp;<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879bb9e422911a368aac3cd22ee41ffed3c">FLAG2_SSIM</a> = 0x00100000, 
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8793d1624c1c870df3c3f9eb631032ac9f8">FLAG2_INTRA_REFRESH</a> = 0x00200000
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">XUGGLER Flags that can be passed to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b484b81ddb23803694376582ebc63dcc" title="Set the flag.">setFlag(Flags, bool)</a> method.  <a href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef enum <br>
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">com::xuggle::xuggler::IStreamCoder::Direction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#59101e45bd3373af53b0db12cff58f2f">Direction</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b508aae561f4617d9871b4dabd71a2e1">getDirection</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the direction.  <a href="#b508aae561f4617d9871b4dabd71a2e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3193aeab178e76155937dc4bf934fb21">getStream</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The associated <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> we're working on.  <a href="#3193aeab178e76155937dc4bf934fb21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388">getCodec</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will use.  <a href="#56aabe726714456ec95c0bd979b48388"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4">ICodec::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#731f039e513526ee80766a7f583cd083">getCodecType</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a>.getType().  <a href="#731f039e513526ee80766a7f583cd083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7ada56e38b03a00aa3a032b2334ab0fc">getCodecID</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a>.getID().  <a href="#7ada56e38b03a00aa3a032b2334ab0fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#48f1f4b8179f54921de7ecba9ced0b8d">setCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *codec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to the passed in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a>, discarding the old <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> if set.  <a href="#48f1f4b8179f54921de7ecba9ced0b8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#4becff2779c996a1c4c546742a616add">setCodec</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it.  <a href="#4becff2779c996a1c4c546742a616add"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#721d05712a3bbadb4e9cb296c31f06c5">getBitRate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bit rate.  <a href="#721d05712a3bbadb4e9cb296c31f06c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d7e0d1ab0062890a09d16520eac7f7fb">setBitRate</a> (int32_t rate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When ENCODING, sets the bit rate to use.  <a href="#d7e0d1ab0062890a09d16520eac7f7fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0daab96eace6c53c2fef0e76f0893400">getBitRateTolerance</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bit rate tolerance.  <a href="#0daab96eace6c53c2fef0e76f0893400"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#730d5312efc1f4c3d75a495781824618">setBitRateTolerance</a> (int32_t tolerance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When ENCODING set the bit rate tolerance.  <a href="#730d5312efc1f4c3d75a495781824618"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#30d036216176596621aa86988366b498">getHeight</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The height, in pixels.  <a href="#30d036216176596621aa86988366b498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#934fbd205a2f93b0eae1ebf309ab88ea">setHeight</a> (int32_t height)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the height, in pixels.  <a href="#934fbd205a2f93b0eae1ebf309ab88ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#833b9a4f028740f5d5829de0c70d2208">getWidth</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The width, in pixels.  <a href="#833b9a4f028740f5d5829de0c70d2208"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b6c9be1de92dfa7e4f8a12c552a5a7c9">setWidth</a> (int32_t width)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the width, in pixels.  <a href="#b6c9be1de92dfa7e4f8a12c552a5a7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea">getTimeBase</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time base this stream will ENCODE in, or the time base we detect while DECODING.  <a href="#bba258ddaba01511e28560f59d6757ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b2d539f28acdf1b569dfc6a8602bf5ae">setTimeBase</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *newTimeBase)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the time base we'll use to ENCODE with.  <a href="#b2d539f28acdf1b569dfc6a8602bf5ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#f9f2c9b61bf00102711d42fa4b86eb9b">getFrameRate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate we'll claim we're using when ENCODING.  <a href="#f9f2c9b61bf00102711d42fa4b86eb9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3fdbe34d0a17f1a65b506bd4e678bfd6">setFrameRate</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *newFrameRate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the frame rate we'll set in the headers of this stream while ENCODING.  <a href="#3fdbe34d0a17f1a65b506bd4e678bfd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bb1cdc689646b3599267bbc0ea42f646">getNumPicturesInGroupOfPictures</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The the number of pictures in this Group of Pictures (GOP).  <a href="#bb1cdc689646b3599267bbc0ea42f646"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d7efb17b72661318751f73bf3d890d5a">setNumPicturesInGroupOfPictures</a> (int32_t gops)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the GOPS on this stream.  <a href="#d7efb17b72661318751f73bf3d890d5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#3b014e161a955d302d03fac3d39a5d37">getPixelType</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For Video streams, get the Pixel Format in use by the stream.  <a href="#3b014e161a955d302d03fac3d39a5d37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c3a41a11704b3c0abb8b6e55d9f57eb3">setPixelType</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a> pixelFmt)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pixel format to ENCODE with.  <a href="#c3a41a11704b3c0abb8b6e55d9f57eb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#554e763894f9274d0fcb9a3f3d51c632">getSampleRate</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sample rate we use for this stream.  <a href="#554e763894f9274d0fcb9a3f3d51c632"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#fd3688dc5215dbb7e1d9e68f1ce2ddb6">setSampleRate</a> (int32_t sampleRate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sample rate to use when ENCODING.  <a href="#fd3688dc5215dbb7e1d9e68f1ce2ddb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#87b8ea7de46bfc8606f2414235983f5c">getSampleFormat</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the audio sample format.  <a href="#87b8ea7de46bfc8606f2414235983f5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#2264cb4521e09417588444d68ead4daa">setSampleFormat</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a> aFormat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sample format when ENCODING.  <a href="#2264cb4521e09417588444d68ead4daa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#9a7316327de43f4f6e8c991a386ee3e0">getChannels</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of channels in this audio stream.  <a href="#9a7316327de43f4f6e8c991a386ee3e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#eb351995ac5cac009e37535c31bfa32b">setChannels</a> (int32_t channels)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of channels to use when ENCODING.  <a href="#eb351995ac5cac009e37535c31bfa32b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0d55705562c299cb8c1eeff383b94128">getAudioFrameSize</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For this stream, get the number of audio samples that are represented in a packet of information.  <a href="#0d55705562c299cb8c1eeff383b94128"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#85940f0d668670d37d624515ee52110a">getGlobalQuality</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality setting this codec uses for video if a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> doesn't have a quality set.  <a href="#85940f0d668670d37d624515ee52110a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0cc039ca3dbf242e8f5bb8c1f785623d">setGlobalQuality</a> (int32_t newQuality)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality to a new value.  <a href="#0cc039ca3dbf242e8f5bb8c1f785623d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#70815810fd45c4b35a2e8bb46ca55936">getFlags</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flags associated with this codec.  <a href="#70815810fd45c4b35a2e8bb46ca55936"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#1b758ae82cb98f8a8168de4883e9dcd1">setFlags</a> (int32_t newFlags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the FFMPEG flags to use with this codec.  <a href="#1b758ae82cb98f8a8168de4883e9dcd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ba73e8620429bd95f4de9f3b09ea2807">getFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a> flag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the setting for the specified flag.  <a href="#ba73e8620429bd95f4de9f3b09ea2807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b484b81ddb23803694376582ebc63dcc">setFlag</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the flag.  <a href="#b484b81ddb23803694376582ebc63dcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#faa50862ae1188ac20ae10539aefce5c">getNextPredictedPts</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For this stream, get the next Pts that we expect to decode.  <a href="#faa50862ae1188ac20ae10539aefce5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ecbfccf54f0b4aa1efd9c029891bb398">open</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> associated with this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#ecbfccf54f0b4aa1efd9c029891bb398"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b">close</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> that was opened on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#7618833932c24a8f2962290ab6c8449b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#97801fddf4414d619b712fdcbac8940d">decodeAudio</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *pOutSamples, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, int32_t byteOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode this packet into pOutSamples.  <a href="#97801fddf4414d619b712fdcbac8940d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#a8fc7f0842531be95981457761adb7b9">decodeVideo</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *pOutFrame, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *packet, int32_t byteOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode this packet into pOutFrame.  <a href="#a8fc7f0842531be95981457761adb7b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d39b98a68e86cbe889b98a053bfc9230">encodeVideo</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *pOutPacket, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *pFrame, int32_t suggestedBufferSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode the given frame using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#d39b98a68e86cbe889b98a053bfc9230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c47164283b3bfa882e32592ace086206">encodeAudio</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *pOutPacket, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *pSamples, uint32_t sampleToStartFrom)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encode the given samples using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>.  <a href="#c47164283b3bfa882e32592ace086206"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ca7adbeb0262af0e9d368cac4cdd7759">getCodecTag</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the 4-byte FOURCC tag (Least Significant Byte first).  <a href="#ca7adbeb0262af0e9d368cac4cdd7759"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#e84f341deb602fc8a093ceb4dd071019">setCodecTag</a> (int32_t fourcc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the 4-byte FOURCC tag for this coder.  <a href="#e84f341deb602fc8a093ceb4dd071019"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#9b8475c809d1a5684a987f4d74789b17">getNumProperties</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of settable properties on this object.  <a href="#9b8475c809d1a5684a987f4d74789b17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ccd97f0e68e28c74b31d6fad9edcf2d5">getPropertyMetaData</a> (int32_t propertyNo)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#ccd97f0e68e28c74b31d6fad9edcf2d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#1092cf8f25a60f0cf41f3762c34a272b">getPropertyMetaData</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the numbered property.  <a href="#1092cf8f25a60f0cf41f3762c34a272b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c4dd45fb064dbcbb4a87f909f31fbaa0">setProperty</a> (const char *name, const char *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a property on this Object.  <a href="#c4dd45fb064dbcbb4a87f909f31fbaa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#25c22b581ba91e0879e217ddc6683705">setProperty</a> (const char *name, double value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#25c22b581ba91e0879e217ddc6683705"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#2fe9345b2139cd51dae0e34150363aa4">setProperty</a> (const char *name, int64_t value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#2fe9345b2139cd51dae0e34150363aa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#fe37876b910d67ade52eecf582b8d1fe">setProperty</a> (const char *name, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#fe37876b910d67ade52eecf582b8d1fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#218c9b5b0dff04d90962ec87352096fd">setProperty</a> (const char *name, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up the property 'name' and sets the value of the property to 'value'.  <a href="#218c9b5b0dff04d90962ec87352096fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0a292d948b0b2dbaf8f2b1c34be7a01a">getPropertyAsString</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a property on this Object.  <a href="#0a292d948b0b2dbaf8f2b1c34be7a01a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c25f79946060059ee021bce8bc05bc4b">getPropertyAsDouble</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a double;.  <a href="#c25f79946060059ee021bce8bc05bc4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#82634d367c065b096cbb224d6caa5a15">getPropertyAsLong</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an long;.  <a href="#82634d367c065b096cbb224d6caa5a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#8c570c4ea02459a2be7225e9d022ff15">getPropertyAsRational</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;.  <a href="#8c570c4ea02459a2be7225e9d022ff15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c64d752357de5237693281b854f927d6">getPropertyAsBoolean</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of this property, and returns as a boolean.  <a href="#c64d752357de5237693281b854f927d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c9befe352247818b4e0fddafb4764f1a">isOpen</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> is currently open.  <a href="#c9befe352247818b4e0fddafb4764f1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#6e2b6aa60e6f05952bfa12d6def2d33f">getDefaultAudioFrameSize</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default audio frame size (in samples).  <a href="#6e2b6aa60e6f05952bfa12d6def2d33f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#dc9c7510ce5706e3cc1f38cfb04883b5">setDefaultAudioFrameSize</a> (int32_t aNewSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default audio frame size.  <a href="#dc9c7510ce5706e3cc1f38cfb04883b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#6ed80cd981bef76c4221b1ee2ea8e05d">getNumDroppedFrames</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of frames this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> had to drop to encode at the specified <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea">getTimeBase()</a>.  <a href="#6ed80cd981bef76c4221b1ee2ea8e05d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#e6ee298bcfd59cc5e462d5d571c1dbe5">setAutomaticallyStampPacketsForStream</a> (bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for.  <a href="#e6ee298bcfd59cc5e462d5d571c1dbe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0cd4b393de212b4b7a23ff26ee5830b9">getAutomaticallyStampPacketsForStream</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for.  <a href="#0cd4b393de212b4b7a23ff26ee5830b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#45a4e37591aabf5e12cb78b2b154fc44">setCodecID</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> id)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it.  <a href="#45a4e37591aabf5e12cb78b2b154fc44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#40b0d59506c404a0d3e55e9e01261d33">setExtraData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *src, int32_t offset, int32_t length, bool allocNew)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies data from the given buffer into the extra-data area maintained by encoders.  <a href="#40b0d59506c404a0d3e55e9e01261d33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#506edb9ae345f485eda9f296f99ac009">getExtraData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *dest, int32_t offset, int32_t maxBytesToCopy)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the current content of the extra-data buffer maintained by this codec (e.g.  <a href="#506edb9ae345f485eda9f296f99ac009"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#4bad3f363604acec9ad671a9882abada">getExtraDataSize</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current number of bytes of data maintained in the coder extra-data area.  <a href="#4bad3f363604acec9ad671a9882abada"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#0055d9571962191f1f05670d6ffd406e">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> direction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a standalone <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that can decode data without regard to which <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer.">IStream</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> it came from.  <a href="#0055d9571962191f1f05670d6ffd406e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#46d0877a0a9f9725d6c459e803c15aa1">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> direction, <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *copyCoder)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> object by copying all the settings in copyCoder.  <a href="#46d0877a0a9f9725d6c459e803c15aa1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#19df5af4ba269de43b87898e2897c223">IStreamCoder</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#88de1bf057891787998b45a774f41ed3">~IStreamCoder</a> ()</td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="59101e45bd3373af53b0db12cff58f2f"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::Direction" ref="59101e45bd3373af53b0db12cff58f2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">com::xuggle::xuggler::IStreamCoder::Direction</a>  <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">com::xuggle::xuggler::IStreamCoder::Direction</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="89070b18b2b728e7c93a73fb65a15099"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::Direction" ref="89070b18b2b728e7c93a73fb65a15099" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">com::xuggle::xuggler::IStreamCoder::Direction</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The Direction in which this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will work. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3"></a><!-- doxytag: member="ENCODING" ref="89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3" args="" -->ENCODING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6"></a><!-- doxytag: member="DECODING" ref="89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6" args="" -->DECODING</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="IStreamCoder_8h-source.html#l00050">50</a> of file <a class="el" href="IStreamCoder_8h-source.html">IStreamCoder.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00051"></a>00051     {
<a name="l00052"></a>00052       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a150997f0497720020c6ccad07dfb4c8f336c3">ENCODING</a>,
<a name="l00053"></a>00053       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099160bc1d2f07eab7cfa28a62dc733e7e6">DECODING</a>
<a name="l00054"></a>00054     } <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099" title="The Direction in which this StreamCoder will work.">Direction</a>;
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7f129ebbe404af47858199c929d0d879"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::Flags" ref="7f129ebbe404af47858199c929d0d879" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">com::xuggle::xuggler::IStreamCoder::Flags</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XUGGLER Flags that can be passed to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#b484b81ddb23803694376582ebc63dcc" title="Set the flag.">setFlag(Flags, bool)</a> method. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8790b5ba77affa50b3f563c1de835aadf1d"></a><!-- doxytag: member="FLAG_QSCALE" ref="7f129ebbe404af47858199c929d0d8790b5ba77affa50b3f563c1de835aadf1d" args="" -->FLAG_QSCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8790ec6bbf2e3f8109b34d6965a55e95c44"></a><!-- doxytag: member="FLAG_4MV" ref="7f129ebbe404af47858199c929d0d8790ec6bbf2e3f8109b34d6965a55e95c44" args="" -->FLAG_4MV</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87949a7588498c33e887697234efb1eea78"></a><!-- doxytag: member="FLAG_QPEL" ref="7f129ebbe404af47858199c929d0d87949a7588498c33e887697234efb1eea78" args="" -->FLAG_QPEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879a4fd0341ad2bbc161fb2323b05361349"></a><!-- doxytag: member="FLAG_GMC" ref="7f129ebbe404af47858199c929d0d879a4fd0341ad2bbc161fb2323b05361349" args="" -->FLAG_GMC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879137d8098c4df8b742d96176c3f700c9a"></a><!-- doxytag: member="FLAG_MV0" ref="7f129ebbe404af47858199c929d0d879137d8098c4df8b742d96176c3f700c9a" args="" -->FLAG_MV0</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8794fb13f83ddb58e8a0da950dee29cf82c"></a><!-- doxytag: member="FLAG_PART" ref="7f129ebbe404af47858199c929d0d8794fb13f83ddb58e8a0da950dee29cf82c" args="" -->FLAG_PART</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879faa4bf5bb5654c608ee8c213828a06a8"></a><!-- doxytag: member="FLAG_INPUT_PRESERVED" ref="7f129ebbe404af47858199c929d0d879faa4bf5bb5654c608ee8c213828a06a8" args="" -->FLAG_INPUT_PRESERVED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8792376a7b4351d17a81af59d488b311903"></a><!-- doxytag: member="FLAG_PASS1" ref="7f129ebbe404af47858199c929d0d8792376a7b4351d17a81af59d488b311903" args="" -->FLAG_PASS1</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879da1dd9271336a4923b96a2ce07724e20"></a><!-- doxytag: member="FLAG_PASS2" ref="7f129ebbe404af47858199c929d0d879da1dd9271336a4923b96a2ce07724e20" args="" -->FLAG_PASS2</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879de16d8054fd655a2bc0d242664969fd0"></a><!-- doxytag: member="FLAG_EXTERN_HUFF" ref="7f129ebbe404af47858199c929d0d879de16d8054fd655a2bc0d242664969fd0" args="" -->FLAG_EXTERN_HUFF</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879604016749a1aaa464d527c892c5d73e5"></a><!-- doxytag: member="FLAG_GRAY" ref="7f129ebbe404af47858199c929d0d879604016749a1aaa464d527c892c5d73e5" args="" -->FLAG_GRAY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87982bca59847b219ed498c5b32c9787715"></a><!-- doxytag: member="FLAG_EMU_EDGE" ref="7f129ebbe404af47858199c929d0d87982bca59847b219ed498c5b32c9787715" args="" -->FLAG_EMU_EDGE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879044427ef5ab8727d083cac2448adca62"></a><!-- doxytag: member="FLAG_PSNR" ref="7f129ebbe404af47858199c929d0d879044427ef5ab8727d083cac2448adca62" args="" -->FLAG_PSNR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879331189b185ba13849ff876111ea673f2"></a><!-- doxytag: member="FLAG_TRUNCATED" ref="7f129ebbe404af47858199c929d0d879331189b185ba13849ff876111ea673f2" args="" -->FLAG_TRUNCATED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87948012cce478a3fea987443d1bc203915"></a><!-- doxytag: member="FLAG_NORMALIZE_AQP" ref="7f129ebbe404af47858199c929d0d87948012cce478a3fea987443d1bc203915" args="" -->FLAG_NORMALIZE_AQP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8790986ea9985781c4940abeb1647bc9544"></a><!-- doxytag: member="FLAG_INTERLACED_DCT" ref="7f129ebbe404af47858199c929d0d8790986ea9985781c4940abeb1647bc9544" args="" -->FLAG_INTERLACED_DCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87926bb157946f80549a09a2b4176185d99"></a><!-- doxytag: member="FLAG_LOW_DELAY" ref="7f129ebbe404af47858199c929d0d87926bb157946f80549a09a2b4176185d99" args="" -->FLAG_LOW_DELAY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87991ce52afe08088d8b2800807b6933bcc"></a><!-- doxytag: member="FLAG_ALT_SCAN" ref="7f129ebbe404af47858199c929d0d87991ce52afe08088d8b2800807b6933bcc" args="" -->FLAG_ALT_SCAN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8796ad4676d1e27d942bda614e396d142fb"></a><!-- doxytag: member="FLAG_TRELLIS_QUANT" ref="7f129ebbe404af47858199c929d0d8796ad4676d1e27d942bda614e396d142fb" args="" -->FLAG_TRELLIS_QUANT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87983559921c3d9f8ad6f68483e27e50ae6"></a><!-- doxytag: member="FLAG_GLOBAL_HEADER" ref="7f129ebbe404af47858199c929d0d87983559921c3d9f8ad6f68483e27e50ae6" args="" -->FLAG_GLOBAL_HEADER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87914f45b1908b8421be1797ec9e4acbfdb"></a><!-- doxytag: member="FLAG_BITEXACT" ref="7f129ebbe404af47858199c929d0d87914f45b1908b8421be1797ec9e4acbfdb" args="" -->FLAG_BITEXACT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8794664d5f71e915e52e9ddcf4a87724f6b"></a><!-- doxytag: member="FLAG_AC_PRED" ref="7f129ebbe404af47858199c929d0d8794664d5f71e915e52e9ddcf4a87724f6b" args="" -->FLAG_AC_PRED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87941ac464d9ff56ddcd3833155f6bb184c"></a><!-- doxytag: member="FLAG_H263P_UMV" ref="7f129ebbe404af47858199c929d0d87941ac464d9ff56ddcd3833155f6bb184c" args="" -->FLAG_H263P_UMV</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8796a766d50b21406c934cba9be3e336b6a"></a><!-- doxytag: member="FLAG_CBP_RD" ref="7f129ebbe404af47858199c929d0d8796a766d50b21406c934cba9be3e336b6a" args="" -->FLAG_CBP_RD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879e64dd7e26f0e45e3a30318dfcdca5de6"></a><!-- doxytag: member="FLAG_QP_RD" ref="7f129ebbe404af47858199c929d0d879e64dd7e26f0e45e3a30318dfcdca5de6" args="" -->FLAG_QP_RD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87913778bd96ee3822451bba72bd2ff1eed"></a><!-- doxytag: member="FLAG_H263P_AIV" ref="7f129ebbe404af47858199c929d0d87913778bd96ee3822451bba72bd2ff1eed" args="" -->FLAG_H263P_AIV</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8791670dbe5caeecca2a9345494d2c7c34d"></a><!-- doxytag: member="FLAG_OBMC" ref="7f129ebbe404af47858199c929d0d8791670dbe5caeecca2a9345494d2c7c34d" args="" -->FLAG_OBMC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87974ed4331302ebe605404f8cc902e3e86"></a><!-- doxytag: member="FLAG_LOOP_FILTER" ref="7f129ebbe404af47858199c929d0d87974ed4331302ebe605404f8cc902e3e86" args="" -->FLAG_LOOP_FILTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879105e96e73c7073eaab84989ce60dd8a0"></a><!-- doxytag: member="FLAG_H263P_SLICE_STRUCT" ref="7f129ebbe404af47858199c929d0d879105e96e73c7073eaab84989ce60dd8a0" args="" -->FLAG_H263P_SLICE_STRUCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879c5c65596cb2da1de27eb16b09512632a"></a><!-- doxytag: member="FLAG_INTERLACED_ME" ref="7f129ebbe404af47858199c929d0d879c5c65596cb2da1de27eb16b09512632a" args="" -->FLAG_INTERLACED_ME</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87965fe2f325c48ac298aaf929a34012963"></a><!-- doxytag: member="FLAG_SVCD_SCAN_OFFSET" ref="7f129ebbe404af47858199c929d0d87965fe2f325c48ac298aaf929a34012963" args="" -->FLAG_SVCD_SCAN_OFFSET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879ef6e47ba37cec10dd4cef0ff621714bc"></a><!-- doxytag: member="FLAG_CLOSED_GOP" ref="7f129ebbe404af47858199c929d0d879ef6e47ba37cec10dd4cef0ff621714bc" args="" -->FLAG_CLOSED_GOP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8796c7fb2ce0c7ad666bce1be3769152016"></a><!-- doxytag: member="FLAG2_FAST" ref="7f129ebbe404af47858199c929d0d8796c7fb2ce0c7ad666bce1be3769152016" args="" -->FLAG2_FAST</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8798d8a0a67a8a9bcd07648fb505a95f427"></a><!-- doxytag: member="FLAG2_STRICT_GOP" ref="7f129ebbe404af47858199c929d0d8798d8a0a67a8a9bcd07648fb505a95f427" args="" -->FLAG2_STRICT_GOP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879db761261af564fe35267e8bfd5e8bb35"></a><!-- doxytag: member="FLAG2_NO_OUTPUT" ref="7f129ebbe404af47858199c929d0d879db761261af564fe35267e8bfd5e8bb35" args="" -->FLAG2_NO_OUTPUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87948ad452ffe5243718ea6b1a6b6484df3"></a><!-- doxytag: member="FLAG2_LOCAL_HEADER" ref="7f129ebbe404af47858199c929d0d87948ad452ffe5243718ea6b1a6b6484df3" args="" -->FLAG2_LOCAL_HEADER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8790f433c6717d4f77429f367b06ab8b039"></a><!-- doxytag: member="FLAG2_BPYRAMID" ref="7f129ebbe404af47858199c929d0d8790f433c6717d4f77429f367b06ab8b039" args="" -->FLAG2_BPYRAMID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879a194205e5e6377e390a07b01d554c6b4"></a><!-- doxytag: member="FLAG2_WPRED" ref="7f129ebbe404af47858199c929d0d879a194205e5e6377e390a07b01d554c6b4" args="" -->FLAG2_WPRED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8794c7f68946aec0f28b13983e511d5c4f0"></a><!-- doxytag: member="FLAG2_MIXED_REFS" ref="7f129ebbe404af47858199c929d0d8794c7f68946aec0f28b13983e511d5c4f0" args="" -->FLAG2_MIXED_REFS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8793e65e92cc90db94d23cb434257cae67a"></a><!-- doxytag: member="FLAG2_8X8DCT" ref="7f129ebbe404af47858199c929d0d8793e65e92cc90db94d23cb434257cae67a" args="" -->FLAG2_8X8DCT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8798388b48a314e3399fe8ffc655888a984"></a><!-- doxytag: member="FLAG2_FASTPSKIP" ref="7f129ebbe404af47858199c929d0d8798388b48a314e3399fe8ffc655888a984" args="" -->FLAG2_FASTPSKIP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879768e526b734655d7cfd788a2583bb0af"></a><!-- doxytag: member="FLAG2_AUD" ref="7f129ebbe404af47858199c929d0d879768e526b734655d7cfd788a2583bb0af" args="" -->FLAG2_AUD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879412e9759c3f63ef5e96b2f1f5dc9f757"></a><!-- doxytag: member="FLAG2_BRDO" ref="7f129ebbe404af47858199c929d0d879412e9759c3f63ef5e96b2f1f5dc9f757" args="" -->FLAG2_BRDO</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879c7267e6d934987b11fa262f0da1d82d1"></a><!-- doxytag: member="FLAG2_INTRA_VLC" ref="7f129ebbe404af47858199c929d0d879c7267e6d934987b11fa262f0da1d82d1" args="" -->FLAG2_INTRA_VLC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8798cfca8988e1d1f6059c7aa831464d9b3"></a><!-- doxytag: member="FLAG2_MEMC_ONLY" ref="7f129ebbe404af47858199c929d0d8798cfca8988e1d1f6059c7aa831464d9b3" args="" -->FLAG2_MEMC_ONLY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879bdf5bc9565154beb0cc150318aca9d27"></a><!-- doxytag: member="FLAG2_DROP_FRAME_TIMECODE" ref="7f129ebbe404af47858199c929d0d879bdf5bc9565154beb0cc150318aca9d27" args="" -->FLAG2_DROP_FRAME_TIMECODE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8798dd8a5684263fe8a5a4373e45acd74d0"></a><!-- doxytag: member="FLAG2_SKIP_RD" ref="7f129ebbe404af47858199c929d0d8798dd8a5684263fe8a5a4373e45acd74d0" args="" -->FLAG2_SKIP_RD</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879194beaf917f8883cca395fcdc99fdef5"></a><!-- doxytag: member="FLAG2_CHUNKS" ref="7f129ebbe404af47858199c929d0d879194beaf917f8883cca395fcdc99fdef5" args="" -->FLAG2_CHUNKS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8797f9e209b5d2dbb95775fb9a4fbe0f480"></a><!-- doxytag: member="FLAG2_NON_LINEAR_QUANT" ref="7f129ebbe404af47858199c929d0d8797f9e209b5d2dbb95775fb9a4fbe0f480" args="" -->FLAG2_NON_LINEAR_QUANT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879b8d674310e24c1b1c6bb1a6ec2836bfe"></a><!-- doxytag: member="FLAG2_BIT_RESERVOIR" ref="7f129ebbe404af47858199c929d0d879b8d674310e24c1b1c6bb1a6ec2836bfe" args="" -->FLAG2_BIT_RESERVOIR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d87909c486748f5f3f7599d7b3168dfbfb38"></a><!-- doxytag: member="FLAG2_MBTREE" ref="7f129ebbe404af47858199c929d0d87909c486748f5f3f7599d7b3168dfbfb38" args="" -->FLAG2_MBTREE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879d73c50803519ff0425d910d32d445165"></a><!-- doxytag: member="FLAG2_PSY" ref="7f129ebbe404af47858199c929d0d879d73c50803519ff0425d910d32d445165" args="" -->FLAG2_PSY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d879bb9e422911a368aac3cd22ee41ffed3c"></a><!-- doxytag: member="FLAG2_SSIM" ref="7f129ebbe404af47858199c929d0d879bb9e422911a368aac3cd22ee41ffed3c" args="" -->FLAG2_SSIM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f129ebbe404af47858199c929d0d8793d1624c1c870df3c3f9eb631032ac9f8"></a><!-- doxytag: member="FLAG2_INTRA_REFRESH" ref="7f129ebbe404af47858199c929d0d8793d1624c1c870df3c3f9eb631032ac9f8" args="" -->FLAG2_INTRA_REFRESH</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="IStreamCoder_8h-source.html#l00059">59</a> of file <a class="el" href="IStreamCoder_8h-source.html">IStreamCoder.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00059"></a>00059                  {
<a name="l00060"></a>00060       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790b5ba77affa50b3f563c1de835aadf1d">FLAG_QSCALE</a> =0x0002,  <span class="comment">// Use fixed qscale.</span>
<a name="l00061"></a>00061       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790ec6bbf2e3f8109b34d6965a55e95c44">FLAG_4MV</a>    =0x0004,  <span class="comment">// 4 MV per MB allowed / advanced prediction for H.263.</span>
<a name="l00062"></a>00062       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87949a7588498c33e887697234efb1eea78">FLAG_QPEL</a>   =0x0010,  <span class="comment">// Use qpel MC.</span>
<a name="l00063"></a>00063       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879a4fd0341ad2bbc161fb2323b05361349">FLAG_GMC</a>    =0x0020,  <span class="comment">// Use GMC.</span>
<a name="l00064"></a>00064       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879137d8098c4df8b742d96176c3f700c9a">FLAG_MV0</a>    =0x0040,  <span class="comment">// Always try a MB with MV=&lt;0,0&gt;.</span>
<a name="l00065"></a>00065       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794fb13f83ddb58e8a0da950dee29cf82c">FLAG_PART</a>   =0x0080,  <span class="comment">// Use data partitioning.</span>
<a name="l00066"></a>00066       <span class="comment">/*</span>
<a name="l00067"></a>00067 <span class="comment">       * The parent program must guarantee that the input for B-frames containing</span>
<a name="l00068"></a>00068 <span class="comment">       * streams is not written to for at least s-&gt;max_b_frames+1 frames, if</span>
<a name="l00069"></a>00069 <span class="comment">       * this is not set the input will be copied.</span>
<a name="l00070"></a>00070 <span class="comment">       */</span>
<a name="l00071"></a>00071       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879faa4bf5bb5654c608ee8c213828a06a8">FLAG_INPUT_PRESERVED</a> =0x0100,
<a name="l00072"></a>00072       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8792376a7b4351d17a81af59d488b311903">FLAG_PASS1</a>           =0x0200,   <span class="comment">// Use internal 2pass ratecontrol in first pass mode.</span>
<a name="l00073"></a>00073       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879da1dd9271336a4923b96a2ce07724e20">FLAG_PASS2</a>           =0x0400,   <span class="comment">// Use internal 2pass ratecontrol in second pass mode.</span>
<a name="l00074"></a>00074       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879de16d8054fd655a2bc0d242664969fd0">FLAG_EXTERN_HUFF</a>     =0x1000,   <span class="comment">// Use external Huffman table (for MJPEG).</span>
<a name="l00075"></a>00075       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879604016749a1aaa464d527c892c5d73e5">FLAG_GRAY</a>            =0x2000,   <span class="comment">// Only decode/encode grayscale.</span>
<a name="l00076"></a>00076       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87982bca59847b219ed498c5b32c9787715">FLAG_EMU_EDGE</a>        =0x4000,   <span class="comment">// Don't draw edges.</span>
<a name="l00077"></a>00077       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879044427ef5ab8727d083cac2448adca62">FLAG_PSNR</a>            =0x8000,   <span class="comment">// error[?] variables will be set during encoding.</span>
<a name="l00078"></a>00078       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879331189b185ba13849ff876111ea673f2">FLAG_TRUNCATED</a>       =0x00010000, <span class="comment">/* Input bitstream might be truncated at a random</span>
<a name="l00079"></a>00079 <span class="comment">                                                  location instead of only at frame boundaries. */</span>
<a name="l00080"></a>00080       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87948012cce478a3fea987443d1bc203915">FLAG_NORMALIZE_AQP</a>  =0x00020000, <span class="comment">// Normalize adaptive quantization.</span>
<a name="l00081"></a>00081       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790986ea9985781c4940abeb1647bc9544">FLAG_INTERLACED_DCT</a> =0x00040000, <span class="comment">// Use interlaced DCT.</span>
<a name="l00082"></a>00082       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87926bb157946f80549a09a2b4176185d99">FLAG_LOW_DELAY</a>      =0x00080000, <span class="comment">// Force low delay.</span>
<a name="l00083"></a>00083       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87991ce52afe08088d8b2800807b6933bcc">FLAG_ALT_SCAN</a>       =0x00100000, <span class="comment">// Use alternate scan.</span>
<a name="l00084"></a>00084       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796ad4676d1e27d942bda614e396d142fb">FLAG_TRELLIS_QUANT</a>  =0x00200000, <span class="comment">// Use trellis quantization.</span>
<a name="l00085"></a>00085       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87983559921c3d9f8ad6f68483e27e50ae6">FLAG_GLOBAL_HEADER</a>  =0x00400000, <span class="comment">// Place global headers in extradata instead of every keyframe.</span>
<a name="l00086"></a>00086       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87914f45b1908b8421be1797ec9e4acbfdb">FLAG_BITEXACT</a>       =0x00800000, <span class="comment">// Use only bitexact stuff (except (I)DCT).</span>
<a name="l00087"></a>00087       <span class="comment">/* Fx : Flag for h263+ extra options */</span>
<a name="l00088"></a>00088       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794664d5f71e915e52e9ddcf4a87724f6b">FLAG_AC_PRED</a>        =0x01000000, <span class="comment">// H.263 advanced intra coding / MPEG-4 AC prediction</span>
<a name="l00089"></a>00089       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87941ac464d9ff56ddcd3833155f6bb184c">FLAG_H263P_UMV</a>      =0x02000000, <span class="comment">// unlimited motion vector</span>
<a name="l00090"></a>00090       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796a766d50b21406c934cba9be3e336b6a">FLAG_CBP_RD</a>         =0x04000000, <span class="comment">// Use rate distortion optimization for cbp.</span>
<a name="l00091"></a>00091       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879e64dd7e26f0e45e3a30318dfcdca5de6">FLAG_QP_RD</a>          =0x08000000, <span class="comment">// Use rate distortion optimization for qp selectioon.</span>
<a name="l00092"></a>00092       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87913778bd96ee3822451bba72bd2ff1eed">FLAG_H263P_AIV</a>      =0x00000008, <span class="comment">// H.263 alternative inter VLC</span>
<a name="l00093"></a>00093       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8791670dbe5caeecca2a9345494d2c7c34d">FLAG_OBMC</a>           =0x00000001, <span class="comment">// OBMC</span>
<a name="l00094"></a>00094       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87974ed4331302ebe605404f8cc902e3e86">FLAG_LOOP_FILTER</a>    =0x00000800, <span class="comment">// loop filter</span>
<a name="l00095"></a>00095       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879105e96e73c7073eaab84989ce60dd8a0">FLAG_H263P_SLICE_STRUCT</a> =0x10000000,
<a name="l00096"></a>00096       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879c5c65596cb2da1de27eb16b09512632a">FLAG_INTERLACED_ME</a>  =0x20000000, <span class="comment">// interlaced motion estimation</span>
<a name="l00097"></a>00097       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87965fe2f325c48ac298aaf929a34012963">FLAG_SVCD_SCAN_OFFSET</a> =0x40000000, <span class="comment">// Will reserve space for SVCD scan offset user data.</span>
<a name="l00098"></a>00098       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879ef6e47ba37cec10dd4cef0ff621714bc">FLAG_CLOSED_GOP</a>     =0x80000000,
<a name="l00099"></a>00099       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8796c7fb2ce0c7ad666bce1be3769152016">FLAG2_FAST</a>          =0x00000001, <span class="comment">// Allow non spec compliant speedup tricks.</span>
<a name="l00100"></a>00100       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798d8a0a67a8a9bcd07648fb505a95f427">FLAG2_STRICT_GOP</a>    =0x00000002, <span class="comment">// Strictly enforce GOP size.</span>
<a name="l00101"></a>00101       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879db761261af564fe35267e8bfd5e8bb35">FLAG2_NO_OUTPUT</a>     =0x00000004, <span class="comment">// Skip bitstream encoding.</span>
<a name="l00102"></a>00102       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87948ad452ffe5243718ea6b1a6b6484df3">FLAG2_LOCAL_HEADER</a>  =0x00000008, <span class="comment">// Place global headers at every keyframe instead of in extradata.</span>
<a name="l00103"></a>00103       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8790f433c6717d4f77429f367b06ab8b039">FLAG2_BPYRAMID</a>      =0x00000010, <span class="comment">// H.264 allow B-frames to be used as references.</span>
<a name="l00104"></a>00104       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879a194205e5e6377e390a07b01d554c6b4">FLAG2_WPRED</a>         =0x00000020, <span class="comment">// H.264 weighted biprediction for B-frames</span>
<a name="l00105"></a>00105       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8794c7f68946aec0f28b13983e511d5c4f0">FLAG2_MIXED_REFS</a>    =0x00000040, <span class="comment">// H.264 one reference per partition, as opposed to one reference per macroblock</span>
<a name="l00106"></a>00106       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8793e65e92cc90db94d23cb434257cae67a">FLAG2_8X8DCT</a>        =0x00000080, <span class="comment">// H.264 high profile 8x8 transform</span>
<a name="l00107"></a>00107       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798388b48a314e3399fe8ffc655888a984">FLAG2_FASTPSKIP</a>     =0x00000100, <span class="comment">// H.264 fast pskip</span>
<a name="l00108"></a>00108       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879768e526b734655d7cfd788a2583bb0af">FLAG2_AUD</a>           =0x00000200, <span class="comment">// H.264 access unit delimiters</span>
<a name="l00109"></a>00109       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879412e9759c3f63ef5e96b2f1f5dc9f757">FLAG2_BRDO</a>          =0x00000400, <span class="comment">// B-frame rate-distortion optimization</span>
<a name="l00110"></a>00110       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879c7267e6d934987b11fa262f0da1d82d1">FLAG2_INTRA_VLC</a>     =0x00000800, <span class="comment">// Use MPEG-2 intra VLC table.</span>
<a name="l00111"></a>00111       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798cfca8988e1d1f6059c7aa831464d9b3">FLAG2_MEMC_ONLY</a>     =0x00001000, <span class="comment">// Only do ME/MC (I frames -&gt; ref, P frame -&gt; ME+MC).</span>
<a name="l00112"></a>00112       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879bdf5bc9565154beb0cc150318aca9d27">FLAG2_DROP_FRAME_TIMECODE</a> =0x00002000, <span class="comment">// timecode is in drop frame format.</span>
<a name="l00113"></a>00113       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8798dd8a5684263fe8a5a4373e45acd74d0">FLAG2_SKIP_RD</a>       =0x00004000, <span class="comment">// RD optimal MB level residual skipping</span>
<a name="l00114"></a>00114       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879194beaf917f8883cca395fcdc99fdef5">FLAG2_CHUNKS</a>        =0x00008000, <span class="comment">// Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.</span>
<a name="l00115"></a>00115       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8797f9e209b5d2dbb95775fb9a4fbe0f480">FLAG2_NON_LINEAR_QUANT</a> =0x00010000, <span class="comment">// Use MPEG-2 nonlinear quantizer.</span>
<a name="l00116"></a>00116       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879b8d674310e24c1b1c6bb1a6ec2836bfe">FLAG2_BIT_RESERVOIR</a> =0x00020000, <span class="comment">// Use a bit reservoir when encoding if possible</span>
<a name="l00117"></a>00117       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d87909c486748f5f3f7599d7b3168dfbfb38">FLAG2_MBTREE</a> =0x00040000, <span class="comment">// Use macroblock tree ratecontrol (x264 only)</span>
<a name="l00118"></a>00118       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879d73c50803519ff0425d910d32d445165">FLAG2_PSY</a> =0x00080000, <span class="comment">// Use psycho visual optimizations.</span>
<a name="l00119"></a>00119       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879bb9e422911a368aac3cd22ee41ffed3c">FLAG2_SSIM</a> =0x00100000, <span class="comment">// Compute SSIM during encoding, error[] values are undefined.</span>
<a name="l00120"></a>00120       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d8793d1624c1c870df3c3f9eb631032ac9f8">FLAG2_INTRA_REFRESH</a>=0x00200000,
<a name="l00121"></a>00121     } <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879" title="XUGGLER Flags that can be passed to the setFlag(Flags, bool) method.">Flags</a>;
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="19df5af4ba269de43b87898e2897c223"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::IStreamCoder" ref="19df5af4ba269de43b87898e2897c223" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::IStreamCoder::IStreamCoder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="IStreamCoder_8cpp-source.html#l00026">26</a> of file <a class="el" href="IStreamCoder_8cpp-source.html">IStreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00027"></a>00027   {
<a name="l00028"></a>00028   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="88de1bf057891787998b45a774f41ed3"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::~IStreamCoder" ref="88de1bf057891787998b45a774f41ed3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::IStreamCoder::~IStreamCoder           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="IStreamCoder_8cpp-source.html#l00030">30</a> of file <a class="el" href="IStreamCoder_8cpp-source.html">IStreamCoder.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00031"></a>00031   {
<a name="l00032"></a>00032   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b508aae561f4617d9871b4dabd71a2e1"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getDirection" ref="b508aae561f4617d9871b4dabd71a2e1" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a> com::xuggle::xuggler::IStreamCoder::getDirection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the direction. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The direction this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> works in. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6b832d9a8c2525e5df94b86ba02c958a">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="3193aeab178e76155937dc4bf934fb21"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getStream" ref="3193aeab178e76155937dc4bf934fb21" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a>* com::xuggle::xuggler::IStreamCoder::getStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The associated <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> we're working on. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The stream associated with this object. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#64063f8de647eb0f803d46286cbffe85">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="56aabe726714456ec95c0bd979b48388"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getCodec" ref="56aabe726714456ec95c0bd979b48388" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a>* com::xuggle::xuggler::IStreamCoder::getCodec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will use. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> used by this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>, or 0 (null) if none. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#38d1c2a946f744d7294c77d03f8a88dc">com::xuggle::xuggler::StreamCoder</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00100">com::xuggle::xuggler::StreamCoder::make()</a>.</p>

</div>
</div><p>
<a class="anchor" name="731f039e513526ee80766a7f583cd083"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getCodecType" ref="731f039e513526ee80766a7f583cd083" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#1ce4619f17510ea1437e8be9c6af6bd4">ICodec::Type</a> com::xuggle::xuggler::IStreamCoder::getCodecType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a>.getType(). 
<p>
<b> Note for Native (C++) users: </b>  If you actually write code like the above from Native code, you'd leak a Codec() since you didn't call <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#2b9f941c8693c281e8683bca97704e4d" title="Internal Only.">release()</a> on it. This method is a short hand way to avoid you having to worry about releasing in between.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The Type of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> we'll use. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6ce7836919f663224cac2581894af3b7">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="7ada56e38b03a00aa3a032b2334ab0fc"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getCodecID" ref="7ada56e38b03a00aa3a032b2334ab0fc" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a> com::xuggle::xuggler::IStreamCoder::getCodecID           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A short hand for <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a>.getID(). 
<p>
<b> Note for Native (C++) users: </b>  If you actually write code like the above from Native code, you'd leak a Codec() since you didn't call <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#2b9f941c8693c281e8683bca97704e4d" title="Internal Only.">release()</a> on it. This method is a short hand way to avoid you having to worry about releasing in between.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ID of the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> we'll use. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5c725f733f5a79b77b07634fcc697f4f">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="48f1f4b8179f54921de7ecba9ced0b8d"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setCodec" ref="48f1f4b8179f54921de7ecba9ced0b8d" args="(ICodec *codec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html">ICodec</a> *&nbsp;</td>
          <td class="paramname"> <em>codec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to the passed in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a>, discarding the old <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> if set. 
<p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>codec</em>&nbsp;</td><td><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> to set. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0d1c8aa67e3989f47ee5a11d82aaf2a9">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="4becff2779c996a1c4c546742a616add"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setCodec" ref="4becff2779c996a1c4c546742a616add" args="(ICodec::ID id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setCodec           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it. 
<p>
To see if you actually set the correct ID, call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a> and check for 0 (null).  <p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>ID of codec to set. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3b5395bc02d83e3238de554373694a79">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="721d05712a3bbadb4e9cb296c31f06c5"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getBitRate" ref="721d05712a3bbadb4e9cb296c31f06c5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getBitRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bit rate. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The bit-rate the stream is, or will be, encoded in. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3ad76901b42de384c16bc717a131bda4">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="d7e0d1ab0062890a09d16520eac7f7fb"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setBitRate" ref="d7e0d1ab0062890a09d16520eac7f7fb" args="(int32_t rate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setBitRate           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When ENCODING, sets the bit rate to use. 
<p>
No-op when DECODING. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#721d05712a3bbadb4e9cb296c31f06c5" title="The bit rate.">getBitRate()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>The bit rate to use. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b62eccf1830d7855da19c9fc6d680159">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0daab96eace6c53c2fef0e76f0893400"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getBitRateTolerance" ref="0daab96eace6c53c2fef0e76f0893400" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getBitRateTolerance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The bit rate tolerance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The bit-rate tolerance </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0118c37786830ca1cf6b0c9d0ba9fcf7">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="730d5312efc1f4c3d75a495781824618"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setBitRateTolerance" ref="730d5312efc1f4c3d75a495781824618" args="(int32_t tolerance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setBitRateTolerance           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When ENCODING set the bit rate tolerance. 
<p>
No-op when DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tolerance</em>&nbsp;</td><td>The bit rate tolerance </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b01fdd1a48ba21f453f21af54af2b494">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="30d036216176596621aa86988366b498"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getHeight" ref="30d036216176596621aa86988366b498" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getHeight           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The height, in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The height of the video frames in the attached stream or -1 if an audio stream, or we cannot determine the height. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4769d9bd31fdc7713ab8dfbd48215469">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="934fbd205a2f93b0eae1ebf309ab88ea"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setHeight" ref="934fbd205a2f93b0eae1ebf309ab88ea" args="(int32_t height)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setHeight           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>height</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the height, in pixels. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#30d036216176596621aa86988366b498" title="The height, in pixels.">getHeight()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Sets the height of video frames we'll encode. No-op when DECODING. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#296b5949d5a4d95efc7b22759d21fbc3">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="833b9a4f028740f5d5829de0c70d2208"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getWidth" ref="833b9a4f028740f5d5829de0c70d2208" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getWidth           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The width, in pixels. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The width of the video frames in the attached stream or -1 if an audio stream, or we cannot determine the width. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#fdd15f63bad7f537ed57d16cb514e7f4">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="b6c9be1de92dfa7e4f8a12c552a5a7c9"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setWidth" ref="b6c9be1de92dfa7e4f8a12c552a5a7c9" args="(int32_t width)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setWidth           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>width</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the width, in pixels. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#833b9a4f028740f5d5829de0c70d2208" title="The width, in pixels.">getWidth()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Sets the width of video frames we'll encode. No-op when DECODING. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#72e99ee4873a1ac9beae122566bb6deb">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="bba258ddaba01511e28560f59d6757ea"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getTimeBase" ref="bba258ddaba01511e28560f59d6757ea" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a>* com::xuggle::xuggler::IStreamCoder::getTimeBase           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the time base this stream will ENCODE in, or the time base we detect while DECODING. 
<p>
Caller must call <a class="el" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html#2b9f941c8693c281e8683bca97704e4d" title="Internal Only.">release()</a> on the returned value.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The time base this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> is using. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#1cb4b1a1f636f6c9cfa929202e12c448">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="b2d539f28acdf1b569dfc6a8602bf5ae"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setTimeBase" ref="b2d539f28acdf1b569dfc6a8602bf5ae" args="(IRational *newTimeBase)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setTimeBase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>newTimeBase</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time base we'll use to ENCODE with. 
<p>
A no-op when DECODING.<p>
As a convenience, we forward this call to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html#3525579ab1a040d62cf04cfea7815410">Stream::setTimeBase()</a> method.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea" title="Get the time base this stream will ENCODE in, or the time base we detect while DECODING...">getTimeBase()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newTimeBase</em>&nbsp;</td><td>The new time base to use. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#577fe228e82875a2f7336761bd414ecf">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9f2c9b61bf00102711d42fa4b86eb9b"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getFrameRate" ref="f9f2c9b61bf00102711d42fa4b86eb9b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a>* com::xuggle::xuggler::IStreamCoder::getFrameRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate we'll claim we're using when ENCODING. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The frame rate. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b73447096b1ab3bbf1d4ac347ee90a9b">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="3fdbe34d0a17f1a65b506bd4e678bfd6"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setFrameRate" ref="3fdbe34d0a17f1a65b506bd4e678bfd6" args="(IRational *newFrameRate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setFrameRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>newFrameRate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the frame rate we'll set in the headers of this stream while ENCODING. 
<p>
Note that you can set whatever frame-rate you'd like, but the TimeBase and the PTS you set on the encoded audio and video frames can override this.<p>
As a convenience, we forward this call to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html#c0410f0b5c8ae709ecf42f46650854cf">Stream::setFrameRate()</a> method.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#f9f2c9b61bf00102711d42fa4b86eb9b" title="Get the frame-rate the attached stream claims to be using when DECODING, or the frame-rate...">getFrameRate()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFrameRate</em>&nbsp;</td><td>The new frame rate to use. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ed7307d0ffe04784b4123dd546cfb748">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb1cdc689646b3599267bbc0ea42f646"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getNumPicturesInGroupOfPictures" ref="bb1cdc689646b3599267bbc0ea42f646" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getNumPicturesInGroupOfPictures           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The the number of pictures in this Group of Pictures (GOP). 
<p>
See the MPEG specs for what a GOP is officially, but this is the minimum number of frames between key-frames (or Intra-Frames in MPEG speak).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the GOPS for this stream. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#9362cb328c007ce98ee74cb5abd106a5">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="d7efb17b72661318751f73bf3d890d5a"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setNumPicturesInGroupOfPictures" ref="d7efb17b72661318751f73bf3d890d5a" args="(int32_t gops)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setNumPicturesInGroupOfPictures           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>gops</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the GOPS on this stream. 
<p>
Ignored if DECODING.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bb1cdc689646b3599267bbc0ea42f646" title="The the number of pictures in this Group of Pictures (GOP).">getNumPicturesInGroupOfPictures()</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gops</em>&nbsp;</td><td>The new GOPS for the stream we're encoding. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#37182d1c20e019bb80a52d4da4189f7e">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="3b014e161a955d302d03fac3d39a5d37"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPixelType" ref="3b014e161a955d302d03fac3d39a5d37" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a> com::xuggle::xuggler::IStreamCoder::getPixelType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For Video streams, get the Pixel Format in use by the stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the Pixel format, or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742914b9479e5b8850fe395b69648e00fb0">IPixelFormat::NONE</a> if audio. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#6d1e20892c0edccaf8df3164fa7cd168">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c3a41a11704b3c0abb8b6e55d9f57eb3"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setPixelType" ref="c3a41a11704b3c0abb8b6e55d9f57eb3" args="(IPixelFormat::Type pixelFmt)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setPixelType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPixelFormat.html#f869b474f38ba0ecd392f05780d23742">IPixelFormat::Type</a>&nbsp;</td>
          <td class="paramname"> <em>pixelFmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the pixel format to ENCODE with. 
<p>
Ignored if audio or DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixelFmt</em>&nbsp;</td><td>Pixel format to use. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f86d01c6b6c439ab59a005ba4a738d39">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="554e763894f9274d0fcb9a3f3d51c632"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getSampleRate" ref="554e763894f9274d0fcb9a3f3d51c632" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getSampleRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the sample rate we use for this stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample rate (in Hz) we use for this stream, or -1 if unknown or video. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e406f7f0aaa28b55cc5194b61e4f41a2">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd3688dc5215dbb7e1d9e68f1ce2ddb6"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setSampleRate" ref="fd3688dc5215dbb7e1d9e68f1ce2ddb6" args="(int32_t sampleRate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setSampleRate           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sampleRate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sample rate to use when ENCODING. 
<p>
Ignored if DECODING or a non-audio stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sampleRate</em>&nbsp;</td><td>New sample rate (in Hz) to use. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#3be6a2991af4984bbff29986ba06fd15">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="87b8ea7de46bfc8606f2414235983f5c"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getSampleFormat" ref="87b8ea7de46bfc8606f2414235983f5c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a> com::xuggle::xuggler::IStreamCoder::getSampleFormat           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the audio sample format. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample format of samples for encoding/decoding. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#97e41cec0c1d23cdb701b5b57d969b35">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="2264cb4521e09417588444d68ead4daa"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setSampleFormat" ref="2264cb4521e09417588444d68ead4daa" args="(IAudioSamples::Format aFormat)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setSampleFormat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#ead23bd010e8f2248e042c0dc8911756">IAudioSamples::Format</a>&nbsp;</td>
          <td class="paramname"> <em>aFormat</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sample format when ENCODING. 
<p>
Ignored if DECODING or if the coder is already open.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aFormat</em>&nbsp;</td><td>The sample format. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8d7694b0fcfaeaf2cd102aea3064be02">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a7316327de43f4f6e8c991a386ee3e0"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getChannels" ref="9a7316327de43f4f6e8c991a386ee3e0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getChannels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of channels in this audio stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The sample rate (in Hz) we use for this stream, or 0 if unknown. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f191e14f7153360d1cffd337c5274d8d">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="eb351995ac5cac009e37535c31bfa32b"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setChannels" ref="eb351995ac5cac009e37535c31bfa32b" args="(int32_t channels)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setChannels           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>channels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of channels to use when ENCODING. 
<p>
Ignored if a non audio stream, or if DECODING.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td>The number of channels we'll encode with. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f9e830b559daf6b97441eb78e7161ca0">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0d55705562c299cb8c1eeff383b94128"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getAudioFrameSize" ref="0d55705562c299cb8c1eeff383b94128" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getAudioFrameSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For this stream, get the number of audio samples that are represented in a packet of information. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of samples per 'frame' of encoded audio </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#7215694c124919baeaf61cb59d2611ef">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="85940f0d668670d37d624515ee52110a"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getGlobalQuality" ref="85940f0d668670d37d624515ee52110a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getGlobalQuality           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality setting this codec uses for video if a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> doesn't have a quality set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The global quality. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0492afbd477f99707ebb0f2442b0aad9">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0cc039ca3dbf242e8f5bb8c1f785623d"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setGlobalQuality" ref="0cc039ca3dbf242e8f5bb8c1f785623d" args="(int32_t newQuality)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setGlobalQuality           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newQuality</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html" title="A collection of static functions that refer to the entire package (like version getters)...">Global</a> Quality to a new value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newQuality</em>&nbsp;</td><td>The new global quality. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#bae0a8f7611f878e77c0db6ec4cadecd">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="70815810fd45c4b35a2e8bb46ca55936"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getFlags" ref="70815810fd45c4b35a2e8bb46ca55936" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the flags associated with this codec. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The (compacted) value of all flags set. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#be713a5c2457120817fe3156a6445bb1">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b758ae82cb98f8a8168de4883e9dcd1"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setFlags" ref="1b758ae82cb98f8a8168de4883e9dcd1" args="(int32_t newFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setFlags           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>newFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the FFMPEG flags to use with this codec. 
<p>
All values must be ORed (|) together.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879" title="XUGGLER Flags that can be passed to the setFlag(Flags, bool) method.">Flags</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newFlags</em>&nbsp;</td><td>The new set flags for this codec. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#810f00ec624a5fea2668df9414d79b38">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba73e8620429bd95f4de9f3b09ea2807"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getFlag" ref="ba73e8620429bd95f4de9f3b09ea2807" args="(Flags flag)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IStreamCoder::getFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the setting for the specified flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag you want to find the setting for</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for false; non-zero for true </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#63e5caa7dd85559c9ea81cd1f3cd9e2f">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="b484b81ddb23803694376582ebc63dcc"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setFlag" ref="b484b81ddb23803694376582ebc63dcc" args="(Flags flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7f129ebbe404af47858199c929d0d879">Flags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the flag. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flag</em>&nbsp;</td><td>The flag to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set it to (true or false) </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#c3999550315918737d0f5e1b4b765737">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="faa50862ae1188ac20ae10539aefce5c"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getNextPredictedPts" ref="faa50862ae1188ac20ae10539aefce5c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IStreamCoder::getNextPredictedPts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For this stream, get the next Pts that we expect to decode. 
<p>
Note that this may not actually be the next Pts (for example due to transmission packet drops in the input source). Still it can be a useful tool.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next presentation time stamp we expect to decode on this stream. This is always in units of 1/1,000,000 seconds </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#322018854233516dabd22740fbc9e5e3">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="ecbfccf54f0b4aa1efd9c029891bb398"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::open" ref="ecbfccf54f0b4aa1efd9c029891bb398" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> associated with this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
You can get the codec through getCodec(...) and set it with setCodec(...). You cannot call any set* methods after you've called <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ecbfccf54f0b4aa1efd9c029891bb398" title="Open the Codec associated with this StreamCoder.">open()</a> on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> until you <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b" title="Close a Codec that was opened on this StreamCoder.">close()</a> it.<p>
You must call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#7618833932c24a8f2962290ab6c8449b" title="Close a Codec that was opened on this StreamCoder.">close()</a> when you're done, but if you don't, the container will clean up after you (but yell at you) when it is closed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#f63b93f7ee8907256f45b1abf1f0dd5d">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="7618833932c24a8f2962290ab6c8449b"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::close" ref="7618833932c24a8f2962290ab6c8449b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> that was opened on this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt; 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#adadc04f0940c3afa23655ab67e86b73">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="97801fddf4414d619b712fdcbac8940d"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::decodeAudio" ref="97801fddf4414d619b712fdcbac8940d" args="(IAudioSamples *pOutSamples, IPacket *packet, int32_t byteOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::decodeAudio           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>byteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode this packet into pOutSamples. 
<p>
It will try to fill up the audio samples object, starting from the byteOffset inside this packet. <p>
The caller is responsible for allocating the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html" title="A set of raw (decoded) samples, plus a timestamp for when to play those samples relative...">IAudioSamples</a> object. This function will overwrite any data in the samples object.  <p>
Note that the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html" title="A set of raw (decoded) samples, plus a timestamp for when to play those samples relative...">IAudioSamples</a> object passed in must have a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html#625af0c15015922f5af4b6308bb29bf9">IAudioSamples#getMaxBufferSize()</a> of at least 192kbytes. Sorry, but this requirement is imposed on us via FFmpeg. If the buffer is not large enough, this method will reallocate the underlying buffers to make them at least 192kbytes.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutSamples</em>&nbsp;</td><td>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1AudioSamples.html">AudioSamples</a> we decode to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet we're attempting to decode from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteOffset</em>&nbsp;</td><td>Where in the packet payload to start decoding</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes actually processed from the packet, or negative for error </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5077165e8e719fedfce7810ce4016cd7">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="a8fc7f0842531be95981457761adb7b9"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::decodeVideo" ref="a8fc7f0842531be95981457761adb7b9" args="(IVideoPicture *pOutFrame, IPacket *packet, int32_t byteOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::decodeVideo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>byteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decode this packet into pOutFrame. 
<p>
The caller is responsible for allocating the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html" title="Represents one raw (undecoded) picture in a video stream, plus a timestamp for when...">IVideoPicture</a> object. This function will potentially overwrite any data in the frame object, but you should pass the same <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html" title="Represents one raw (undecoded) picture in a video stream, plus a timestamp for when...">IVideoPicture</a> into this function repeatedly until <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html#e90b6fdbb542140bc25d2e976af24665" title="Is this picture completely decoded?">IVideoPicture::isComplete()</a> is true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutFrame</em>&nbsp;</td><td>The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1AudioSamples.html">AudioSamples</a> we decode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet we're attempting to decode from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteOffset</em>&nbsp;</td><td>Where in the packet payload to start decoding</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of bytes actually processed from the packet, or negative for error </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#5febedd0e02c02da5cdb0d56de264835">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="d39b98a68e86cbe889b98a053bfc9230"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::encodeVideo" ref="d39b98a68e86cbe889b98a053bfc9230" args="(IPacket *pOutPacket, IVideoPicture *pFrame, int32_t suggestedBufferSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::encodeVideo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IVideoPicture.html">IVideoPicture</a> *&nbsp;</td>
          <td class="paramname"> <em>pFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>suggestedBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode the given frame using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> will allocate a buffer to use internally for this, and will free it when the frame destroys itself.<p>
Also, when done in order to flush the encoder, caller should call this method passing in 0 (null) for pFrame to tell the encoder to flush any data it was keeping a hold of.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutPacket</em>&nbsp;</td><td>[out] The packet to encode into. It will point to a buffer allocated in the frame. Caller should check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8a905262cb3774db3f36f48749f7e56b" title="Is this packet complete.">IPacket::isComplete()</a> after call to find out if we had enough information to encode a full packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pFrame</em>&nbsp;</td><td>[in/out] The frame to encode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suggestedBufferSize</em>&nbsp;</td><td>The suggested buffer size to allocate or -1 for choose ourselves. If -1 we'll allocate a buffer exactly the same size (+1) as the decoded frame with the guess that you're encoding a frame because you want to use LESS space than that.</td></tr>
  </table>
</dl>
@ return &gt;= 0 on success; &lt;0 on error. 
<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4e8e90c3ba84aab18d7e17379c59c865">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c47164283b3bfa882e32592ace086206"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::encodeAudio" ref="c47164283b3bfa882e32592ace086206" args="(IPacket *pOutPacket, IAudioSamples *pSamples, uint32_t sampleToStartFrom)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::encodeAudio           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html">IPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>pOutPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IAudioSamples.html">IAudioSamples</a> *&nbsp;</td>
          <td class="paramname"> <em>pSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>sampleToStartFrom</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encode the given samples using this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. 
<p>
The <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1VideoPicture.html">VideoPicture</a> will allocate a buffer to use internally for this, and will free it when the frame destroys itself.<p>
Callers should call this repeatedly on a set of samples until we consume all the samples.<p>
Also, when done in order to flush the encoder, caller should call this method passing in 0 (null) for pSamples to tell the encoder to flush any data it was keeping a hold of.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pOutPacket</em>&nbsp;</td><td>[out] The packet to encode into. It will point to a buffer allocated in the frame. Caller should check <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8a905262cb3774db3f36f48749f7e56b" title="Is this packet complete.">IPacket::isComplete()</a> after call to find out if we had enough information to encode a full packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pSamples</em>&nbsp;</td><td>[in] The samples to consume </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sampleToStartFrom</em>&nbsp;</td><td>[in] Which sample you want to start with This is usually zero, but if you're using a codec that packetizes output with small number of samples, you may need to call encodeAudio repeatedly with different starting samples to consume all of your samples.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of samples we consumed when encoding, or negative for errors. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#81102eae7e5d013057c3a38f9e636cbc">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0055d9571962191f1f05670d6ffd406e"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::make" ref="0055d9571962191f1f05670d6ffd406e" args="(Direction direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> * com::xuggle::xuggler::IStreamCoder::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a standalone <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that can decode data without regard to which <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html" title="Represents a stream of similar data (eg video) in a IContainer.">IStream</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html" title="A file (or network data source) that contains one or more IStream objects of audio...">IContainer</a> it came from. 
<p>
If you're reading or writing to a XUGGLER file or URL you almost definitely don't want to use this method. Use the <a class="el" href="">IContainer#getStream(long)</a> and <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html#eff9842732f2e9e11b90079f9d9d1db0">IStream#getStreamCoder()</a> methods instead as it will set up the resulting <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> with sensible defaults. Use of a un-attached <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> returned from this method is for advanced users only.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>The direction this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> will work in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new stream coder, or null if error. </dd></dl>

<p>Definition at line <a class="el" href="IStreamCoder_8cpp-source.html#l00035">35</a> of file <a class="el" href="IStreamCoder_8cpp-source.html">IStreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Global_8cpp-source.html#l00156">com::xuggle::xuggler::Global::init()</a>, and <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465">com::xuggle::xuggler::StreamCoder::make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00036"></a>00036   {
<a name="l00037"></a>00037     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#d4f1787e8c9f61cf8cb31eceddaa477f" title="Internal Only.">Global::init</a>();
<a name="l00038"></a>00038     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465" title="This method creates a StreamCoder that is not tied to any container or stream.">StreamCoder::make</a>(direction, 0);
<a name="l00039"></a>00039   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ca7adbeb0262af0e9d368cac4cdd7759"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getCodecTag" ref="ca7adbeb0262af0e9d368cac4cdd7759" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getCodecTag           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the 4-byte FOURCC tag (Least Significant Byte first). 
<p>
This is really a packed 4-byte array so it's only useful if you use bit-wise operations on it. Some language wrappings may provide more obvious ways of manipulating, but this is the safest way to do this that will work with all wrappers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the FOURCC tag. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#afc7dd7a6f0ee4157beeafc6c0561ac9">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="e84f341deb602fc8a093ceb4dd071019"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setCodecTag" ref="e84f341deb602fc8a093ceb4dd071019" args="(int32_t fourcc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setCodecTag           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>fourcc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the 4-byte FOURCC tag for this coder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fourcc</em>&nbsp;</td><td>The FOURCC to set, with Least Significant Byte first. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#44de26df5c2b94ff6a05edb0a25eb749">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b8475c809d1a5684a987f4d74789b17"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getNumProperties" ref="9b8475c809d1a5684a987f4d74789b17" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getNumProperties           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of settable properties on this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>total number of options (not including constant definitions) </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#4b46738b73578892a602c9e4f5d86b9a">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="ccd97f0e68e28c74b31d6fad9edcf2d5"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyMetaData" ref="ccd97f0e68e28c74b31d6fad9edcf2d5" args="(int32_t propertyNo)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a>* com::xuggle::xuggler::IStreamCoder::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>propertyNo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>propertyNo</em>&nbsp;</td><td>The property number in the options list.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#e455a70c2e5117f2606aef6e78851eb9">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="1092cf8f25a60f0cf41f3762c34a272b"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyMetaData" ref="1092cf8f25a60f0cf41f3762c34a272b" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html">IProperty</a>* com::xuggle::xuggler::IStreamCoder::getPropertyMetaData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the numbered property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IProperty.html" title="Represents settable properties that effect how Xuggler objects operate.">IProperty</a> value for this properties meta-data </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#986ce910417e9eae24db40582628fc36">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4dd45fb064dbcbb4a87f909f31fbaa0"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setProperty" ref="c4dd45fb064dbcbb4a87f909f31fbaa0" args="(const char *name, const char *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a property on this Object. 
<p>
All AVOptions supported by the underlying AVClass are supported.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The property name. For example "b" for bit-rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 if the property was successfully set; &lt;0 on error </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#11e185722fd04e12b149a920acccda58">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="25c22b581ba91e0879e217ddc6683705"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setProperty" ref="25c22b581ba91e0879e217ddc6683705" args="(const char *name, double value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#a3c98a470f35ea37de9b09e59051adb4">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="2fe9345b2139cd51dae0e34150363aa4"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setProperty" ref="2fe9345b2139cd51dae0e34150363aa4" args="(const char *name, int64_t value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#c088c801ac620c2408a2d772ef0d4106">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="fe37876b910d67ade52eecf582b8d1fe"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setProperty" ref="fe37876b910d67ade52eecf582b8d1fe" args="(const char *name, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0b410e91987886c9aaa054409bd264f6">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="218c9b5b0dff04d90962ec87352096fd"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setProperty" ref="218c9b5b0dff04d90962ec87352096fd" args="(const char *name, IRational *value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up the property 'name' and sets the value of the property to 'value'. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 on success; &lt;0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#745884fb6d54f10306298ec51c37c1aa">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a292d948b0b2dbaf8f2b1c34be7a01a"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyAsString" ref="0a292d948b0b2dbaf8f2b1c34be7a01a" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* com::xuggle::xuggler::IStreamCoder::getPropertyAsString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a property on this Object. 
<p>
Note for C++ callers; you must free the returned array with delete[] in order to avoid a memory leak. Other language folks need not worry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>property name</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an string copy of the option value, or null if the option doesn't exist. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#46ad55458a7bc58e68773cefc7a2bb46">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c25f79946060059ee021bce8bc05bc4b"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyAsDouble" ref="c25f79946060059ee021bce8bc05bc4b" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double com::xuggle::xuggler::IStreamCoder::getPropertyAsDouble           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a double;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>double value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#860e21eba8f6a01bbd89658b62f9c51d">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="82634d367c065b096cbb224d6caa5a15"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyAsLong" ref="82634d367c065b096cbb224d6caa5a15" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IStreamCoder::getPropertyAsLong           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an long;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#577f109de16549bebcfda6c275cd63c8">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="8c570c4ea02459a2be7225e9d022ff15"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyAsRational" ref="8c570c4ea02459a2be7225e9d022ff15" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a>* com::xuggle::xuggler::IStreamCoder::getPropertyAsRational           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html" title="This class wraps represents a Rational number for the Xuggler.">IRational</a>;. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>long value of property, or 0 on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#67ec2cafa9879d66f862cdcd18ed831b">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c64d752357de5237693281b854f927d6"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getPropertyAsBoolean" ref="c64d752357de5237693281b854f927d6" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IStreamCoder::getPropertyAsBoolean           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the value of this property, and returns as a boolean. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of option</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>boolean value of property, or false on error. </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8198a8c1864f7e80360a32e3464e4be4">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="c9befe352247818b4e0fddafb4764f1a"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::isOpen" ref="c9befe352247818b4e0fddafb4764f1a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IStreamCoder::isOpen           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> is currently open. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if open; false if not </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#0fd9b5cc2bcabf4d605923f9559cef52">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="6e2b6aa60e6f05952bfa12d6def2d33f"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getDefaultAudioFrameSize" ref="6e2b6aa60e6f05952bfa12d6def2d33f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getDefaultAudioFrameSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default audio frame size (in samples). 
<p>
Some codecs, especially raw codecs, like PCM, don't have a standard frame size. In those cases, we use the value of this setting to determine how many samples to encode into a single packet.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of samples in an audio frame size if the codec doesn't specify the size. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.21 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#35c1957cd69edc56727d8cb124ff0c64">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="dc9c7510ce5706e3cc1f38cfb04883b5"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setDefaultAudioFrameSize" ref="dc9c7510ce5706e3cc1f38cfb04883b5" args="(int32_t aNewSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setDefaultAudioFrameSize           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>aNewSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default audio frame size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aNewSize</em>&nbsp;</td><td>The new number of samples to use to encode samples into a packet. This setting is ignored if &lt;= 0 or if the codec requires it's own frame size (e.g. Nellymoser).</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#6e2b6aa60e6f05952bfa12d6def2d33f" title="Get the default audio frame size (in samples).">getDefaultAudioFrameSize()</a> </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.21 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#559e498fccb1698f959fd021948988bf">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="46d0877a0a9f9725d6c459e803c15aa1"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::make" ref="46d0877a0a9f9725d6c459e803c15aa1" args="(Direction direction, IStreamCoder *copyCoder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> * com::xuggle::xuggler::IStreamCoder::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#89070b18b2b728e7c93a73fb65a15099">Direction</a>&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> *&nbsp;</td>
          <td class="paramname"> <em>copyCoder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> object by copying all the settings in copyCoder. 
<p>
The new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> is created by copying all the current properties on the passed in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a>. If the passed in stream coder is in a different direction than the one you want, this method still set the same codec ID, and the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ecbfccf54f0b4aa1efd9c029891bb398" title="Open the Codec associated with this StreamCoder.">IStreamCoder.open()</a> method will check then to see if it can work in the specified direction.  <p>
For example, imagine that direction is ENCODING and the copyCoder is a DECODING <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> that is of the CODEC_ID_VP6 type. The resulting new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> has it's code set to CODEC_ID_VP6. However (as of the writing of this comment) we don't support encoding to CODEC_ID_VP6, so when you try to open the codec we will fail.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>The direction you want the new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> to work in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copyCoder</em>&nbsp;</td><td>The coder to copy settings from.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a>, or null on error. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>1.22 </dd></dl>

<p>Definition at line <a class="el" href="IStreamCoder_8cpp-source.html#l00042">42</a> of file <a class="el" href="IStreamCoder_8cpp-source.html">IStreamCoder.cpp</a>.</p>

<p>References <a class="el" href="Global_8cpp-source.html#l00156">com::xuggle::xuggler::Global::init()</a>, and <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465">com::xuggle::xuggler::StreamCoder::make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00043"></a>00043   {
<a name="l00044"></a>00044     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#d4f1787e8c9f61cf8cb31eceddaa477f" title="Internal Only.">Global::init</a>();
<a name="l00045"></a>00045     <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#ce525892dddad9328378e914560b6465" title="This method creates a StreamCoder that is not tied to any container or stream.">StreamCoder::make</a>(direction, coder);
<a name="l00046"></a>00046   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6ed80cd981bef76c4221b1ee2ea8e05d"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getNumDroppedFrames" ref="6ed80cd981bef76c4221b1ee2ea8e05d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::IStreamCoder::getNumDroppedFrames           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of frames this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html">StreamCoder</a> had to drop to encode at the specified <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea">getTimeBase()</a>. 
<p>
<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> objects can encode audio and video, but guarantee that every packet outputted has monotonically increasing timestamps (i.e. 0, 1, 2, 3, 4, 5, etc. without repeats). Sometimes data is passed too quickly into an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> via <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#d39b98a68e86cbe889b98a053bfc9230">encodeVideo</a> or <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#c47164283b3bfa882e32592ace086206">encodeAudio</a>, and the underlying codec can't handle it that quickly. In those cases the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> must drop the most recent frame of data.  <p>
If you're seeing a lot of dropped frames you can try either sending less frequent data to the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a>, or adjusting the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#bba258ddaba01511e28560f59d6757ea">getTimeBase()</a> to the highest possible resolution. Be warned though; some codecs (such as MPEG2) require fixed time-bases (like 1/25) and so setting a higher resolution time base might end up with the codec not able to encode any data.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of frames dropped. </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.1 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#dfb0fb4245829c6b69d0199794cbdab0">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="e6ee298bcfd59cc5e462d5d571c1dbe5"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setAutomaticallyStampPacketsForStream" ref="e6ee298bcfd59cc5e462d5d571c1dbe5" args="(bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setAutomaticallyStampPacketsForStream           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for. 
<p>
If this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> does not know which <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is destined for, or this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> isn't used with an <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> at all, then this setting is ignored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>true to automatically adjust. </td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#8fb1b9a720ffc81d4cfe813992619239">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="0cd4b393de212b4b7a23ff26ee5830b9"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getAutomaticallyStampPacketsForStream" ref="0cd4b393de212b4b7a23ff26ee5830b9" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::IStreamCoder::getAutomaticallyStampPacketsForStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html">IStreamCoder</a> automatically adjust time stamps on output packets for the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html">IStream</a> it is ultimately destined for. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true for yes; false for no </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>setAutomaticallyStampPacketsForStream(boolean) </dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#cbb4270459aff43a8016d9cffc3ba466">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="45a4e37591aabf5e12cb78b2b154fc44"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setCodecID" ref="45a4e37591aabf5e12cb78b2b154fc44" args="(ICodec::ID id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::IStreamCoder::setCodecID           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1ICodec.html#d438813180968adfeac774f4f0170e28">ICodec::ID</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up a <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Codec.html">Codec</a> based on the passed in ID, and then set it. 
<p>
Forwards to <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#45a4e37591aabf5e12cb78b2b154fc44">setCodecID(com.xuggle.xuggler.ICodec.ID)</a>  <p>
To see if you actually set the correct ID, call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#56aabe726714456ec95c0bd979b48388" title="The Codec this StreamCoder will use.">getCodec()</a> and check for 0 (null).  <p>
Once you call setCodec, all settings on the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html" title="The work horse of the Xuggler: Takes IPacket data from an IContainer (representing...">IStreamCoder</a> are reset to default values. So you probably want to call this first. <p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>ID of codec to set. </td></tr>
  </table>
</dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.2 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#aeb23b6d11c94150844c8eb4590681fa">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="40b0d59506c404a0d3e55e9e01261d33"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::setExtraData" ref="40b0d59506c404a0d3e55e9e01261d33" args="(com::xuggle::ferry::IBuffer *src, int32_t offset, int32_t length, bool allocNew)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::setExtraData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allocNew</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies data from the given buffer into the extra-data area maintained by encoders. 
<p>
This is an extremely advanced method, and incorrect usage can result in Java crashes so take care. In general people should not need to use this.  <p>
For some codecs (e.g. for H264, this is global header information and for rv10 it is additional flags), Xuggler maintains extra information about the codec in a extra data buffer. In general Xuggler will allocate this data as needed and you never need to set it (or get it). But if you know what you're doing, you can ask Xuggler to replace the existing extra data for the given codec with a copy of the data in the given buffer.  <p>
You should call this method after you call <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStreamCoder.html#ecbfccf54f0b4aa1efd9c029891bb398">open()</a> but before you encode or decode any media.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The data to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position, in bytes, to start copying data from src </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to copy from data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocNew</em>&nbsp;</td><td>If true, and there is not enough space in the existing extra data buffer, then Xuggler will discard the old buffer and allocate a new buffer. If false, then Xuggler will attempt to copy the data into the existing buffer and if there is not enough space in the existing buffer, no bytes will be copied and an error will be returned. In general, you should set this to false if that works for you. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes copied, or &lt; 0 on error.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#308231743dc003b0eb2a50b66948c8ca">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="506edb9ae345f485eda9f296f99ac009"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getExtraData" ref="506edb9ae345f485eda9f296f99ac009" args="(com::xuggle::ferry::IBuffer *dest, int32_t offset, int32_t maxBytesToCopy)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getExtraData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>maxBytesToCopy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the current content of the extra-data buffer maintained by this codec (e.g. 
<p>
header bytes) into the dest buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The buffer to copy to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The position, in bytes, to start writing data to in dest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxBytesToCopy</em>&nbsp;</td><td>The maximum number of bytes to copy. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes copied, or &lt; 0 on error.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#b3a67a201a8d07c137d3e3583dbdd1f4">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<a class="anchor" name="4bad3f363604acec9ad671a9882abada"></a><!-- doxytag: member="com::xuggle::xuggler::IStreamCoder::getExtraDataSize" ref="4bad3f363604acec9ad671a9882abada" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t com::xuggle::xuggler::IStreamCoder::getExtraDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current number of bytes of data maintained in the coder extra-data area. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes. If 0, then no data is currently available.</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>3.3 </dd></dl>

<p>Implemented in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1StreamCoder.html#82786dc6502d13f4d33b4defc7cef81f">com::xuggle::xuggler::StreamCoder</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>csrc/com/xuggle/xuggler/<a class="el" href="IStreamCoder_8h-source.html">IStreamCoder.h</a><li>csrc/com/xuggle/xuggler/<a class="el" href="IStreamCoder_8cpp-source.html">IStreamCoder.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 11 07:40:12 2011 for Xuggle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
