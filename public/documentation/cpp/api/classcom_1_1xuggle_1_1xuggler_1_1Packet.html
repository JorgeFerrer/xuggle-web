<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xuggle: com::xuggle::xuggler::Packet Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacecom.html">com</a>::<a class="el" href="namespacecom_1_1xuggle.html">xuggle</a>::<a class="el" href="namespacecom_1_1xuggle_1_1xuggler.html">xuggler</a>::<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a>
  </div>
</div>
<div class="contents">
<h1>com::xuggle::xuggler::Packet Class Reference</h1><!-- doxytag: class="com::xuggle::xuggler::Packet" --><!-- doxytag: inherits="com::xuggle::xuggler::IPacket" --><code>#include &lt;<a class="el" href="Packet_8h-source.html">Packet.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for com::xuggle::xuggler::Packet:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1Packet__inherit__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1Packet__inherit__map" alt="Inheritance graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1Packet__inherit__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given..." alt="" coords="19,161,227,188"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html" title="The parent class of all media objects than can be gotten from an IStream." alt="" coords="5,84,240,111"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="15,7,231,33"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for com::xuggle::xuggler::Packet:</div>
<div class="dynsection">
<p><center><img src="classcom_1_1xuggle_1_1xuggler_1_1Packet__coll__graph.png" border="0" usemap="#com_1_1xuggle_1_1xuggler_1_1Packet__coll__map" alt="Collaboration graph"></center>
<map name="com_1_1xuggle_1_1xuggler_1_1Packet__coll__map">
<area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html" title="Represents an encoded piece of data that can be placed in an IContainer for a given..." alt="" coords="1235,109,1443,136"><area shape="rect" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html" title="The parent class of all media objects than can be gotten from an IStream." alt="" coords="659,109,893,136"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefCounted.html" title="Parent of all Ferry objects &#45;&#45; it mains reference counts in native code." alt="" coords="357,80,573,106"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html" title="Allows Java code to get data from a native buffers, and optionally modify native..." alt="" coords="684,58,868,85"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1AtomicInteger.html" title="Internal only." alt="" coords="7,80,239,106"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="com::xuggle::ferry::RefPointer\&lt; com::xuggle::ferry::IBuffer \&gt;" alt="" coords="1139,58,1539,85"><area shape="rect" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html" title="This class is only useful from C++." alt="" coords="655,8,897,34"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classcom_1_1xuggle_1_1xuggler_1_1Packet-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00030">30</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#3ed06ddb9626ac451df7c27f06df4676">VS_JNIUTILS_REFCOUNTED_OBJECT</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#0c257cb75a15bcdb44adf2525457770b">getTimeStamp</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time stamp of this object in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6" title="Get the time base that time stamps of this object are represented in.">getTimeBase()</a> units.  <a href="#0c257cb75a15bcdb44adf2525457770b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#ad6a733dc0db1077b0742bfb38329c6a">setTimeStamp</a> (int64_t aTimeStamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the time stamp for this object in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6" title="Get the time base that time stamps of this object are represented in.">getTimeBase()</a> units.  <a href="#ad6a733dc0db1077b0742bfb38329c6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#0e27b069df8551e44e50ef988c9b6cf1">isKey</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this object a key object? i.e.  <a href="#0e27b069df8551e44e50ef988c9b6cf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6">getTimeBase</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time base that time stamps of this object are represented in.  <a href="#5fc1538475b76c746d8da0873c7172b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#1a66a34bc44517f0b7c85583b9c9260d">setTimeBase</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *aBase)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the time base that time stamps of this object are represented in.  <a href="#1a66a34bc44517f0b7c85583b9c9260d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dbea886b2c9414553bab1489d1e4a5b8">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear out any data in this packet, but leaves the buffer available for reuse.  <a href="#dbea886b2c9414553bab1489d1e4a5b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#d9d393b6d4ce835b13b4adfa7446d1c2">getPts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Presentation Time Stamp (PTS) for this packet.  <a href="#d9d393b6d4ce835b13b4adfa7446d1c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#a6814c3d4307b75f10aa5842bd7880ba">getDts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Decompression Time Stamp (DTS) for this packet.  <a href="#a6814c3d4307b75f10aa5842bd7880ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#4c853321e62895bbb8f1cafaed581850">getSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size in bytes of the payload currently in this packet.  <a href="#4c853321e62895bbb8f1cafaed581850"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#bd90fdcf4eb18ba4546acfe32a50abfd">getMaxSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum size (in bytes) of payload this packet can hold.  <a href="#bd90fdcf4eb18ba4546acfe32a50abfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#94e5c11280cc69b9b3eec511c92993bd">getStreamIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the container-specific index for the stream this packet is part of.  <a href="#94e5c11280cc69b9b3eec511c92993bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c1a2bceba197cab685cf52629d67aa9a">getFlags</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get any flags set on this packet, as a 4-byte binary-ORed bit-mask.  <a href="#c1a2bceba197cab685cf52629d67aa9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c7ee2d1198e2785fcddc6224441b616d">isKeyPacket</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this packet contain Key data? i.e.  <a href="#c7ee2d1198e2785fcddc6224441b616d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#b02d075e020ef593bf04aa9072a4826f">getDuration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the duration of this packet, in units of <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6">getTimeBase()</a>.  <a href="#b02d075e020ef593bf04aa9072a4826f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#d834c6179cb7f256d6b323fcb638c7cd">getPosition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the position (in bytes) of this packet in the stream.  <a href="#d834c6179cb7f256d6b323fcb638c7cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#8a524d6d4b22016ffb45f224963d820d">getData</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get any underlying raw data available for this object.  <a href="#8a524d6d4b22016ffb45f224963d820d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dd4917abffc5995af9f1878b233e821d">allocateNewPayload</a> (int32_t payloadSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard the current payload and allocate a new payload.  <a href="#dd4917abffc5995af9f1878b233e821d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#0cfd4ed15cd9320633f1e7713cd5ad7c">isComplete</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is this packet complete.  <a href="#0cfd4ed15cd9320633f1e7713cd5ad7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#f045ea9400b29ab72b4d3c5c92b47370">setKeyPacket</a> (bool keyPacket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set if this is a key packet.  <a href="#f045ea9400b29ab72b4d3c5c92b47370"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#b0d97f0b1c636126d9463457a9c87d36">setFlags</a> (int32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set any internal flags.  <a href="#b0d97f0b1c636126d9463457a9c87d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#9512706570a7d189e2a7cb4d68bd1fce">setPts</a> (int64_t pts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new Presentation Time Stamp (PTS) for this packet.  <a href="#9512706570a7d189e2a7cb4d68bd1fce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#f87e8f03b36b30c7a16cf274ffd7b0c9">setDts</a> (int64_t dts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a new Decompression Time Stamp (DTS) for this packet.  <a href="#f87e8f03b36b30c7a16cf274ffd7b0c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#460bf910ff440f570cb4b755b6325e79">setComplete</a> (bool complete, int32_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set if this packet is complete, and what the total size of the data should be assumed to be.  <a href="#460bf910ff440f570cb4b755b6325e79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#141e3d2de1de7faac30169237419bef7">setStreamIndex</a> (int32_t streamIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stream index for this packet.  <a href="#141e3d2de1de7faac30169237419bef7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#10908bcedc0b4d6fa2cdd15064ce2f19">setDuration</a> (int64_t duration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the duration.  <a href="#10908bcedc0b4d6fa2cdd15064ce2f19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c0e59128db8ccb4060d1868948a35d37">setPosition</a> (int64_t position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the position.  <a href="#c0e59128db8ccb4060d1868948a35d37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#0da8909ef01b256873f8468eb1fa641c">getConvergenceDuration</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time difference in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html#fca01046c42f14df5354cde52d087eeb">IStream#getTimeBase()</a> units from the presentation time stamp of this packet to the point at which the output from the decoder has converged independent from the availability of previous frames.  <a href="#0da8909ef01b256873f8468eb1fa641c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#42e0bbe27c3c951e6f7f767299ccbdca">setConvergenceDuration</a> (int64_t duration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the convergence duration.  <a href="#42e0bbe27c3c951e6f7f767299ccbdca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#bb64e700047a5d6e6e3aa4a633888f87">setData</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the underlying buffer used by this object.  <a href="#bb64e700047a5d6e6e3aa4a633888f87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AVPacket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#bf9329c24229930650ebb308b79a32c3">getAVPacket</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#9d486427ebcba7a23d5833f7b31c1a30">wrapAVPacket</a> (AVPacket *pkt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#54523451f0fe5688c0b946e69cbfee60">wrapBuffer</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *buffer)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#4587bb8ac750d613a6eb915561807818">make</a> (int32_t payloadSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new packet.  <a href="#4587bb8ac750d613a6eb915561807818"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5b877eef678dc7f76c3bb8a5990f6b91">make</a> (<a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new packet that wraps an existing IBuffer.  <a href="#5b877eef678dc7f76c3bb8a5990f6b91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#16fd1160d85fb651e5db2ff1c5146f14">make</a> (<a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> *packet, bool)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#73ee80b47bc0aba86020ba714a1ee7cd">freeAVBuffer</a> (void *buf, void *closure)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c3d8694ca60e82d6621ed2fe2c65c425">Packet</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#d283634a557583b07019cdd93c4f3748">~Packet</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c3d8694ca60e82d6621ed2fe2c65c425"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::Packet" ref="c3d8694ca60e82d6621ed2fe2c65c425" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::Packet::Packet           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00035">35</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00036"></a>00036   {
<a name="l00037"></a>00037     mPacket = (AVPacket*)av_malloc(<span class="keyword">sizeof</span>(AVPacket));
<a name="l00038"></a>00038     <span class="keywordflow">if</span> (!mPacket)
<a name="l00039"></a>00039       <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00040"></a>00040     
<a name="l00041"></a>00041     <span class="keywordflow">if</span> (mPacket)
<a name="l00042"></a>00042     {
<a name="l00043"></a>00043       <span class="comment">// initialize because ffmpeg doesn't</span>
<a name="l00044"></a>00044       av_init_packet(mPacket);
<a name="l00045"></a>00045       mPacket-&gt;data = 0;
<a name="l00046"></a>00046       mPacket-&gt;size = 0;
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048     mIsComplete = <span class="keyword">false</span>;
<a name="l00049"></a>00049   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d283634a557583b07019cdd93c4f3748"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::~Packet" ref="d283634a557583b07019cdd93c4f3748" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::Packet::~Packet           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00051">51</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00209">reset()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00052"></a>00052   {
<a name="l00053"></a>00053     <span class="keywordflow">if</span> (mPacket) {
<a name="l00054"></a>00054       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dbea886b2c9414553bab1489d1e4a5b8" title="Clear out any data in this packet, but leaves the buffer available for reuse.">reset</a>();
<a name="l00055"></a>00055       av_free(mPacket);
<a name="l00056"></a>00056     }
<a name="l00057"></a>00057     mPacket = 0;
<a name="l00058"></a>00058   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3ed06ddb9626ac451df7c27f06df4676"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::VS_JNIUTILS_REFCOUNTED_OBJECT" ref="3ed06ddb9626ac451df7c27f06df4676" args="(Packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">com::xuggle::xuggler::Packet::VS_JNIUTILS_REFCOUNTED_OBJECT           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4587bb8ac750d613a6eb915561807818"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::make" ref="4587bb8ac750d613a6eb915561807818" args="(int32_t payloadSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> * com::xuggle::xuggler::Packet::make           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new packet. 
<p>
Note that any buffers this packet needs will be lazily allocated (i.e. we won't actually grab all the memory until we need it).  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The maximum size, in bytes, of data you want to put in this packet.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new packet, or null on error. </dd></dl>

<p>Reimplemented from <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#191b933c111696c69e9f7a4b4211fa7e">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00220">220</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00307">allocateNewPayload()</a>, <a class="el" href="IPacket_8cpp-source.html#l00037">com::xuggle::xuggler::IPacket::make()</a>, and <a class="el" href="RefCounted_8h-source.html#l00230">VS_REF_RELEASE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00221"></a>00221   {
<a name="l00222"></a>00222     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c3d8694ca60e82d6621ed2fe2c65c425">Packet</a> *retval= 0;
<a name="l00223"></a>00223     <span class="keywordflow">try</span> {
<a name="l00224"></a>00224       retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">Packet::make</a>();
<a name="l00225"></a>00225       <span class="keywordflow">if</span> (retval-&gt;allocateNewPayload(payloadSize) &lt; 0)
<a name="l00226"></a>00226       {
<a name="l00227"></a>00227         <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00228"></a>00228       }
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230     <span class="keywordflow">catch</span> (std::bad_alloc &amp; e)
<a name="l00231"></a>00231     {
<a name="l00232"></a>00232       <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00233"></a>00233       <span class="keywordflow">throw</span> e;
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="keywordflow">return</span> retval;
<a name="l00237"></a>00237   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5b877eef678dc7f76c3bb8a5990f6b91"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::make" ref="5b877eef678dc7f76c3bb8a5990f6b91" args="(com::xuggle::ferry::IBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> * com::xuggle::xuggler::Packet::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a new packet that wraps an existing IBuffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The IBuffer to wrap. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new packet or null on error. </dd></dl>

<p>Reimplemented from <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#2d78a113fd46724f3b58ea18ef8e20ba">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00240">240</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="IPacket_8cpp-source.html#l00037">com::xuggle::xuggler::IPacket::make()</a>, and <a class="el" href="Packet_8cpp-source.html#l00360">wrapBuffer()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00241"></a>00241   {
<a name="l00242"></a>00242     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c3d8694ca60e82d6621ed2fe2c65c425">Packet</a> *retval= 0;
<a name="l00243"></a>00243     retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">Packet::make</a>();
<a name="l00244"></a>00244     <span class="keywordflow">if</span> (retval)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246       retval-&gt;wrapBuffer(buffer);
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248     <span class="keywordflow">return</span> retval;
<a name="l00249"></a>00249   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="16fd1160d85fb651e5db2ff1c5146f14"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::make" ref="16fd1160d85fb651e5db2ff1c5146f14" args="(Packet *packet, bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> * com::xuggle::xuggler::Packet::make           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>copyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00252">252</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00171">getData()</a>, <a class="el" href="Packet_8cpp-source.html#l00085">getSize()</a>, <a class="el" href="Packet_8h-source.html#l00049">getTimeBase()</a>, <a class="el" href="IPacket_8cpp-source.html#l00037">com::xuggle::xuggler::IPacket::make()</a>, <a class="el" href="Packet_8h-source.html#l00097">mPacket</a>, <a class="el" href="Packet_8cpp-source.html#l00130">setComplete()</a>, <a class="el" href="Packet_8h-source.html#l00050">setTimeBase()</a>, and <a class="el" href="RefCounted_8h-source.html#l00230">VS_REF_RELEASE</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00253"></a>00253   {
<a name="l00254"></a>00254     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c3d8694ca60e82d6621ed2fe2c65c425">Packet</a>* retval=0;
<a name="l00255"></a>00255     <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html" title="Allows Java code to get data from a native buffers, and optionally modify native...">com::xuggle::ferry::IBuffer</a> *buffer=0;
<a name="l00256"></a>00256     IRational* timeBase = 0;
<a name="l00257"></a>00257     <span class="keywordflow">try</span>
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259       <span class="keywordflow">if</span> (!packet)
<a name="l00260"></a>00260         <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">"need packet to copy"</span>);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262       <span class="keywordflow">if</span> (copyData)
<a name="l00263"></a>00263       {
<a name="l00264"></a>00264         int32_t numBytes = packet-&gt;getSize();
<a name="l00265"></a>00265         retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">make</a>(numBytes);
<a name="l00266"></a>00266         <span class="keywordflow">if</span> (!retval || !retval-&gt;mPacket || !retval-&gt;mPacket-&gt;data)
<a name="l00267"></a>00267           <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00268"></a>00268         <span class="keywordflow">if</span> (numBytes &gt; 0 &amp;&amp; packet-&gt;mPacket-&gt;data)
<a name="l00269"></a>00269           memcpy(retval-&gt;mPacket-&gt;data, packet-&gt;mPacket-&gt;data,
<a name="l00270"></a>00270               numBytes);
<a name="l00271"></a>00271       } <span class="keywordflow">else</span> {
<a name="l00272"></a>00272         buffer=packet-&gt;getData();
<a name="l00273"></a>00273         retval = <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#da604b3f9b413d547112409fa7b5ea3e" title="Allocate a new packet.">make</a>(buffer);
<a name="l00274"></a>00274         <span class="keywordflow">if</span> (!retval)
<a name="l00275"></a>00275           <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00276"></a>00276       }
<a name="l00277"></a>00277       <span class="comment">// Keep a copy of this, because we're going to nuke</span>
<a name="l00278"></a>00278       <span class="comment">// it temporarily.</span>
<a name="l00279"></a>00279       uint8_t* data_buf = retval-&gt;mPacket-&gt;data;
<a name="l00280"></a>00280       void (*orig_destruct)(<span class="keyword">struct </span>AVPacket *) = retval-&gt;mPacket-&gt;destruct;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282       <span class="comment">// copy all data members, including data and size,</span>
<a name="l00283"></a>00283       <span class="comment">// but we'll overwrite those next.</span>
<a name="l00284"></a>00284       *(retval-&gt;mPacket) = *(packet-&gt;mPacket);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286       retval-&gt;mPacket-&gt;data = data_buf;
<a name="l00287"></a>00287       retval-&gt;mPacket-&gt;destruct = orig_destruct;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289       <span class="comment">// separate here to catch addRef()</span>
<a name="l00290"></a>00290       timeBase = packet-&gt;getTimeBase();
<a name="l00291"></a>00291       retval-&gt;setTimeBase(timeBase);
<a name="l00292"></a>00292 
<a name="l00293"></a>00293       retval-&gt;setComplete(retval-&gt;mPacket-&gt;size &gt; 0,
<a name="l00294"></a>00294           retval-&gt;mPacket-&gt;size);
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296     <span class="keywordflow">catch</span> (std::exception &amp;e)
<a name="l00297"></a>00297     {
<a name="l00298"></a>00298       <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(retval);
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300     <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(buffer);
<a name="l00301"></a>00301     <a class="code" href="RefCounted_8h.html#90e04e77a467e22dde38932cd10a3e08">VS_REF_RELEASE</a>(timeBase);
<a name="l00302"></a>00302     
<a name="l00303"></a>00303     <span class="keywordflow">return</span> retval;
<a name="l00304"></a>00304   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0c257cb75a15bcdb44adf2525457770b"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getTimeStamp" ref="0c257cb75a15bcdb44adf2525457770b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t com::xuggle::xuggler::Packet::getTimeStamp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the time stamp of this object in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6" title="Get the time base that time stamps of this object are represented in.">getTimeBase()</a> units. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time stamp </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#bd468b57257067c3796e219bfa841b7f">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00046">46</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00073">getDts()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 { <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#a6814c3d4307b75f10aa5842bd7880ba" title="Get the Decompression Time Stamp (DTS) for this packet.">getDts</a>(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ad6a733dc0db1077b0742bfb38329c6a"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setTimeStamp" ref="ad6a733dc0db1077b0742bfb38329c6a" args="(int64_t aTimeStamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::Packet::setTimeStamp           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>aTimeStamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time stamp for this object in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6" title="Get the time base that time stamps of this object are represented in.">getTimeBase()</a> units. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeStamp</em>&nbsp;</td><td>The time stamp </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#3ac9b027edaee5c826dda311c6d11d2d">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00047">47</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00079">setDts()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00047"></a>00047 { <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#f87e8f03b36b30c7a16cf274ffd7b0c9" title="Set a new Decompression Time Stamp (DTS) for this packet.">setDts</a>(aTimeStamp); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0e27b069df8551e44e50ef988c9b6cf1"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::isKey" ref="0e27b069df8551e44e50ef988c9b6cf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool com::xuggle::xuggler::Packet::isKey           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this object a key object? i.e. 
<p>
it can be interpreted without needing any other media objects<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if it's a key, false if not </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#e07fc3e2594c5b7a91df80828240c88d">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00048">48</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00105">isKeyPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00048"></a>00048 { <span class="keywordflow">return</span> <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#c7ee2d1198e2785fcddc6224441b616d" title="Does this packet contain Key data? i.e.">isKeyPacket</a>(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5fc1538475b76c746d8da0873c7172b6"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getTimeBase" ref="5fc1538475b76c746d8da0873c7172b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a>* com::xuggle::xuggler::Packet::getTimeBase           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the time base that time stamps of this object are represented in. 
<p>
Caller must release the returned value.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the time base. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#dd759896cb9c5bc4a4c83a6486c8e781">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00049">49</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00252">make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00049"></a>00049 { <span class="keywordflow">return</span> mTimeBase.get(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1a66a34bc44517f0b7c85583b9c9260d"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setTimeBase" ref="1a66a34bc44517f0b7c85583b9c9260d" args="(IRational *aBase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void com::xuggle::xuggler::Packet::setTimeBase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IRational.html">IRational</a> *&nbsp;</td>
          <td class="paramname"> <em>aBase</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time base that time stamps of this object are represented in. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aBase</em>&nbsp;</td><td>the new time base. If null an exception is thrown. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#f6214100f35e890b49ca9643c0ebbb4f">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00050">50</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00252">make()</a>, and <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00050"></a>00050 { mTimeBase.reset(aBase, <span class="keyword">true</span>); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dbea886b2c9414553bab1489d1e4a5b8"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::reset" ref="dbea886b2c9414553bab1489d1e4a5b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear out any data in this packet, but leaves the buffer available for reuse. 
<p>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#94c2e86543411cb1b33fa61a708982a8">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00209">209</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00130">setComplete()</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00307">allocateNewPayload()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01230">com::xuggle::xuggler::StreamCoder::encodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01007">com::xuggle::xuggler::StreamCoder::encodeVideo()</a>, <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>, <a class="el" href="Packet_8cpp-source.html#l00360">wrapBuffer()</a>, and <a class="el" href="Packet_8cpp-source.html#l00051">~Packet()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00210"></a>00210   {
<a name="l00211"></a>00211     <span class="keywordflow">if</span> (mPacket) {
<a name="l00212"></a>00212       av_free_packet(mPacket);
<a name="l00213"></a>00213       av_init_packet(mPacket);
<a name="l00214"></a>00214     }
<a name="l00215"></a>00215     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#460bf910ff440f570cb4b755b6325e79" title="Set if this packet is complete, and what the total size of the data should be assumed...">setComplete</a>(<span class="keyword">false</span>, 0);
<a name="l00216"></a>00216     <span class="comment">// Don't reset the buffer though; we can potentially reuse it.</span>
<a name="l00217"></a>00217   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d9d393b6d4ce835b13b4adfa7446d1c2"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getPts" ref="d9d393b6d4ce835b13b4adfa7446d1c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Packet::getPts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Presentation Time Stamp (PTS) for this packet. 
<p>
This is the time at which the payload for this packet should be <b>presented</b> to the user, in units of <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6">getTimeBase()</a>, relative to the start of stream.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Get the Presentation Timestamp for this packet. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8c621ea3313e177521ee7819eebb1e8f">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00061">61</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">com::xuggle::xuggler::StreamCoder::decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">com::xuggle::xuggler::StreamCoder::decodeVideo()</a>, and <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00062"></a>00062   {
<a name="l00063"></a>00063     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;pts : (int64_t)-1);
<a name="l00064"></a>00064   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a6814c3d4307b75f10aa5842bd7880ba"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getDts" ref="a6814c3d4307b75f10aa5842bd7880ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Packet::getDts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Decompression Time Stamp (DTS) for this packet. 
<p>
This is the time at which the payload for this packet should be <b>decompressed</b>, in units of <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6">getTimeBase()</a>, relative to the start of stream.  <p>
Some media codecs can require packets from the "future" to be decompressed before earliest packets as an additional way to compress data. In general you don't need to worry about this, but if you're curious start reading about the difference between I-Frames, P-Frames and B-Frames (or Bi-Directional Frames). B-Frames can use information from future frames when compressed.  <dl class="return" compact><dt><b>Returns:</b></dt><dd>Get the Decompression Timestamp (i.e. when this was read relative to the start of reading packets). </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#9c6ae314276fdb16ac6de9099dc6eba2">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00073">73</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">com::xuggle::xuggler::StreamCoder::decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">com::xuggle::xuggler::StreamCoder::decodeVideo()</a>, <a class="el" href="Packet_8h-source.html#l00046">getTimeStamp()</a>, and <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00074"></a>00074   {
<a name="l00075"></a>00075     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;dts : (int64_t)-1);
<a name="l00076"></a>00076   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4c853321e62895bbb8f1cafaed581850"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getSize" ref="4c853321e62895bbb8f1cafaed581850" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Packet::getSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size in bytes of the payload currently in this packet. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size (in bytes) of payload currently in packet. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#f4a2783b43a5dadd3ba114f0505f6a44">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00085">85</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">com::xuggle::xuggler::StreamCoder::decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">com::xuggle::xuggler::StreamCoder::decodeVideo()</a>, <a class="el" href="Packet_8cpp-source.html#l00252">make()</a>, <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>, and <a class="el" href="Container_8cpp-source.html#l00557">com::xuggle::xuggler::Container::writePacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00086"></a>00086   {
<a name="l00087"></a>00087     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;size: (int32_t)-1);
<a name="l00088"></a>00088   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bd90fdcf4eb18ba4546acfe32a50abfd"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getMaxSize" ref="bd90fdcf4eb18ba4546acfe32a50abfd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Packet::getMaxSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum size (in bytes) of payload this packet can hold. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Get maximum size (in bytes) of payload this packet can hold. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#617ca0638341d8180b1c05f9ed3d3ca7">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00090">90</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00091"></a>00091   {
<a name="l00092"></a>00092     <span class="keywordflow">return</span> (mBuffer ? mBuffer-&gt;getBufferSize() : -1);
<a name="l00093"></a>00093   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="94e5c11280cc69b9b3eec511c92993bd"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getStreamIndex" ref="94e5c11280cc69b9b3eec511c92993bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Packet::getStreamIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the container-specific index for the stream this packet is part of. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Stream.html">Stream</a> in container that this packet has data for. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#496a5941981febcab6cd96297a8e1ddd">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00095">95</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>, and <a class="el" href="Container_8cpp-source.html#l00557">com::xuggle::xuggler::Container::writePacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00096"></a>00096   {
<a name="l00097"></a>00097     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;stream_index: (int32_t)-1);
<a name="l00098"></a>00098   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c1a2bceba197cab685cf52629d67aa9a"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getFlags" ref="c1a2bceba197cab685cf52629d67aa9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Packet::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get any flags set on this packet, as a 4-byte binary-ORed bit-mask. 
<p>
This is access to raw FFMPEG flags, but it is easier to use the is* methods below. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Any flags on the packet. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#ac8a99969a2bbfc8d817cefbac314dcc">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00100">100</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00101"></a>00101   {
<a name="l00102"></a>00102     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;flags: (int32_t)-1);
<a name="l00103"></a>00103   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c7ee2d1198e2785fcddc6224441b616d"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::isKeyPacket" ref="c7ee2d1198e2785fcddc6224441b616d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Packet::isKeyPacket           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does this packet contain Key data? i.e. 
<p>
data that needs no other frames or samples to decode. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if key; false otherwise. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#00d55bd725c6ea66438d41c18be6350f">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00105">105</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Packet_8h-source.html#l00048">isKey()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00106"></a>00106   {
<a name="l00107"></a>00107     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;flags &amp; AV_PKT_FLAG_KEY : <span class="keyword">false</span>);
<a name="l00108"></a>00108   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b02d075e020ef593bf04aa9072a4826f"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getDuration" ref="b02d075e020ef593bf04aa9072a4826f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Packet::getDuration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the duration of this packet, in units of <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#5fc1538475b76c746d8da0873c7172b6">getTimeBase()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Duration of this packet, in same time-base as the PTS. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#0b8c9590ae59b184599302247d6a034f">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00147">147</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00148"></a>00148   {
<a name="l00149"></a>00149     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;duration: (int64_t)-1);
<a name="l00150"></a>00150   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d834c6179cb7f256d6b323fcb638c7cd"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getPosition" ref="d834c6179cb7f256d6b323fcb638c7cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Packet::getPosition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the position (in bytes) of this packet in the stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The position of this packet in the stream, or -1 if unknown. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#58e33fdb928aac7b35c942b27746e1e2">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00159">159</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00160"></a>00160   {
<a name="l00161"></a>00161     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;pos: (int64_t)-1);
<a name="l00162"></a>00162   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8a524d6d4b22016ffb45f224963d820d"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getData" ref="8a524d6d4b22016ffb45f224963d820d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> * com::xuggle::xuggler::Packet::getData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get any underlying raw data available for this object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The raw data, or null if not accessible. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#cb725e52fa3f5431896658a805a38272">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00171">171</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="RefPointer_8h-source.html#l00206">com::xuggle::ferry::RefPointer&lt; T &gt;::get()</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">com::xuggle::xuggler::StreamCoder::decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">com::xuggle::xuggler::StreamCoder::decodeVideo()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01230">com::xuggle::xuggler::StreamCoder::encodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01007">com::xuggle::xuggler::StreamCoder::encodeVideo()</a>, and <a class="el" href="Packet_8cpp-source.html#l00252">make()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00172"></a>00172   {
<a name="l00173"></a>00173     <span class="keywordflow">return</span> mBuffer.<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#deb150bcd9d22a22c13117ef83bc91a1" title="Call RefCounted::acquire() on the managed pointer and return it.">get</a>();
<a name="l00174"></a>00174   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dd4917abffc5995af9f1878b233e821d"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::allocateNewPayload" ref="dd4917abffc5995af9f1878b233e821d" args="(int32_t payloadSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t com::xuggle::xuggler::Packet::allocateNewPayload           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>payloadSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discard the current payload and allocate a new payload. 
<p>
Note that if any people have access to the old payload using <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#8a524d6d4b22016ffb45f224963d820d" title="Get any underlying raw data available for this object.">getData()</a>, the memory will continue to be available to them until they release their hold of the IBuffer.  <p>
When requesting a packet size, the system may allocate a larger payloadSize.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>payloadSize</em>&nbsp;</td><td>The (minimum) payloadSize of this packet in bytes.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt;= 0 if successful. &lt; 0 if error. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#10165d16b2227eb3ca5237250e113e71">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00307">307</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00388">freeAVBuffer()</a>, <a class="el" href="Buffer_8cpp-source.html#l00091">com::xuggle::ferry::Buffer::make()</a>, <a class="el" href="Packet_8cpp-source.html#l00209">reset()</a>, <a class="el" href="Packet_8cpp-source.html#l00130">setComplete()</a>, and <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l01230">com::xuggle::xuggler::StreamCoder::encodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l01007">com::xuggle::xuggler::StreamCoder::encodeVideo()</a>, <a class="el" href="Packet_8cpp-source.html#l00220">make()</a>, and <a class="el" href="Packet_8cpp-source.html#l00177">wrapAVPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00308"></a>00308   {
<a name="l00309"></a>00309     int32_t retval = -1;
<a name="l00310"></a>00310     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dbea886b2c9414553bab1489d1e4a5b8" title="Clear out any data in this packet, but leaves the buffer available for reuse.">reset</a>();
<a name="l00311"></a>00311     uint8_t* payload = 0;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="comment">// Some FFMPEG encoders will read past the end of a</span>
<a name="l00314"></a>00314     <span class="comment">// buffer, so you need to allocate extra; yuck.</span>
<a name="l00315"></a>00315     <span class="keywordflow">if</span> (!mBuffer || mBuffer-&gt;getBufferSize() &lt; payloadSize)
<a name="l00316"></a>00316     {
<a name="l00317"></a>00317       <span class="comment">// buffer isn't big enough; we need to make a new one.</span>
<a name="l00318"></a>00318       payload = (uint8_t*) av_malloc(payloadSize+FF_INPUT_BUFFER_PADDING_SIZE);
<a name="l00319"></a>00319       <span class="keywordflow">if</span> (!payload)
<a name="l00320"></a>00320         <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00321"></a>00321       
<a name="l00322"></a>00322       <span class="comment">// we don't use the JVM for packets because Ffmpeg is REAL squirly about that</span>
<a name="l00323"></a>00323       mBuffer = <a class="code" href="classcom_1_1xuggle_1_1ferry_1_1Buffer.html#8be88d8588508e4b74a2cdd4657dd1c3" title="Allocate a new buffer of at least bufferSize.">Buffer::make</a>(0, payload,
<a name="l00324"></a>00324           payloadSize,
<a name="l00325"></a>00325           <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#73ee80b47bc0aba86020ba714a1ee7cd">Packet::freeAVBuffer</a>, 0);
<a name="l00326"></a>00326       <span class="keywordflow">if</span> (!mBuffer) {
<a name="l00327"></a>00327         av_free(payload);
<a name="l00328"></a>00328         <span class="keywordflow">throw</span> std::bad_alloc();
<a name="l00329"></a>00329       }
<a name="l00330"></a>00330       <span class="comment">// and memset the padding area.</span>
<a name="l00331"></a>00331       memset(payload + payloadSize,
<a name="l00332"></a>00332           0,
<a name="l00333"></a>00333           FF_INPUT_BUFFER_PADDING_SIZE);
<a name="l00334"></a>00334     } <span class="keywordflow">else</span> {
<a name="l00335"></a>00335       payload = (uint8_t*)mBuffer-&gt;getBytes(0, payloadSize);
<a name="l00336"></a>00336     }
<a name="l00337"></a>00337     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mPacket, <span class="stringliteral">"Should already have a packet"</span>);
<a name="l00338"></a>00338     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mBuffer, <span class="stringliteral">"Should have allocated a buffer"</span>);
<a name="l00339"></a>00339     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(payload, <span class="stringliteral">"Should have allocated a payload"</span>);
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (mBuffer &amp;&amp; mPacket)
<a name="l00341"></a>00341     {
<a name="l00342"></a>00342       mPacket-&gt;data = payload;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344       <span class="comment">// And start out at zero.</span>
<a name="l00345"></a>00345       mPacket-&gt;size = 0;
<a name="l00346"></a>00346       this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#460bf910ff440f570cb4b755b6325e79" title="Set if this packet is complete, and what the total size of the data should be assumed...">setComplete</a>(<span class="keyword">false</span>, 0);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348       retval = 0;
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350     <span class="keywordflow">return</span> retval;
<a name="l00351"></a>00351   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0cfd4ed15cd9320633f1e7713cd5ad7c"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::isComplete" ref="0cfd4ed15cd9320633f1e7713cd5ad7c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool com::xuggle::xuggler::Packet::isComplete           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this packet complete. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Is this packet full and therefore has valid information. </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8a905262cb3774db3f36f48749f7e56b">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00382">382</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00557">com::xuggle::xuggler::Container::writePacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00383"></a>00383   {
<a name="l00384"></a>00384     <span class="keywordflow">return</span> mIsComplete &amp;&amp; mPacket-&gt;data;
<a name="l00385"></a>00385   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f045ea9400b29ab72b4d3c5c92b47370"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setKeyPacket" ref="f045ea9400b29ab72b4d3c5c92b47370" args="(bool keyPacket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setKeyPacket           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keyPacket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if this is a key packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyPacket</em>&nbsp;</td><td>true for yes, false for no. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#65c1f09afd1c61eccf21b2a16581648c">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00111">111</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00112"></a>00112   {
<a name="l00113"></a>00113     <span class="keywordflow">if</span> (mPacket)
<a name="l00114"></a>00114     {
<a name="l00115"></a>00115       <span class="keywordflow">if</span> (bKeyPacket)
<a name="l00116"></a>00116         mPacket-&gt;flags |= AV_PKT_FLAG_KEY;
<a name="l00117"></a>00117       <span class="keywordflow">else</span>
<a name="l00118"></a>00118         mPacket-&gt;flags = 0;
<a name="l00119"></a>00119     }
<a name="l00120"></a>00120   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b0d97f0b1c636126d9463457a9c87d36"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setFlags" ref="b0d97f0b1c636126d9463457a9c87d36" args="(int32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setFlags           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set any internal flags. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to set </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#8e2845273ecd719451183a8cbb562614">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00123">123</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00124"></a>00124   {
<a name="l00125"></a>00125     <span class="keywordflow">if</span> (mPacket)
<a name="l00126"></a>00126       mPacket-&gt;flags = flags;
<a name="l00127"></a>00127   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9512706570a7d189e2a7cb4d68bd1fce"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setPts" ref="9512706570a7d189e2a7cb4d68bd1fce" args="(int64_t pts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setPts           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>aPts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a new Presentation Time Stamp (PTS) for this packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPts</em>&nbsp;</td><td>a new PTS for this packet.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#d9d393b6d4ce835b13b4adfa7446d1c2" title="Get the Presentation Time Stamp (PTS) for this packet.">getPts()</a> </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#0bce76e19b8fc4302124eb5bde256162">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00067">67</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00068"></a>00068   {
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (mPacket) mPacket-&gt;pts = aPts;
<a name="l00070"></a>00070   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f87e8f03b36b30c7a16cf274ffd7b0c9"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setDts" ref="f87e8f03b36b30c7a16cf274ffd7b0c9" args="(int64_t dts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setDts           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>aDts</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a new Decompression Time Stamp (DTS) for this packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDts</em>&nbsp;</td><td>a new DTS for this packet. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#a6814c3d4307b75f10aa5842bd7880ba" title="Get the Decompression Time Stamp (DTS) for this packet.">getDts()</a> </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#f150e8cae1fe7bedaf615da79b54b1ab">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00079">79</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Packet_8h-source.html#l00047">setTimeStamp()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00080"></a>00080   {
<a name="l00081"></a>00081     <span class="keywordflow">if</span> (mPacket) mPacket-&gt;dts = aDts;
<a name="l00082"></a>00082   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="460bf910ff440f570cb4b755b6325e79"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setComplete" ref="460bf910ff440f570cb4b755b6325e79" args="(bool complete, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setComplete           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>complete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set if this packet is complete, and what the total size of the data should be assumed to be. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>complete</em>&nbsp;</td><td>True for complete, false for not. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of data in packet. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#397eb086a31a47ca44708bbfd9357d18">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00130">130</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00307">allocateNewPayload()</a>, <a class="el" href="Packet_8cpp-source.html#l00252">make()</a>, <a class="el" href="Packet_8cpp-source.html#l00209">reset()</a>, <a class="el" href="Packet_8cpp-source.html#l00177">wrapAVPacket()</a>, and <a class="el" href="Packet_8cpp-source.html#l00360">wrapBuffer()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00131"></a>00131   {
<a name="l00132"></a>00132     mIsComplete = complete;
<a name="l00133"></a>00133     <span class="keywordflow">if</span> (mIsComplete)
<a name="l00134"></a>00134     {
<a name="l00135"></a>00135       <span class="keywordflow">if</span> (mPacket)
<a name="l00136"></a>00136         mPacket-&gt;size = size;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="141e3d2de1de7faac30169237419bef7"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setStreamIndex" ref="141e3d2de1de7faac30169237419bef7" args="(int32_t streamIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setStreamIndex           </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>streamIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stream index for this packet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streamIndex</em>&nbsp;</td><td>The stream index, as determined from the <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IContainer.html">IContainer</a> this packet will be written to. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#bc128a9a747950fe43a891e8fc6ddf3f">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00141">141</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00142"></a>00142   {
<a name="l00143"></a>00143     <span class="keywordflow">if</span> (mPacket)
<a name="l00144"></a>00144       mPacket-&gt;stream_index = streamIndex;
<a name="l00145"></a>00145   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="10908bcedc0b4d6fa2cdd15064ce2f19"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setDuration" ref="10908bcedc0b4d6fa2cdd15064ce2f19" args="(int64_t duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setDuration           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>duration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the duration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>duration</em>&nbsp;</td><td>new duration </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#b02d075e020ef593bf04aa9072a4826f" title="Return the duration of this packet, in units of getTimeBase().">getDuration()</a> </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#26b2a9ea095b0a58e796b3659f308278">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00153">153</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00154"></a>00154   {
<a name="l00155"></a>00155     <span class="keywordflow">if</span> (mPacket) mPacket-&gt;duration = duration;
<a name="l00156"></a>00156   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c0e59128db8ccb4060d1868948a35d37"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setPosition" ref="c0e59128db8ccb4060d1868948a35d37" args="(int64_t position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setPosition           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>position</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>new position </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#d834c6179cb7f256d6b323fcb638c7cd" title="Return the position (in bytes) of this packet in the stream.">getPosition()</a> </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#3c8c7e6086f15378a67630b6c7be429d">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00165">165</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00166"></a>00166   {
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (mPacket) mPacket-&gt;pos = position;
<a name="l00168"></a>00168   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0da8909ef01b256873f8468eb1fa641c"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getConvergenceDuration" ref="0da8909ef01b256873f8468eb1fa641c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t com::xuggle::xuggler::Packet::getConvergenceDuration           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Time difference in <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IStream.html#fca01046c42f14df5354cde52d087eeb">IStream#getTimeBase()</a> units from the presentation time stamp of this packet to the point at which the output from the decoder has converged independent from the availability of previous frames. 
<p>
That is, the frames are virtually identical no matter if decoding started from the very first frame or from this keyframe. Is <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1Global.html#3ad04b8c773456d7ae083f34eead4382">Global#NO_PTS</a> if unknown. This field is not the display duration of the current packet. <p>
The purpose of this field is to allow seeking in streams that have no keyframes in the conventional sense. It corresponds to the recovery point SEI in H.264 and match_time_delta in NUT. It is also essential for some types of subtitle streams to ensure that all subtitles are correctly displayed after seeking.  <p>
If you didn't follow that, try drinking one to two glasses of Absinthe. It won't help, but it'll be more fun. <p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the convergence duration </dd></dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#d8b7b263d4b6032154c8094c1e5bf84b">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00398">398</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00399"></a>00399   {
<a name="l00400"></a>00400     <span class="keywordflow">return</span> (mPacket ? mPacket-&gt;convergence_duration : -1);
<a name="l00401"></a>00401   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="42e0bbe27c3c951e6f7f767299ccbdca"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setConvergenceDuration" ref="42e0bbe27c3c951e6f7f767299ccbdca" args="(int64_t duration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setConvergenceDuration           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>duration</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the convergence duration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>duration</em>&nbsp;</td><td>the new duration </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IPacket.html#c6e68cd5e6c6ea42fd7ef5c6e53b8880">com::xuggle::xuggler::IPacket</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00404">404</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00405"></a>00405   {
<a name="l00406"></a>00406     <span class="keywordflow">if</span> (mPacket) mPacket-&gt;convergence_duration = duration;
<a name="l00407"></a>00407   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bb64e700047a5d6e6e3aa4a633888f87"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::setData" ref="bb64e700047a5d6e6e3aa4a633888f87" args="(com::xuggle::ferry::IBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::setData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the underlying buffer used by this object. 
<p>
This is an advanced method and is not recommended for use by those who don't fully understand how IBuffers work. Implementations of <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html">IMediaData</a> may behave in undefined ways if the buffer you pass in is not big enough for what you ask them to do (e.g. they may discard your buffer and allocate a larger one if they need more space). It is up to the caller to ensure the buffer passed in is large enough, and is not simultaneously in use by another part of the system.  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to set. If null, this method is ignored. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classcom_1_1xuggle_1_1xuggler_1_1IMediaData.html#02f8ea2b694ace798aae304e1dbbafdc">com::xuggle::xuggler::IMediaData</a>.</p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00354">354</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00360">wrapBuffer()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00355"></a>00355   {
<a name="l00356"></a>00356     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#54523451f0fe5688c0b946e69cbfee60">wrapBuffer</a>(buffer);
<a name="l00357"></a>00357   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="bf9329c24229930650ebb308b79a32c3"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::getAVPacket" ref="bf9329c24229930650ebb308b79a32c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVPacket* com::xuggle::xuggler::Packet::getAVPacket           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8h-source.html#l00081">81</a> of file <a class="el" href="Packet_8h-source.html">Packet.h</a>.</p>

<p>Referenced by <a class="el" href="StreamCoder_8cpp-source.html#l00677">com::xuggle::xuggler::StreamCoder::decodeAudio()</a>, <a class="el" href="StreamCoder_8cpp-source.html#l00861">com::xuggle::xuggler::StreamCoder::decodeVideo()</a>, and <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00081"></a>00081 { <span class="keywordflow">return</span> mPacket; }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9d486427ebcba7a23d5833f7b31c1a30"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::wrapAVPacket" ref="9d486427ebcba7a23d5833f7b31c1a30" args="(AVPacket *pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::wrapAVPacket           </td>
          <td>(</td>
          <td class="paramtype">AVPacket *&nbsp;</td>
          <td class="paramname"> <em>pkt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00177">177</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="Packet_8cpp-source.html#l00307">allocateNewPayload()</a>, <a class="el" href="Packet_8cpp-source.html#l00130">setComplete()</a>, and <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="Container_8cpp-source.html#l00495">com::xuggle::xuggler::Container::readNextPacket()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00178"></a>00178   {
<a name="l00179"></a>00179     <span class="comment">// WE ALWAYS COPY the data; Let Ffmpeg do what it wants</span>
<a name="l00180"></a>00180     <span class="comment">// to with it's own memory.</span>
<a name="l00181"></a>00181     <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mPacket, <span class="stringliteral">"No packet?"</span>);
<a name="l00182"></a>00182     
<a name="l00183"></a>00183     <span class="comment">// Make sure we have a buffer at least as large as this packet</span>
<a name="l00184"></a>00184     <span class="comment">// This overwrites data, which we'll patch below.</span>
<a name="l00185"></a>00185     (void) this-&gt;<a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dd4917abffc5995af9f1878b233e821d" title="Discard the current payload and allocate a new payload.">allocateNewPayload</a>(pkt-&gt;size);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">// Keep a copy of this, because we're going to nuke</span>
<a name="l00188"></a>00188     <span class="comment">// it temporarily.</span>
<a name="l00189"></a>00189     uint8_t* data_buf = mPacket-&gt;data;
<a name="l00190"></a>00190     void (*orig_destruct)(<span class="keyword">struct </span>AVPacket *) = mPacket-&gt;destruct;
<a name="l00191"></a>00191     
<a name="l00192"></a>00192     <span class="comment">// copy all data members, including data and size,</span>
<a name="l00193"></a>00193     <span class="comment">// but we'll overwrite those next.</span>
<a name="l00194"></a>00194     *mPacket = *pkt;
<a name="l00195"></a>00195     <span class="comment">// Reset the data buf.</span>
<a name="l00196"></a>00196     mPacket-&gt;data = data_buf;
<a name="l00197"></a>00197     mPacket-&gt;destruct = orig_destruct;
<a name="l00198"></a>00198     mPacket-&gt;size = pkt-&gt;size;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     <span class="comment">// Copy the contents of the new packet into data.</span>
<a name="l00201"></a>00201     if (pkt-&gt;data &amp;&amp; pkt-&gt;size)
<a name="l00202"></a>00202       memcpy(mPacket-&gt;data, pkt-&gt;data, pkt-&gt;size);
<a name="l00203"></a>00203     
<a name="l00204"></a>00204     <span class="comment">// And assume we're now complete.</span>
<a name="l00205"></a>00205     <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#460bf910ff440f570cb4b755b6325e79" title="Set if this packet is complete, and what the total size of the data should be assumed...">setComplete</a>(<span class="keyword">true</span>, mPacket-&gt;size);
<a name="l00206"></a>00206   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="54523451f0fe5688c0b946e69cbfee60"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::wrapBuffer" ref="54523451f0fe5688c0b946e69cbfee60" args="(com::xuggle::ferry::IBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::wrapBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcom_1_1xuggle_1_1ferry_1_1IBuffer.html">com::xuggle::ferry::IBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00360">360</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>References <a class="el" href="RefPointer_8h-source.html#l00237">com::xuggle::ferry::RefPointer&lt; T &gt;::reset()</a>, <a class="el" href="Packet_8cpp-source.html#l00209">reset()</a>, <a class="el" href="Packet_8cpp-source.html#l00130">setComplete()</a>, <a class="el" href="RefPointer_8h-source.html#l00226">com::xuggle::ferry::RefPointer&lt; T &gt;::value()</a>, and <a class="el" href="Logger_8h-source.html#l00207">VS_ASSERT</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00240">make()</a>, and <a class="el" href="Packet_8cpp-source.html#l00354">setData()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00361"></a>00361   {
<a name="l00362"></a>00362     <span class="keywordflow">if</span> (buffer != mBuffer.<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#b1538ab848cc19e5aa7ec627afa2a853" title="Return the managed pointer without calling RefCounted::acquire() on it.">value</a>())
<a name="l00363"></a>00363     {
<a name="l00364"></a>00364       <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#dbea886b2c9414553bab1489d1e4a5b8" title="Clear out any data in this packet, but leaves the buffer available for reuse.">reset</a>();
<a name="l00365"></a>00365       <span class="comment">// and acquire this buffer.</span>
<a name="l00366"></a>00366       mBuffer.<a class="code" href="classcom_1_1xuggle_1_1ferry_1_1RefPointer.html#b899de28a26a25ca63155aae9530f9f1" title="Reset the managed pointer, calling RefCounted::release() on the previously managed...">reset</a>(buffer, <span class="keyword">true</span>);
<a name="l00367"></a>00367     }
<a name="l00368"></a>00368     <span class="keywordflow">if</span> (mBuffer)
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370       <span class="comment">// and patch up our AVPacket</span>
<a name="l00371"></a>00371       <a class="code" href="Logger_8h.html#cc63c47c2830d2158599b12926d7daee">VS_ASSERT</a>(mPacket, <span class="stringliteral">"No AVPacket"</span>);
<a name="l00372"></a>00372       <span class="keywordflow">if</span> (mPacket)
<a name="l00373"></a>00373       {
<a name="l00374"></a>00374         mPacket-&gt;size = mBuffer-&gt;getBufferSize();
<a name="l00375"></a>00375         mPacket-&gt;data = (uint8_t*)mBuffer-&gt;getBytes(0, mPacket-&gt;size);
<a name="l00376"></a>00376         <span class="comment">// And assume we're now complete.</span>
<a name="l00377"></a>00377         <a class="code" href="classcom_1_1xuggle_1_1xuggler_1_1Packet.html#460bf910ff440f570cb4b755b6325e79" title="Set if this packet is complete, and what the total size of the data should be assumed...">setComplete</a>(<span class="keyword">true</span>, mPacket-&gt;size);
<a name="l00378"></a>00378       }
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="73ee80b47bc0aba86020ba714a1ee7cd"></a><!-- doxytag: member="com::xuggle::xuggler::Packet::freeAVBuffer" ref="73ee80b47bc0aba86020ba714a1ee7cd" args="(void *buf, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void com::xuggle::xuggler::Packet::freeAVBuffer           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>closure</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="Packet_8cpp-source.html#l00388">388</a> of file <a class="el" href="Packet_8cpp-source.html">Packet.cpp</a>.</p>

<p>Referenced by <a class="el" href="Packet_8cpp-source.html#l00307">allocateNewPayload()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00389"></a>00389   {
<a name="l00390"></a>00390     <span class="comment">// We know that FFMPEG allocated this with av_malloc, but</span>
<a name="l00391"></a>00391     <span class="comment">// that might change in future versions; so this is</span>
<a name="l00392"></a>00392     <span class="comment">// inherently somewhat dangerous.</span>
<a name="l00393"></a>00393     (void) closure;
<a name="l00394"></a>00394     av_free(buf);
<a name="l00395"></a>00395   }
</pre></div>
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>csrc/com/xuggle/xuggler/<a class="el" href="Packet_8h-source.html">Packet.h</a><li>csrc/com/xuggle/xuggler/<a class="el" href="Packet_8cpp-source.html">Packet.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 11 07:40:13 2011 for Xuggle by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
